# 第4章 - 树

## 主要内容一览

【todo：思维导图】

<br />

## 基本概念

| 概念     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 树       | $N$ 个结点，$N-1$ 条边，除根结点外，其余结点都有且只有一条边指向其父结点。 |
| 根       | 无父亲的结点。                                               |
| 树叶     | 无儿子的结点。                                               |
| 兄弟     | 有相同父亲的结点。                                           |
| 祖父     | 父结点的父结点。                                             |
| 孙子     | 儿子结点的儿子结点。                                         |
| 路径     | 从 $n_1$ 结点到 $n_k$ 结点的结点序列。                       |
| 路径的长 | $n_1$ 结点到 $n_k$ 结点路径的边的条数，即路径上结点数减 1，$k-1$。 |
| 深度     | $n_k$ 结点的深度为根到 $n_k$ 结点的唯一路径的长，根的深度为 0，树的深度等于深度最大的树叶的深度，等于该树的高度。<br />结点 $x$ 的深度：from root to x<br />树的深度：from root to deepest leaf |
| 高度     | $n_k$ 结点的高度为 $n_k$ 结点到树叶的最长路径的长，所有树叶的高度为 0，树的高度等于根的高度。<br />结点 $x$ 的高度：from deepest leaf to x<br />树的高度：from deepest leaf to root |
| 层       | 根为第 1 层，树的层数等于树的高度 (深度) 加1。               |
| 祖先     | $n_1$ 到 $n_k$ 存在路径，$n_1$ 为 $n_k$ 的祖先，$k$ 不等于 1 时 $n_1$ 为 $n_k$ 的 **真祖先** 。 |
| 后裔     | $n_1$ 到 $n_k$ 存在路径，$n_k$ 为 $n_1$ 的后裔，$k$ 不等于 1 时 $n_k$ 为 $n_1$ 的 **真后裔**。 |
| 度       | 结点的度为其子结点个数。<br />叶子结点度为 0，二叉树的结点的度不超过 2，$N$ 个结点的树的度等于 $N-1$ ，也即边的总数，<br />因为除根结点外每个结点都有且只有一条边连接其父结点。 |
| 树的遍历 | 主要有以下四种遍历方式<br />前序遍历 (Pre-order Traversal): 按 **根>左>右** 的顺序遍历。<br />中序遍历 (In-order Traversal): 按 **左>根>右** 的顺序遍历。<br />后序遍历 (Post-order Traversal): 按 **左>右>根** 的顺序遍。<br />层序遍历 (Lever-order Traversal): 按 **层** 遍历。 |

<br />

## N叉树 (一般树)

[N叉树 (N-ary Tree)](https://baike.baidu.com/item/n%E5%8F%89%E6%A0%91/22213726): 不限制结点个数的树，即一般的树。

<br />

### 直径与重心

<br />

### 遍历

<br />

## 二叉树

[二叉树 (Binary Tree)](https://en.wikipedia.org/wiki/Binary_tree): 结点至多有两个子结点的树称作二叉树。二叉树的定义十分简单，但却十分强大，是一种应用广泛的数据结构。

<br />

### 按形态分类

| 概念                                   | 描述                                                         |
| -------------------------------------- | ------------------------------------------------------------ |
| 二叉树<br />*binary tree*              | 每个结点最多只能有两个结点的树。                             |
| 满二叉树<br />*full binary tree*       | 每个结点要么为无儿子的叶子结点，要么拥有两个儿子结点 (度为 0 或 2) |
| 完全二叉树<br />*complete binary tree* | 第一种描述：所有位置结点的编号都与完美二叉树对应位置的编号相同的二叉树。<br />第二种描述：去掉最后一层后的树为完美二叉树，且最后一层从左到右有连续的结点。<br />完全二叉树特点：<br />若从上到下从左到右编号所有结点，当根结点编号为 1 时，编号为 $i$ 的结点的左儿子编号为 $2i$，右儿子编号为 $2i+1$ <br />或者根结点编号为 0 时，编号为 $i$ 的结点的左儿子编号为 $2i+1$ ，右儿子编号为 $2i+2$ 。<br />反过来，知道某结点编号为 $i$，在第一种编号中其父结点编号为 $i/2$ <br />在第二种编号中其父结点编号为 $(i - 1)/2$ |
| 完美二叉树<br />*perfect binary tree*  | 除最后一层叶子结点外所有层上的结点都有两个儿子结点（度为2）。 |

```text
说明：
中文语境下有时满二叉树也被定义为完美二叉树，产生歧义时以英文名称备注说明更好。
根据根结点为0层或1层，深度/高度为0或1的不同设定，树的层数，高度，深度也有歧义：
根为第0层。树的层数为 k 时（只有根结点的树层数为1），树的高度 (深度) 为 k-1。
根为第1层。树的层数为 k 时（只有根结点的树层数为1），树的高度(深度)为 k。
在具体语境中判断，而不必纠结歧义。

N 个结点的最大二叉树深度：
树为链状时深度最大，为 N-1（根的深度为0）。
```

![image.png](https://pic.leetcode-cn.com/1656839768-kfllBy-image.png)

<br />

### 性质

| 目标                                                         | 关系表达式                              |
| ------------------------------------------------------------ | --------------------------------------- |
| **1. k 层 (深度为 k-1) 完美二叉树节结点数为 N**              |                                         |
| 1-1. $k$                                                     | $k = log(N+1)$                          |
| 1-2. $N$                                                     | $N = 2^k - 1$                           |
| 1-3. 至第 $k-1$ 层的树的结点数 $P$                           | $P = 2^{k-1} - 1$ <br />$P = (N-1) / 2$ |
| 1-4. 第 $k$ 层结点数 $Q$                                     | $Q = 2^{k-1}$ <br />$Q = (N+1) / 2$     |
| 1-5. $P$ 和 $Q$                                              | $Q = P + 1$                             |
| 1-6. $P$ 和 $N$                                              | $N = P + Q = 2P + 1$                    |
| 1-7. $Q$ 和 $N$                                              | $N = P + Q = 2Q - 1$                    |
| **2. k 层 (深度 k-1) 完全二叉树结点数为 N**                  |                                         |
| 2-1. $k$                                                     | $k = ⌊logN⌋ + 1$                        |
| 2-2. $N$                                                     | $2^{k-1} <= N <= 2^k - 1$               |
| 2-3. 上到下左到右从 1 开始编号，下标为 $i$ 的结点的左右子结点的下标 | $left = 2i,  right = 2i + 1$            |
| 2-4. 上到下左到右从 0 开始编号，下标为 $i$ 的结点的左右子结点的下标 | $left = 2i + 1, right = 2i + 2$         |
| **3. k 层任意二叉树**                                        |                                         |
| 3-1. 第 $k$ 层最大结点数                                     | 完美二叉树时最大，为 $2^{k-1}$          |
| 3-2. 最大结点总数                                            | 完美二叉树时最大，为 $2^k - 1$          |
| 3-3. 结点度的关系 ( 0 度结点个数为 $n_0$ ，1 度结点个数为 $n_1$，2 度结点个数为 $n_2$ ) | $n_0 = n_2 + 1$                         |
| 3-4. $null$ 链数 (结点度为 0 时 $null$ 链为 2，结点度为 1 时 $null$ 链为 1，即 $2n_0+n_1$ ) | $N + 1$                                 |

上述部分性质的说明或证明。

- 2-1 说明

  不能表示为 $⌈logN⌉$ ，因为最后一层只有一个结点时，$logN = ⌈logN⌉  = k - 1$ (不等于层数 $k$ )。

- 2-3 证明 (从 1 开始编号)

  设 $i$ 结点左子结点下标为 $n$ ， $i$ 所在层 $i$ 之后的结点数为 $k$ ，将此完全二叉树扩展为完美二叉树后，$n$ 所在层 $n$ 之后的结点数为 $p$ 。由完美二叉树性质1-6，有:

  $n + p = 2*(i + k) + 1$
  又由完美二叉树定义 $p - 1$ 为 $n$ 所在层去掉 $i$ 的右子结点后的结点数，为上一层 $k$ 的两倍 ( $k$ 的每一个结点都有两个子结点) 

  $p - 1 = 2k$
  联立上述两个式子：
  $n + p = 2*(i + k) + 1$
  $p - 1 = 2k$
  得 $n = 2i$

- 3-3 证明
  显然，$N = n0 + n1 + n2$，边数为 $E = 2n2 + n1$ 。除了根以外所有结点往上有一条边连接父结点，故 $N$ 与 $E$ 的关系: $N = E + 1$，即
  $n0 + n1 + n2 = 2n2 + n1 + 1$ ，即 $n0 = n2 + 1$。 
- 3-4 证明
  - 方法1: $N$ 个结点的二叉树，每个结点均有左右两个链（考虑 $null$ 链），共 $2N$ 条链。除根结点外，所有结点都有一个来自其父结点的链指向它，所以一共使用了 $N-1$ 条链(边)，于是剩下的 $2N-(N-1)=N+1$ 即为 $null$ 链的数量。
  - 方法2: $null$ 链个数为度 0 结点乘 2 加度 1 结点数 $2*n0+n1$，由3-3得  $2*n0+n1 = n0+n2+1+n1 = N +1$。 

<br />

### 应用例: 表达式树

叶子结点为操作数，其他结点为操作符。

<div align=center>
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1guv1w4aan9j60ea08iaae02.jpg" alt="image-20210927130033275" width="300" />
</div>

对上述表达式树执行 **中序遍历** 即可得到日常使用的 **中缀表达式** 。执行 **后序遍历** 则得到 **后缀表达式** ，得到后缀表达式后可利用栈计算表达式的值。执行 **前序遍历** 则得到 **前缀表达式** 。例如对 `(a+b*c)+((d*e+f)*g)` 执行后序遍历得到后缀表达式 `abc*+de*f+g*+` ，执行前序遍历得到前缀表达式 `++a*bc*+*defg`  (不常用)。

后缀表达式在1920年代由波兰数学家引入，因此也称其为[逆波兰表达式](https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95) (Reverse Polish Notation)。

将一个后缀表达式转变为表达式树：

- 从左到右读取后缀表达式。

- 若遇到数字则将其作为单结点树压入存储树的栈中。

- 若遇到符号则先后弹出树T1和树T2，以该符号为根合并T1和T2成为一棵新树。

- 重复上述操作直到读取结束。

计算前缀表达式（不常用）：

- 从右往左读取前缀表达式。

- 遇到数字压入栈中。

- 遇到运算符号则取出栈顶两个数字(x1, x2)运算后再压回栈中。(除法时为x1/x2，减法时为x1-x2，x1比x2先出栈。)
- 重复上述操作直到读取结束。

<br />

### 遍历



<br />

## 二叉查找树

[二叉查找树 / 二叉搜索树 / 二叉排序树 (Binary Search Tree / Binary Sort Tree, BST) ](https://en.wikipedia.org/wiki/Binary_search_tree): 对于一棵二叉树，每个结点存有一个可用于比较的数据项，规定结点 $x$ 的左子树中所有结点的数据项小于 $x$ 的数据项，而 $x$ 的右子树中所有结点的数据项大于 $x$ 的数据项，这样的二叉树即为二叉查找树。对于有 $n$ 个元素的二叉树，假设树高平衡，则根据前面的性质可知其高度为 $logn$ ，我们将能够通过其结点数据项有序的特点，以类似二分查找的树上的 **二分操作** 实现 $O(logn)$ 平均时间复杂度的插入，查找和删除等操作。BST 内容非常丰富，下面我们先介绍非自平衡的 **基本 BST** ，由于基本BST树高不保证平衡，树上操作的复杂度无法保证为 $O(logn)$ ，因此引入 **平衡 BST** 。我们将会详细几种不同的平衡 BST 实现。

根据定义可知下图中只有左侧的树是 BST ，右侧的树中结点 7 与 6 不满足 BST 的结点顺序性质，若结点 7 是结点 8 的左子结点，则为 BST。

![image.png](https://pic.leetcode-cn.com/1656840556-GvQFIZ-image.png)

※ 应用二叉查找树实现的数据结构一般为 $set$ 或 $map$，若为 $set$ (例如 Java 中的 $TreeSet$)，则不会存储相同数据项，若为 $map$ (例如 Java 中的 $TreeMap$)，则不会存储相同 $key$ 值。若要求保存相同值，可以采用链表或将相同值看作小于或大于来处理，本文以及后续讲解的所有二叉查找树均不保存相同值。 



> 根据 Wiki 词条，此数据结构在 1960 年代由多人独立提出。
>
> The binary search tree algorithm was discovered independently by several researchers, including P.F. Windley, [Andrew Donald Booth](https://en.wikipedia.org/wiki/Andrew_Donald_Booth), [Andrew Colin](https://en.wikipedia.org/wiki/Andrew_Colin), [Thomas N. Hibbard](https://en.wikipedia.org/wiki/Thomas_N._Hibbard). 

<br />

### 基本BST

基本 BST 即只保持 BST 结点数据项大小关系性质，而不维护树高平衡的 **非平衡 BST** 。所谓「平衡」，指树的形态类似等腰三角形，从根结点到任意叶子结点的路径长度都是稳定的 $O(logn)$ ，更严格的定义是 **「任意结点的左右子树高差不超过 1」** ，如此即能保证对结点的增删改查的时间复杂度均为 $O(logn)$ 。

基本BST的定义十分简单，我们直接给出它的类的实现架构，并介绍其中的主要方法，然后再分析主要操作的时空复杂度。

> 本节内容为 Mark Allen Weiss 所著 [数据结构与算法分析：Java语言描述](https://awesome-programming-books.github.io/algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9AJava%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0.pdf) 相关章节的整理和总结。代码亦来自该书，略作改动。

<br />

#### 基本BST类架构

以下是基本 BST 类 ($MyTreeSet$) 架构。

| 类成员/方法                                | 描述                                |
| ------------------------------------------ | ----------------------------------- |
| `private Node<E> root`                     | 唯一字段，根结点                    |
| `public MyTreeSet()`                       | 无参构造器                          |
| `public void clear()`                      | 树置空                              |
| `public boolean isEmpty()`                 | 树判空                              |
| `public void add(E e)`                     | 插入结点驱动方法                    |
| `public void remove(E e)`                  | 删除结点驱动方法                    |
| `public E first()`                         | 查找最小结点驱动方法                |
| `public E last()`                          | 查找最大结点驱动方法                |
| `public E floor(E e)`                      | 查找小于等于 $e$ 的最大元素驱动方法 |
| `public E ceiling(E e)`                    | 查找大于等于 $e$ 的最小元素驱动方法 |
| `public E lower(E e)`                      | 查找严格小于 $e$ 的最大元素驱动方法 |
| `public E higher(E e)`                     | 查找严格大于 $e$ 的最小元素驱动方法 |
| `public boolean contains(E e)`             | 结点存在判定驱动方法                |
| `public void printTree()`                  | 中序遍历打印树的驱动方法            |
| `public int size()`                        | 求树大小驱动方法                    |
| `public int height()`                      | 求树高驱动方法                      |
| `private Node<E> add(E e, Node<E> t)`      | 插入结点                            |
| `private Node<E> remove(E e, Node<E> t)`   | 删除结点(懒惰删除)                  |
| `private Node<E> first(Node<E> t)`         | 返回树的最小结点                    |
| `private Node<E> last(Node<E> t)`          | 返回树的最大结点                    |
| `private Node floor(Node<E> x, E e)`       | 查找小于等于 $e$ 的最大元素         |
| `private Node<E> ceiling(Node<E> x, E e)`  | 查找大于等于 $e$ 的最小元素         |
| `private Node lower(Node<E> x, E e)`       | 查找严格小于 $e$ 的最大元素         |
| `private Node<E> higher(Node<E> x, E e)`   | 查找严格大于 $e$ 的最小元素         |
| `private boolean contains(E e, Node<E> t)` | 判断树中是否有指定元素的结点        |
| `private void printTree(Node<E> t)`        | 中序遍历打印树                      |
| `private int height(Node<E> t)`            | 求以 $t$ 为根结点的树高             |
| `private int size(Node<E> t)`              | 求以 $t$ 为根结点的树大小           |

<br />

以下是二叉树结点嵌套类 $Node$ 的架构。

| 类成员/方法                                           | 描述     |
| ----------------------------------------------------- | -------- |
| `public E element`                                    | 结点数据 |
| `public Node<E> left`                                 | 左子结点 |
| `public Node<E> right`                                | 右子结点 |
| `public Node(E element)`                              | 构造器   |
| `public Node(E element, Node<E> left, Node<E> right)` | 构造器   |

<br />

#### 主要方法

在类架构表格中，我们看到 BST 实现的 $set$ 类 ($MyTreeSet$) 主要应该包含哪些方法，接下来我们讲解这其中的主要方法。其他实现简单的方法在「类的实现代码」中呈现。

<br />

##### add

插入结点操作由插入驱动方和具体插入方法完成，将值为 $e$ 的结点插入到当前二叉树中并使得插入后仍保持查找树性质。递归地比较 $e$ 和当前结点值的大小，最后 $e$ 总能 **作为一个叶子结点** 被插入到满足查找树性质的位置。

对于具体插入方法，当原树为 $null$ 时返回 `Node<>(e,null, null)` 给 $root$ ，即数据为 $e$ 的结点作为根结点插入。当原树不为 $null$ 时， **插入后返回原根** 。

```java
public void add(E e) { // 插入结点驱动方法
    root = add(e, root);
}
private Node<E> add(E e, Node<E> t){ // 插入结点
    if(t == null) return new Node<>(e,null, null);
    int cmp = e.compareTo(t.element);
    if(cmp < 0) t.left = add(e, t.left); // 递进直到t.left == null
    else if(cmp > 0) t.right = add(e, t.right); // 递进直到t.right == null
    return t; // 等于时不插入(以该树只能存放不同的元素为前提)
}
```

<br />

##### remove

删除结点操作由删除驱动方法和具体删除方法完成，将数据项为 $e$ 的结点删除并使得删除后仍保持查找树性质。

首先，在驱动方法中执行 $contains(e)$ ，若不存在直接返回，否则删除目标存在，调用具体删除方法，递归地寻找 $element$ 为 $e$ 的结点 $t$ ，对其执行 **懒惰删除** 。删除相比其他操作要复杂一些，以下为找到时结点 $t$ 的两种情形。

- 情形1: $t$ 有左右两个子结点。
- 情形2: $t$ 有一个或没有子结点。

情形1时，找到 $t$ 的右子树中最小结点 $min$ ，令 `t.element = min.element` ，即相当于用 $min$ 替换掉要删除的 $t$ ，然后对右子树执行删除 $min$ 的操作（由于是最小值，故此删除必属于情形 2）。

情形2时，根据是否有左子结点，执行此语句 `t = (t.left != null) ? t.left : t.right` 。有左子结点时 `t = t.left`，即用这个左子结点取代 $t$。没有左子结点时 `t = t.right`，表示以右子结点取代 $t$（包含右子结点也为空的情形，则此时 `t = null`）。

对于具体删除方法，当原树为 $null$ 时返回 $t$ (即 $root$ ) 给 $root$ 。当原树不为 $null$ 时，在删除后递归地返回到当前根给 $root$（例如当树只有根结点，且删除的就是该根时，`root = null` ）。

```java
public void remove(E e) { // 删除结点驱动方法
    if (e == null) throw new IllegalArgumentException("argument to remove() is null");
    if (!contains(e)) return; // 检测删除目标是否存在
    root = remove(e, root);
}
private Node<E> remove(E e, Node<E> t){ // 懒惰删除结点
    if(t == null) return null;
    int cmp = e.compareTo(t.element);
    if(cmp < 0) t.left = remove(e, t.left); // 递归地在左侧寻找
    else if(cmp > 0) t.right = remove(e, t.right); // 递归地在右侧寻找
    // e等于t.element，分两种情形
    else if(t.left != null && t.right != null) { // 情形1：该t的左右子节点均不为null
        t.element = first(t.right).element; // 在右子树中找min
        t.right = remove(t.element, t.right); // 此时min已是t.element，必为情形2
    }
    else t = (t.left != null) ? t.left : t.right; // 情形2: 1以外的情形
    return t;
}
```

<br />

##### first/last

查找具有最小/最大数据的结点的操作由驱动方法和具体方法实现。根据 BST 性质一直向左/向右寻找即可找到最小/最大值。以下以递归方式实现 $first$，以迭代方式实现 $last$ 。这两个方法的实现容易理解，不赘述。如下展示 $first$ 的实现，$last$ 的实现请看「类的实现代码」。

```java
public E first() { // 查找最小结点驱动方法
    if(isEmpty()) throw new NoSuchElementException();
    return first(root).element;
}
private Node<E> first(Node<E> t){ // 返回树的最小节点(尾递归方式)
    if(t.left == null) return t;
    return first(t.left);
}
```

<br />

##### floor/ceiling

$floor$ 方法用于查找小于等于指定元素中的最大者，$ceiling$ 方法用于查找大于等于指定元素中的最小者，均由驱动方法和具体方法实现。其实现方式也是根据 BST 性质向左/向右寻找目标。

以 $floor$ 为例，说明如下。

1. `if (cmp == 0) return x;` 若当前元素 $x$ 与目标元素相等，则 $x$ 即为所求直接返回。
2. `if (cmp < 0) return floor(x.left, e);` 若 $e$ 小于当前元素 $x$，说明目标元素在 $x$ 的左子树中，传入 $x.left$ 递归调用 $floor$ 。
3. `Node<E> t = floor(x.right, e);` 否则此时 $e$ 大于 $x$ ，在 $x$ 的右子树中找最大者，即为所求。

如下展示 $floor$ 的实现，$ceiling$ 的实现请看「类的实现代码」。

```java
public E floor(E e) { // 查找小于等于 e 的最大元素驱动方法
    if (e == null) throw new IllegalArgumentException("argument to floor() is null");
    if (isEmpty()) throw new NoSuchElementException("calls floor() with empty symbol table");
    Node<E> x = floor(root, e);
    if (x == null) throw new NoSuchElementException("argument to floor() is too small");
    else return x.element;
}
private Node floor(Node<E> x, E e) { // 小于等于 e 中最大者
    if (x == null) return null;
    int cmp = e.compareTo(x.element);
    if (cmp == 0) return x;
    if (cmp < 0) return floor(x.left, e);
    Node<E> t = floor(x.right, e);
    if (t != null) return t;
    else return x;
}
```

类似地，$lower$ 方法用于查找严格小于指定元素中的最大者，$higher$ 方法用于查找严格大于指定元素的最小者。二者的实现方式与 $floor/ceiling$ 非常类似，只需要将等于的情形与需要递归的情形合写即可，具体请看「类的实现代码」。 

<br />

##### contains

寻找树中是否包含数据项为 $e$ 的结点的操作由相应的驱动方法和具体方法实现。根据二叉查找树的性质以递归方式一直向左/向右寻找。找到返回 $true$ ，否则返回 $false$ 。

```java
public boolean contains(E e) { // 判断是否包含值为e的元素的结点的驱动方法
    return contains(e, root);
}
private boolean contains(E e, Node<E> t) { // 判断树中是否有指定元素的节点
    if(t == null) return false;
    int cmp = e.compareTo(t.element);
    if(cmp < 0) return contains(e, t.left);
    else if(cmp > 0) return contains(e, t.right);
    else return true;
}
```

<br />

#### 时空复杂度

二叉查找树的平均深度为 $O(logn)$ ，因此上述介绍的主要方法 **平均时间复杂度** 均为 $O(logn)$ 。当树为链状时，退化为链表形式，达到最坏时间复杂度 $O(n)$ 。若方法以递归实现，则空间复杂度取决于递归深度 $O(logn)$ ，若以迭代方式实现则空间复杂度为 $O(1)$ 。

| 方法         | 平均时间  | 最坏时间 |
| ------------ | --------- | -------- |
| $add$        | $O(logn)$ | $O(n)$   |
| $first/last$ | $O(logn)$ | $O(n)$   |
| $remove$     | $O(logn)$ | $O(n)$   |
| $contains$   | $O(logn)$ | $O(n)$   |

> BST 平均深度为 $O(logn)$ 的证明见此[论文](http://luc.devroye.org/devroye_reed_1995_variance_height_random_binary_search_tree.pdf)。

<br />

#### 类的实现代码

```java
/**
 * 二叉查找树类 MyTreeSet
 */
class MyTreeSet<E extends Comparable<? super E>>{
    private Node<E> root; // 唯一字段，根节点
    public MyTreeSet() {} // 无参构造器
    public void clear() { // 树置空
        root = null;
    }
    public boolean isEmpty() { // 判树空
        return root == null;
    }
    public void add(E e) { // 插入结点驱动方法
        root = add(e, root);
    }
    public void remove(E e) { // 删除结点驱动方法
        if (e == null) throw new IllegalArgumentException("argument to remove() is null");
        if (!contains(e)) return; // 检测删除目标是否存在
        root = remove(e, root);
    }
    public E first() { // 查找最小结点驱动方法
        if(isEmpty()) throw new NoSuchElementException();
        return first(root).element;
    }
    public E last(){ // 查找最大结点驱动方法
        if(isEmpty()) throw new NoSuchElementException();
        return last(root).element;
    }
    public E floor(E e) { // 查找小于等于 e 的最大元素驱动方法
        if (e == null) throw new IllegalArgumentException("argument to floor() is null");
        if (isEmpty()) throw new NoSuchElementException("calls floor() with empty symbol table");
        Node<E> x = floor(root, e);
        if (x == null) throw new NoSuchElementException("argument to floor() is too small");
        else return x.element;
    }
    public E ceiling(E e) { // 查找大于等于 e 的最小元素驱动方法
        if (e == null) throw new IllegalArgumentException("argument to ceiling() is null");
        if (isEmpty()) throw new NoSuchElementException("calls ceiling() with empty symbol table");
        Node<E> x = ceiling(root, e);
        if (x == null) throw new NoSuchElementException("argument to ceiling() is too large");
        else return x.element;
    }
    public E lower(E e) { // 查找严格小于 e 的最大元素驱动方法
        if (e == null) throw new IllegalArgumentException("argument to lower() is null");
        if (isEmpty()) throw new NoSuchElementException("calls lower() with empty symbol table");
        Node<E> x = lower(root, e);
        if (x == null) throw new NoSuchElementException("argument to lower() is too small");
        else return x.element;
    }
    public E higher(E e) { // 查找严格大于 e 的最小元素驱动方法
        if (e == null) throw new IllegalArgumentException("argument to higher() is null");
        if (isEmpty()) throw new NoSuchElementException("calls higher() with empty symbol table");
        Node<E> x = higher(root, e);
        if (x == null) throw new NoSuchElementException("argument to higher() is too large");
        else return x.element;
    }
    public boolean contains(E e) { // 判断是否包含值为e的元素的结点的驱动方法
        return contains(e, root);
    }
    public void printTree() { // 中序遍历打印
        if (isEmpty()) System.out.println("Empty tree");
        else printTree(root);
    }
    public int size() { // 求树的个数驱动方法
        return size(root);
    }
    public int height() { // 求树的高度驱动方法
        return height(root);
    }
    private Node<E> add(E e, Node<E> t){ // 插入结点
        if(t == null) return new Node<>(e,null, null);
        int cmp = e.compareTo(t.element);
        if(cmp < 0) t.left = add(e, t.left); // 递进直到t.left == null
        else if(cmp > 0) t.right = add(e, t.right); // 递进直到t.right == null
        return t; // 等于时不插入(以该树只能存放不同的元素为前提)
    }
    private Node<E> remove(E e, Node<E> t){ // 懒惰删除结点
        if(t == null) return null;
        int cmp = e.compareTo(t.element);
        if(cmp < 0) t.left = remove(e, t.left); // 递归地在左侧寻找
        else if(cmp > 0) t.right = remove(e, t.right); // 递归地在右侧寻找
        // e等于t.element，分两种情形
        else if(t.left != null && t.right != null) { // 情形1：该t的左右子节点均不为null
            t.element = first(t.right).element; // 在右子树中找min
            t.right = remove(t.element, t.right); // 此时min已是t.element，必为情形2
        }
        else t = (t.left != null) ? t.left : t.right; // 情形2: 1以外的情形
        return t;
    }
    private Node<E> first(Node<E> t){ // 返回树的最小节点(尾递归方式)
        if(t.left == null) return t;
        return first(t.left);
    }
    private Node<E> last(Node<E> t){ // 返回树的最大节点(循环方式)
        while(t.right != null) t = t.right;
        return t;
    }
    private Node floor(Node<E> x, E e) { // 小于等于 e 中最大者
        if (x == null) return null;
        int cmp = e.compareTo(x.element);
        if (cmp == 0) return x;
        if (cmp < 0) return floor(x.left, e);
        Node<E> t = floor(x.right, e);
        if (t != null) return t;
        else return x;
    }
    private Node<E> ceiling(Node<E> x, E e) { // 大于等于 e 中的最小者
        if (x == null) return null;
        int cmp = e.compareTo(x.element);
        if (cmp == 0) return x;
        if (cmp > 0)  return ceiling(x.right, e);
        Node<E> t = ceiling(x.left, e);
        if (t != null) return t;
        else return x;
    }
    private Node lower(Node<E> x, E e) { // 小于 e 中最大者
        if (x == null) return null;
        int cmp = e.compareTo(x.element);
        if (cmp <= 0) return lower(x.left, e);
        Node<E> t = lower(x.right, e);
        if (t != null) return t;
        else return x;
    }
    private Node<E> higher(Node<E> x, E e) { // 大于 e 中的最小者
        if (x == null) return null;
        int cmp = e.compareTo(x.element);
        if (cmp >= 0)  return higher(x.right, e);
        Node<E> t = higher(x.left, e);
        if (t != null) return t;
        else return x;
    }
    private boolean contains(E e, Node<E> t) { // 判断树中是否有指定元素的节点
        if(t == null) return false;
        int cmp = e.compareTo(t.element);
        if(cmp < 0) return contains(e, t.left);
        else if(cmp > 0) return contains(e, t.right);
        else return true;
    }
    private void printTree(Node<E> t) { // 中序遍历打印树
        if(t != null) {
            printTree(t.left);
            System.out.println(t.element);
            printTree(t.right);
        }
    }
    private int height(Node<E> t) { // 返回以t为根节点的树的高度
        if(t == null) return -1;
        else return 1 + Math.max(height(t.left), height(t.right));
    }
    private int size(Node<E> t) { // 递归地遍历树的所有节点，返回节点总数
        if(t != null) {
            if(t.left != null && t.right != null) {
                return 1 + size(t.left) + size(t.right);
            }
            else {
                return t.left != null ? 1 + size(t.left) : 1 + size(t.right);
            }
        }
        return 0;
    }
    /**
     * 二叉树节点嵌套类
     */
    private static class Node<E>{
        public E element;
        public Node<E> left, right;
        public Node(E element, Node<E> left, Node<E> right){
            this.element = element;
            this.left = left;
            this.right = right;
        }
    }
}
```

<br />

#### 测试代码

```java
package com.yukiyama;
import java.util.NoSuchElementException;

public class MyTreeSetDemo {

    public static void main(String[] args) {
        MyTreeSet<Integer> t = new MyTreeSet<>( );
        // 10 98 61 13 8 20 48 29 47 74
        /*
         *            10
         *        8       98
         *             61
         *          13    74
         *            20
         *              48
         *            29
         *              47
         */
        int[] elements = {10,98,61,13,8,20,48,29,47,74};
        for(int e : elements) t.add(e);
        t.add(10);
        t.printTree(); // 输出8 10 13 20 29 47 48 61 74 98
        System.out.printf("size: %d, height: %d, min: %d, max: %d\n", t.size(), t.height(), t.first(), t.last());
        System.out.printf("has 47? %s, has 100? %s\n", t.contains(47), t.contains(100));
        System.out.printf("floor(9): %s, floor(10): %s, ceiling(73): %s, ceiling(98): %s\n", t.floor(9), t.floor(10), t.ceiling(73), t.ceiling(98));
        System.out.printf("lower(9): %s, lower(10): %s, higher(73): %s, higher(61): %s\n", t.lower(9), t.lower(10), t.higher(73), t.higher(61));
        t.remove(47); t.remove(48); t.remove(61);
        t.printTree();
        System.out.println("is empty: " + t.isEmpty()); // 输出false
        t.clear();
        System.out.println("is empty: " + t.isEmpty()); // 输出true
        System.out.printf("size: %d, height: %d\n", t.size(), t.height());// 输出0
    }

}
```

<br />

### AVL树

对于二叉查找树插入/删除/查找等操作，保持 $O(logn)$ 复杂度的前提是 **保持树的平衡** ，即保持树的高度为 $logn$ 。在前述二叉查找树的删除操作中，我们总是删除目标结点右子树中的最小结点，可以预见多次删除操作后将使树呈现 **左高右低的倾向** 。一旦树不平衡，插入删除查找等操作将无法达到 $O(logn)$ 的复杂度，于是我们自然会想如何使得对树进行操作后总能够保持平衡。若能一棵 BST 在操作后总能保持平衡，我们称其为 **平衡 BST** 。本节介绍的 AVL 树是最早提出的自平衡二叉查找树。

AVL 树以 **「旋转 (rotation)」** 操作保证任意结点的左右子树高度差不超过 1，使得树的深度总保持为 $O(logn)$ 。下图左侧的树是 AVL 树，右侧的树则不是 AVL 树，在结点 7 处失衡。

![image.png](https://pic.leetcode-cn.com/1656841310-TPLbDJ-image.png)

> AVL (Adelson-Velsky and Landis Tree) 树由 G.M. Adelson-Velsky 和E.M. Landis于1962年的 [论文](https://zhjwpku.com/assets/pdf/AED2-10-avl-paper.pdf) 中首次介绍。
>
> 本节内容为 Mark Allen Weiss 所著 [数据结构与算法分析：Java语言描述](https://awesome-programming-books.github.io/algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9AJava%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0.pdf) 相关章节的整理和总结。代码亦来自该书，略作改动。

<br />


#### 旋转

在上图 AVL 树中插入 6 时， 6 将作为 7 的左子结点被插入，这将破坏结点 8 的平衡 (8的左子树与其右子树高差为 2)。AVL 树通过旋转操作能够恢复失衡结点的平衡，本节详细讲解此操作的细节。



考虑插入一个结点 $x$ 后，平衡被破坏的结点 $y1, y2,…$ 只可能在 $x$ 到根结点路径上，因此 **只需沿着此路径恢复平衡即可** 。更进一步地，不难证明，只需在第一个平衡被破坏的结点 $y$ （ $x$ 到根结点方向）上重新平衡这棵树，即能保证整棵树恢复为 AVL 树。

插入情况必为如下四情形种之一：

```
 情形1(左-左): 插入点在 y 的左儿子的左子树
 情形2(左-右): 插入点在 y 的左儿子的右子树
 情形3(右-左): 插入点在 y 的右儿子的左子树
 情形4(右-右): 插入点在 y 的右儿子的右子树
```

其中 1 和 4，2 和 3 关于 $y$ 镜像对称，所以实际只有两种情况，但从编程角度来看需要分别处理这四种情形。对于发生在外侧的情况 (左-左，右-右) ，需要通过 **单旋转** 恢复平衡，对于发生在内侧的情况 (左-右，右-左) ，需要通过 **双旋转** 恢复平衡。

> 许多资料将本节介绍的左单旋、右单旋、左右双旋、右左双旋分别称作zag, zig, zag-zig, zig-zag操作。zig和zag原意并无左右之分，为了避免歧义，本文不采用这种称呼，读者只需了解即可。在「伸展树」一节中还会有「一字型」的左左双旋和右右双旋，分别被称为zag-zag和zig-zig，也仅需了解即可。

<br />

##### **单旋转**

**右单旋转 (情形1)：**如下图，在 $k2$ 的左儿子的左子树中插入结点后导致 $k2$ 失去平衡 ( $k2$ 左子树比右子树深 2 层)。

<div align=center>
  <img src="https://tva3.sinaimg.cn/large/73b74df4gy1gzfcu9u2x0j20xm0a8mys.jpg" alt="left-left-single-rotation" width="300">
</div>
$Y$ 不可能与当前的 $X$ 在同一水平上，否则在插入前即失衡。$Y$ 也不可能与 $Z$ 在同一水平上，否则插入后先失衡的是 $k1$（在插入结点通往根路上第一个失衡）。



单旋转操作方法：

在失衡结点 $k2$ 和其左子结点 $k1$ 之间旋转。如图，核心操作为 `k2.left = k1.right`，`k1.right = k2` ，可以形象地描述为将 $k1$ 提起，将 $Y$ 抖落到 $k2$ 的左侧。旋转方向为右侧，即顺时针方向，且只有一次旋转操作，因此称为 **右单旋转** 。旋转后以 $k2$ 和 $k1$ 为根结点的树的高度也需要实时调整（ $height$ 是 $AvlNode$ 类的属性）。如下是该左-左单旋转的代码实现。

```java
private AvlNode<E> rotateRight(AvlNode<E> k2){ // 传入失衡结点
    AvlNode<E> k1 = k2.left;
    k2.left = k1.right;
    k1.right = k2;
    k2.height = Math.max(height(k2.left), height(k2.right)); // 调整k2高度
    k1.height = Math.max(height(k1.left), height(k1.right)); // 调整k1高度
    return k1; // 返回调整后原失衡处结点
}
```

 如图调整，将 $k1$ 作为调整后树的根结点，$X$ 上移 1 层，$Y$ 深度不变，$Z$ 下移 1 层，调整后 $XYZ$ 深度相同，树高度恢复为插入前的高度。

<br />

**左单旋转(情形4)：**如下图，在 $k1$ 的右儿子的右子树中插入结点后导致 $k1$ 失去平衡 ( $k1$ 右子树比左子树深 2 层)。

<div align=center>
  <img src="https://tvax4.sinaimg.cn/large/73b74df4gy1gzfdpidniij20xs0b2769.jpg" alt="right-right-single-rotation" width="300">
</div>

恢复平衡的旋转操作与左-左单旋转类似，核心操作为 `k1.right = k2.left`，`k2.left = k1` 。旋转方向为左侧，即逆时针方向，且只有一次旋转操作，因此称为 **左单旋转** 。以下给出右-右单旋转的代码实现。

```java
private AvlNode<E> rotateLeft(AvlNode<E> k1){ // 传入失衡结点
    AvlNode<E> k2 = k1.right;
    k1.right = k2.left;
    k2.left = k1;
    // 调整平衡后更新k1，k2的高度
    k1.height = Math.max(height(k1.left), height(k1.right));
    k2.height = Math.max(height(k2.left), height(k2.right));
    return k2; // 返回调整后原失衡处结点
}
```

<br />

##### **双旋转**

**左右双旋转(情形2)：**如下图左侧的树，在 $k2$ 的左儿子 $k1$ 的右子树中插入结点后导致 $k2$ 失衡 ( $k2$ 的左子树比右子树高 2)。

对于情形2和情形3，单旋转无法恢复平衡。如下图，执行一次单旋转后 $k1$ 的右子树比左子树高 2，平衡未恢复。恢复此情形的平衡需采用 **「双旋转」** 操作。

<div align=center>
  <img src="https://tvax1.sinaimg.cn/large/73b74df4gy1gzfehzvgr4j20is07cq3n.jpg" alt="left-right-single-rotation" width="300">
</div>

双旋转操作方法：

将上述左-右失衡情形 (情形2) 表示为下图。导致失衡的结点插入位置为 $k1$ 的右子树，因此可以表示为 $k2$ 及其左右子树的结构。

如前述，单旋转将 $k1$ 作为根无效，因此考虑将 $k2$ 作为根，将 $k2$ 的左子树 $B$ 作为 $k1$ 的右子树，$k2$ 的右子树 $C$ 作 为$k3$ 的左子树。然后 $k2$ 的左右儿子分别更新为 $k1$ ， $k3$ 。如下图，平衡恢复。该双旋转实际上可以通过对 $k1$ 执行一次右-右单旋转，再对 $k3$ 执行一次左-左单旋转实现。可以看到代码实现十分简洁。

<div align=center>
  <img src="https://tva4.sinaimg.cn/large/73b74df4gy1gzfejxd7kuj20nm06y0tu.jpg" alt="left-right-double-rotation" width="350">
</div>

```java
/**
 * 左右双旋
 * 因k2的左子结点的内侧子树，即k2的左子结点的右子树导致k2失衡。
 * 对k2执行一次右单旋转后仍然在k1处(新根)失衡，因此考虑展开一开始导致失衡的k1右子树，
 * 做如下转换(总是以中序遍历的顺序标注结点，注意k1,k2,k3位置变化)。
 * 因为不知道是B或C中的哪一棵导致失衡(比D深2层)，所以将B，C画成比D深1.5。
 * 依次执行如下两次单旋转后可恢复原失衡处的平衡。
 * 1. 对k1(k3.left)执行左单旋转。
 * 2. 对k3执行右单旋转。
 *
 *           k2                        k3
 *         /    \                    /     \
 *        k1     /\　  转换为        k1      /\
 *       /  \   /__\   ====>      /   \    /__\
 *     /\    /\   Z             /\     k2    D
 *    /__\  /  \               /__\   /  \
 *     X   /    \               A   /\    /\
 *        /______\                 /  \  /  \
 *           Y                    /____\/____\　
 *                                  B      C
 *                         k3                                k2
 *                       /     \                         /        \
 *  对k1执行             k2      /\    对k3执行           K1          K3
 *  一次左单旋转         /    \  /__\   一次右单旋转      /    \       /  \
 *    =====>         k1      /\  D    ====>          /\    /\     /\   /\
 *                 /   \    /  \                    /__\  /　\   / 　\ /__\
 *                /\    /\ /____\                    A   /____\ /____\  D
 *               /__\  /  \  C                             B      C
 *　　　　         A   /____\　
 *                      B
 */
private AvlNode<E> rotateLeftRight(AvlNode<E> k3){ // 传入失衡结点
    k3.left = rotateLeft(k3.left);
    return rotateRight(k3);
}
```

<br />

**右-左双旋转(情形3)：**如下图左侧的树，在k1的右儿子k3的左子树中插入结点后导致k1失衡(k1的右子树比左子树高2)。

<div align=center>
  <img src="https://tvax1.sinaimg.cn/large/73b74df4gy1gzff46iu03j20ps07cq44.jpg" alt="right-left-double-rotation" width="350">
</div>

恢复平衡的旋转操作与左右双旋转类似，以下给出右左双旋转的代码实现。

```java
private AvlNode<E> rotateRightLeft(AvlNode<E> k1){
    k1.right = rotateRight(k1.right);
    return rotateLeft(k1);
}
```

<br />


#### AVL树类架构

以下是AVL查找树类AvlTree的架构。

| 类成员/方法                                       | 描述                                                         |
| ------------------------------------------------- | ------------------------------------------------------------ |
| private AvlNode<E> root                           | 字段，AVL树的根结点                                          |
| private static final int *ALLOWED_IMBALANCE* = 1  | 常量字段，结点的失衡判定值，大于此值则失衡                   |
| public AvlTree()                                  | 无参构造器，$root$ 初始化为 $null$                           |
| public void makeEmpty()                           | 树置空                                                       |
| public boolean isEmpty()                          | 判断树是否为空                                               |
| public void insert(E e)                           | 插入结点驱动方法                                             |
| public void remove(E e)                           | 删除结点驱动方法                                             |
| public E findMin()                                | 查找最小结点驱动方法                                         |
| public E findMax()                                | 查找最大结点驱动方法                                         |
| public boolean contains(E e)                      | 判断是否包含指定元素驱动方法                                 |
| public void printTree()                           | 按中序遍历打印树的驱动方法                                   |
| public int size()                                 | 求树的结点个数驱动方法                                       |
| public int height()                               | 求树的高度驱动方法                                           |
| public void checkBalance()                        | 树平衡检查驱动方法                                           |
| private AvlNode<E> balance(AvlNode<E> t)          | 调整 $t$ 结点处的平衡，并返回 $t$ 。<br />如果 $t$ 失去平衡，根据其失衡的情况，执行如下四种情形之一的旋转调整。<br />左外情形，对 $t$ 执行右单旋转 $rotateRight$<br />左内情形，对 $t$ 执行左右双旋转 $rotateLeftRight$<br />右外情形，对 $t$ 执行左单旋转 $rotateLeft$<br />右内情形，对 $t$ 执行右左双旋转 $rotateRightLeft$ |
| private AvlNode<E> insert(E e, AvlNode<E> t)      | 插入结点<br />与 BST 的不同在于返回时调用 $balance(t)$ ，<br />调整插入 $t$ 后 $t$ 处的平衡，返回 $t$ 。 |
| private AvlNode<E> remove(E e, AvlNode<E> t)      | 删除结点(懒惰删除)<br />与 BST 的不同在于返回时调用 $balance(t)$ ，<br />调整删除 $t$ 后 $t$ 处的平衡，返回 $t$ (新 $t$ )。 |
| private AvlNode<E> findMin(AvlNode<E> t)          | 返回树的最小结点                                             |
| private AvlNode<E> findMax(AvlNode<E> t)          | 返回树的最大结点                                             |
| private boolean contains(E e, AvlNode<E> t)       | 判断树中是否有指定元素的结点                                 |
| private void printTree(AvlNode<E> t)              | 中序遍历打印树                                               |
| private int height(AvlNode<E> t)                  | 返回以 $t$ 为根结点的树的高度                                |
| private int size(AvlNode<E> t)                    | 递归地遍历所有结点，返回结点总数                             |
| private int checkBalance(AvlNode<E> t)            | 检查树是否平衡，不平衡打印“imbalance”，并返回树高度          |
| private AvlNode<E> rotateRight(AvlNode<E> k2)     | 右单旋转                                                     |
| private AvlNode<E> rotateLeft(AvlNode<E> k1)      | 左单旋转                                                     |
| private AvlNode<E> rotateLeftRight(AvlNode<E> k3) | 左右双旋转                                                   |
| private AvlNode<E> rotateRightLeft(AvlNode<E> k1) | 右左双旋转                                                   |

以下为 AVL 树结点嵌套类 $AvlNode$ 的架构。

| 类成员/方法                                                  | 描述                   |
| ------------------------------------------------------------ | ---------------------- |
| public E element                                             | 字段，本结点元素       |
| public AvlNode<E> left                                       | 字段，本结点的左子结点 |
| public AvlNode<E> right                                      | 字段，本结点的右子结点 |
| public int height                                            | 字段，该结点的高度     |
| public AvlNode(E theElement)                                 | 构造器                 |
| public AvlNode(E element, AvlNode<E> left, AvlNode<E> right) | 构造器                 |

<br />

#### 主要方法

##### insert

插入结点操作由插入驱动方法和具体插入方法完成，与 BST 的插入方法的不同在于，插入后通过 $balance$ 方法，调整 $t$ 处的平衡后通过返回原根。由于递归，$balance$ 方法能够自底向上调整 **插入路径上所有结点的平衡** ，且实际上在调整 **第一个**（自底向上方向上的第一个）失衡结点后使整棵树恢复为 AVL 树。$balance$ 方法后续详述。

```java
public void insert(E e) { // 插入结点驱动方法
    root = insert(e, root);
}
private AvlNode<E> insert(E e, AvlNode<E> t){ // 插入结点，返回时沿路检查平衡并调整
    if(t == null) return new AvlNode<>(e,null, null);
    int compareRes = e.compareTo(t.element);
    if(compareRes < 0) t.left = insert(e, t.left);
    else if(compareRes > 0) t.right = insert(e, t.right);
    // 等于时不插入(以该树只能存放不同的元素为前提)
    return balance(t); // 调整t处的平衡并返回t
}
```

<br />

##### findMin/findMax

与 BST 的对应方法一致。

```java
public E findMin() { // 查找最小结点驱动方法
    if(isEmpty()) throw new NoSuchElementException();
    return findMin(root).element;
}
private AvlNode<E> findMin(AvlNode<E> t){ // 返回树的最小结点(递归方式)
    if(t == null) return null;
    else if(t.left == null) return t;
    return findMin(t.left);
}
public E findMax(){ // 查找最大结点驱动方法
    if(isEmpty()) throw new NoSuchElementException();
    return findMax(root).element;
}
private AvlNode<E> findMax(AvlNode<E> t){ // 返回树的最大结点(循环方式)
    if(t == null) return null;
    while(t.right != null) t = t.right;
    return t;
}
```

<br />

##### remove

删除结点操作由删除驱动方法和具体删除方法完成，与 BST 的删除方法的不同在于，删除后通过 $balance$ 方法，调整 $t$ 处的平衡后通过返回原根。由于递归，$balance$ 方法能够自底向上调整 **插入路径上所有结点的平衡** ，且实际上在调整 **第一个**（自底向上方向上的第一个）失衡结点后使整棵树恢复为 AVL 树。$balance$ 方法后续详述。

```java
public void remove(E e) { // 删除结点驱动方法
    root = remove(e, root);
}
private AvlNode<E> remove(E e, AvlNode<E> t){ // 删除结点(懒惰删除)，返回时沿路检查平衡并调整
    if(t == null) return null;
    int compareRes = e.compareTo(t.element);
    if(compareRes < 0) t.left = remove(e, t.left); // 递归地在左侧寻找
    else if(compareRes > 0) t.right = remove(e, t.right); // 递归地在右侧寻找
    // e等于t.element，分两种情形
    else if(t.left != null && t.right != null) { // 情形1：该t的左右子结点均不为null
        t.element = findMin(t.right).element; // 在右子树中找min
        t.right = remove(t.element, t.right); // 此时min已是t.element，必为情形2
    }
    else t = (t.left != null) ? t.left : t.right; // 情形2: 1以外的情形
    return balance(t); // 调整t处的平衡并返回t
}
```

<br />

##### contains

与 BST 的对应方法一致。

```java
public boolean contains(E e) { // 判断是否包含指定元素驱动方法
    return contains(e, root);
}
private boolean contains(E e, AvlNode<E> t) {
    if(t == null) return false;
    int compareRes = e.compareTo(t.element);
    if(compareRes < 0) return contains(e, t.left);
    else if(compareRes > 0) return contains(e, t.right);
    else return true;
}
```

<br />

##### balance

在每一次插入或删除结点后，路径上结点 $t$ 的平衡。判断 $t$ 的左右子树高差是否超过设定的值（`ALLOWED_IMBALANCE = 1`），若超过则分别判断属于左-左、左-右、右-右、右-左中的哪一种情形，调用相应的旋转方法调整即可。该方法返回 $t$ 。

```java
private AvlNode<E> balance(AvlNode<E> t){ // 调整 t 结点处的平衡，并返回 t
    if(t == null) return null;
    if(height(t.left) - height(t.right) > ALLOWED_IMBALANCE) { // 失衡，且左高于右
        if(height(t.left.left) >= height(t.left.right)){ // 右单旋情形
            t = rotateRight(t);
        }
        else t = rotateLeftRight(t); // 左右双旋情形
    }
    else if(height(t.right) - height(t.left) > ALLOWED_IMBALANCE){ // 失衡，且右高于左
        if(height(t.right.right) >= height(t.right.left)) { // 左单旋情形
            t = rotateLeft(t);
        }
        else t = rotateRightLeft(t); // 右左双旋情形
    }
    t.height = Math.max(height(t.left), height(t.right)) + 1; // 更新 t 的高度
    return t;
}
```

<br />

##### rotateRight

右单旋转，见前述说明。

<br />

##### rotateLeft

左单旋转，见前述说明。

<br />

##### rotateLeftRight

左右双旋转，见前述说明。

<br />

##### rotateRightLeft

右左双旋转，见前述说明。

<br />

##### checkBalance

检查整棵树是否平衡的方法。由平衡检查驱动方法和具体平衡检查方法完成。具体方法中以递归方式检查，若平衡则返回树高，不平衡则打印 $imbalance$ 并返回树高。

```java
public void checkBalance() { // 树平衡检查驱动方法
    checkBalance(root);
}
private int checkBalance(AvlNode<E> t) { // 检查树是否平衡，不平衡打印“imbalance”，并返回树高度
    if(t == null) return -1;
    int lh = checkBalance(t.left);
    int rh = checkBalance(t.right);
    if(Math.abs(height(t.left) - height(t.right)) > 1
            || height(t.left) != lh || height(t.right) != rh) {
        System.out.println("imbalance");
    }
    return height(t);
}
```

<br />

#### 类的实现代码

```java
class AvlTree<E extends Comparable<? super E>>{
    private AvlNode<E> root;
    private static final int ALLOWED_IMBALANCE = 1;
    public AvlTree() {} // 无参构造器
    public void makeEmpty() { // 树置空
        root = null;
    }
    public boolean isEmpty() { // 树判空
        return root == null;
    }
    public void insert(E e) { // 插入结点驱动方法
        root = insert(e, root);
    }
    public void remove(E e) { // 删除结点驱动方法
        root = remove(e, root);
    }
    public E findMin() { // 查找最小结点驱动方法
        if(isEmpty()) throw new NoSuchElementException();
        return findMin(root).element;
    }
    public E findMax(){ // 查找最大结点驱动方法
        if(isEmpty()) throw new NoSuchElementException();
        return findMax(root).element;
    }
    public boolean contains(E e) { // 判断是否包含指定元素驱动方法
        return contains(e, root);
    }
    public void printTree(){ // 按中序遍历打印树的驱动方法
        if(isEmpty()) System.out.println("Empty tree");
        else printTree(root);
    }
    public int size() { // 求树的结点个数驱动方法
        return size(root);
    }
    public int height() { // 求树的高度驱动方法
        return height(root);
    }
    public void checkBalance() { // 树平衡检查驱动方法
        checkBalance(root);
    }
    private AvlNode<E> balance(AvlNode<E> t){ // 调整 t 结点处的平衡，并返回 t
        if(t == null) return null;
        if(height(t.left) - height(t.right) > ALLOWED_IMBALANCE) { // 失衡，且左高于右
            if(height(t.left.left) >= height(t.left.right)){ // 右单旋情形
                t = rotateRight(t);
            }
            else t = rotateLeftRight(t); // 左右双旋情形
        }
        else if(height(t.right) - height(t.left) > ALLOWED_IMBALANCE){ // 失衡，且右高于左
            if(height(t.right.right) >= height(t.right.left)) { // 左单旋情形
                t = rotateLeft(t);
            }
            else t = rotateRightLeft(t); // 右左双旋情形
        }
        t.height = Math.max(height(t.left), height(t.right)) + 1; // 更新 t 的高度
        return t;
    }
    private AvlNode<E> insert(E e, AvlNode<E> t){ // 插入结点，返回时沿路检查平衡并调整
        if(t == null) return new AvlNode<>(e,null, null);
        int compareRes = e.compareTo(t.element);
        if(compareRes < 0) t.left = insert(e, t.left);
        else if(compareRes > 0) t.right = insert(e, t.right);
        // 等于时不插入(以该树只能存放不同的元素为前提)
        return balance(t); // 调整t处的平衡并返回t
    }
    private AvlNode<E> remove(E e, AvlNode<E> t){ // 删除结点(懒惰删除)，返回时沿路检查平衡并调整
        if(t == null) return null;
        int compareRes = e.compareTo(t.element);
        if(compareRes < 0) t.left = remove(e, t.left); // 递归地在左侧寻找
        else if(compareRes > 0) t.right = remove(e, t.right); // 递归地在右侧寻找
        // e等于t.element，分两种情形
        else if(t.left != null && t.right != null) { // 情形1：该t的左右子结点均不为null
            t.element = findMin(t.right).element; // 在右子树中找min
            t.right = remove(t.element, t.right); // 此时min已是t.element，必为情形2
        }
        else t = (t.left != null) ? t.left : t.right; // 情形2: 1以外的情形
        return balance(t); // 调整t处的平衡并返回t
    }
    private AvlNode<E> findMin(AvlNode<E> t){ // 返回树的最小结点(递归方式)
        if(t == null) return null;
        else if(t.left == null) return t;
        return findMin(t.left);
    }
    private AvlNode<E> findMax(AvlNode<E> t){ // 返回树的最大结点(循环方式)
        if(t == null) return null;
        while(t.right != null) t = t.right;
        return t;
    }
    private boolean contains(E e, AvlNode<E> t) { // 判断树中是否有指定元素的结点
        if(t == null) return false;
        int compareRes = e.compareTo(t.element);
        if(compareRes < 0) return contains(e, t.left);
        else if(compareRes > 0) return contains(e, t.right);
        else return true;
    }
    private void printTree(AvlNode<E> t) { // 中序遍历打印树
        if(t != null) {
            printTree(t.left);
            System.out.println(t.element);
            printTree(t.right);
        }
    }
    private int height(AvlNode<E> t) { // 返回以t为根结点的树的高度
        return t == null ? -1 : t.height;
    }
    private int size(AvlNode<E> t) { // 递归地遍历所有结点，返回结点总数
        if(t != null) {
            if(t.left != null && t.right != null) {
                return 1 + size(t.left) + size(t.right);
            }
            else {
                return t.left != null ? 1 + size(t.left) : 1 + size(t.right);
            }
        }
        return 0;
    }
    private int checkBalance(AvlNode<E> t) { // 检查树是否平衡，不平衡打印“imbalance”，并返回树高度
        if(t == null) return -1;
        int lh = checkBalance(t.left);
        int rh = checkBalance(t.right);
        if(Math.abs(height(t.left) - height(t.right)) > 1
                || height(t.left) != lh || height(t.right) != rh) {
            System.out.println("imbalance");
        }
        return height(t);
    }
    private AvlNode<E> rotateRight(AvlNode<E> k2){ // 右单旋
        AvlNode<E> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        k2.height = Math.max(height(k2.left), height(k2.right)); // 调整k2高度
        k1.height = Math.max(height(k1.left), height(k1.right)); // 调整k1高度
        return k1; // 返回调整后原失衡处结点
    }
    private AvlNode<E> rotateLeft(AvlNode<E> k1){ // 左单旋
        AvlNode<E> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        k1.height = Math.max(height(k1.left), height(k1.right)); // 调整k1高度
        k2.height = Math.max(height(k2.left), height(k2.right)); // 调整k2高度
        return k2; // 返回调整后原失衡处结点
    }
    private AvlNode<E> rotateLeftRight(AvlNode<E> k3){ // 左右双旋
        k3.left = rotateLeft(k3.left);
        return rotateRight(k3);
    }
    private AvlNode<E> rotateRightLeft(AvlNode<E> k1){ // 右左双旋
        k1.right = rotateRight(k1.right);
        return rotateLeft(k1);
    }
    /**
     * AVL树结点嵌套类
     */
    private static class AvlNode<E>{
        public E element;
        public AvlNode<E> left, right;
        // 比BinaryNode多维护一个height字段，每次insert或remove一个结点时通过balance方法更新
        public int height;
        @SuppressWarnings("unused")
        public AvlNode(E theElement){
            this(theElement, null, null);
        }
        public AvlNode(E element, AvlNode<E> left, AvlNode<E> right){
            this.element = element;
            this.left = left;
            this.right = right;
            this.height = 0;
        }
    }
}
```

<br />

#### 测试代码

```java
package com.yukiyama;

import java.util.NoSuchElementException;

public class AvlTreeDemo {

    public static void main(String[] args) {
        AvlTree<Integer> t = new AvlTree<>( );
        int[] elements = {3,2,1,4,5,6,7,16,15,14,13,12,11,10,8,9};
        for(int e : elements) t.insert(e);
        t.printTree();
        System.out.printf("size: %d, height: %d, min: %d, max: %d\n", t.size(), t.height(), t.findMin(), t.findMax()); // 输出10
        System.out.printf("has 10? %s, has 100? %s\n", t.contains(10), t.contains(100));
        t.checkBalance();
        t.remove(1); t.checkBalance();
        t.remove(10); t.checkBalance();
        t.remove(16); t.checkBalance();
        t.printTree(); // 8 10 13 20 29 74 98
        System.out.printf("size: %d, height: %d\n", t.size(), t.height());// 输出0
        System.out.println("is empty: " + t.isEmpty()); // false
        t.makeEmpty();
        System.out.println("is empty: " + t.isEmpty()); // true
    }

}
```

<br />

### splay树

伸展树是解决基本 BST 在非平衡状态下主要操作无法达到 $O(logn)$ 复杂度的另一种解决方案。相比 AVL 树，伸展树并不严格地使 BST 每次操作后保持平衡，因此伸展树的单次操作可能为 $O(n)$ 复杂度，但伸展树保证 $m$ 次操作的最坏时间复杂度为 $mO(logn)$，也就是说其主要操作的均摊时间复杂度为 $O(logn)$  。伸展树相对 AVL 树的优点是 **无需维护树的高度信息** ，从而能够节省一部分空间，且编程相对简单。伸展树的主要操作均基于 **「展开 (splay)」** ，展开操作的基础是我们已在 AVL 中讲解过的旋转，「展开」动作将目标结点旋转至根结点处，并在这个过程中调整沿途上的结点。本节将介绍一种只需 $O(1)$ 辅助空间的「自顶向下」展开的伸展树。


> 伸展树由 [Daniel Sleator](https://en.wikipedia.org/wiki/Daniel_Sleator) 和 [Robert Tarjan](https://en.wikipedia.org/wiki/Robert_Tarjan) 共同发明，发表于1985年的 [论文](https://www.cs.cmu.edu/~sleator/papers/self-adjusting.pdf) 中。
>
> 本节内容为Mark Allen Weiss所著 [数据结构与算法分析：Java语言描述](https://awesome-programming-books.github.io/algorithms/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%EF%BC%9AJava%E8%AF%AD%E8%A8%80%E6%8F%8F%E8%BF%B0.pdf) 相关章节的整理和总结。代码亦来自该书，略作改动。

<br />

#### 展开

伸展树「展开」的想法基于这样一个事实：当一个结点被访问时 (查询最小/最大/是否存在/插入/删除等)，它很可能将在不久之后被再次访问。因此为了提高总体访问效率，在访问一个结点后，应当将其移动到根结点处， **移动过程即「展开」** 。在 AVL 树一节中我们已经掌握如何通过旋转向一个方向移动目标结点，很容易想到通过有限次的「单旋转」将目标结点展开至根结点处 (使其成为根结点)。但只使用单旋转是不够的，以下图为例，通过简单旋转将左侧树的结点 1 展开至根处得到右侧树，可以看到树高无变化。

![image-20220627201309170](https://tva1.sinaimg.cn/large/e6c9d24egy1h3n2as323pj209e060q2z.jpg)

因此伸展树采用 **双旋转与单旋转结合** 的方式展开。主要为以下三种情形，每种情形有对称的两种子情形 (不再列出)。

```text
单旋转: 与 AVL 树中介绍的单旋转相同，分为左单旋状和右单旋转。
之字形双旋转：与 AVL 树中介绍的之字形双旋转相同，实际上就是连续两次不同向的单旋转，分为左右双旋转和右左双旋转。
一字形双旋转：实际上就是连续两次同向的单旋转，分为左左双旋转和右右双旋转。
```

如下图左侧是我们在 AVL 树一节中已经熟悉的之字形左右双旋转 (先左旋 $P-X$ ，再右旋 $X-G$ )，右侧是一字形右右双旋转 (先右旋 $G-P$ ，再右旋 $P-X$ )。

![image-20220627185134653](https://tva1.sinaimg.cn/large/e6c9d24egy1h3mzxws5upj20oc03mmxi.jpg)

伸展树中的「展开」操作要求在能够双旋转时采用双旋转，只能单旋转时才执行单旋转。现在我们利用此规则展开前面给出的 1 到 6 的链状树，如下，展开过程为两次一字形的双旋转和一次单旋转。尽管由于结点树较少而无法很好地看出树高减小的效果，但总体上，相比简单的单旋转，我们确实能够看到树高减小的效果。

![image-20220627200831041](https://tva1.sinaimg.cn/large/e6c9d24egy1h3n260o2mpj20ea05s74m.jpg)

<br />

#### 自顶向下展开

展开操作的前提是找到目标结点，因此需要一次遍历来找到目标结点，然后再沿着此路径将目标结点旋转至根结点，这显然需要保存路径信息。在 AVL 树中我们以递归调用的方式，借助隐式保存了路径信息的递归栈实现上述做法。这里我们将介绍一种 **无需栈空间的「自顶向下」展开** ，即无需遍历找到目标后再展开，而是在自顶向下寻找目标的过程中实时地展开。

在前面的例子中我们没有展示之字形旋转的过程，实际上，本节给出的「自顶向下」的展开实现中， **对之字形的情况按照「单旋转」处理** 。此外，展开的过程中始终维护树 $L$ 、树 $M$ 以及树 $R$ ，使得旋转操作得到简化，其定义如下。

>  整棵树中小于中间树 $M$ 的根结点但不在 $M$ 中的结点存储在 $L$ 树中，大于中间树 $M$ 的根结点但不在 $M$ 中的结点存储在 $R$ 树中。初始时 $M$ 即为原树，$L, R$ 为空树。

下图从上到下表示 **单旋转、之字形旋转 (同单旋转) 以及一字形旋转** 。可以看到，与 AVL 的旋转相比，这里的「单旋转」实际上只是修改了一些链接关系 ( AVL 单旋转本质也是修改一些链接关系，但重点在于旋转主体目标结点相对关系的改变，例如下图的单旋转，若为 AVL 中的单旋转，则 $X$ 到 $Y$ 的链接「右旋」后将变为 $Y$ 到 $X$ 的链接)，而「一字形旋转」也只是执行了一次 $Y-X$ 右旋后修改了一些链接关系。因此相比 AVL 树的实现，「自顶向下」伸展树的代码十分易于编写。

![image-20220627204142567](https://tva1.sinaimg.cn/large/e6c9d24egy1h3n34izck1j20cy08oweu.jpg)

实际编程中应用了一些技巧，例如利用 $nullNode$ 来简化程序并提高了程序效率。通过设置 $header$ 来保存 $L$ 和 $R$ 首次不为空树时的树根，以便于最后的 **组装** 操作。下图表现了展开操作最后的组装动作，同样只是简单地修改一些链接关系。具体实现以及提到的一些实现技巧请参考本节「主要方法」以及「类的实现代码」中的注释。

![image-20220627204547729](https://tva1.sinaimg.cn/large/e6c9d24egy1h3n38qpvcdj20bg02iwed.jpg)

<br />


#### 伸展树类架构

以下是伸展树 SplayTree 架构。

| 类成员/方法                                           | 描述                                 |
| ----------------------------------------------------- | ------------------------------------ |
| `private BinaryNode<E> root`                          | 字段，splay树的根结点                |
| `private BinaryNode<E> newNode`                       | 字段，插入结点                       |
| `private BinaryNode<E> nullNode`                      | 字段，为方便编程而设置的 $null$ 结点 |
| `public SplayTree()`                                  | 构造器                               |
| `public void makeEmpty()`                             | 树置空                               |
| `public boolean isEmpty()`                            | 树判空                               |
| `public void insert(E e)`                             | 插入结点方法                         |
| `public void remove(E e)`                             | 删除结点方法                         |
| `public E findMin()`                                  | 查找最小结点驱动方法                 |
| `public E findMax()`                                  | 查找最大结点驱动方法                 |
| `public boolean contains(E e)`                        | 判断是否包含指定元素方法             |
| `public void printTree()`                             | 按中序遍历打印树的驱动方法           |
| `public int size()`                                   | 求树的结点个数驱动方法               |
| `private BinaryNode<E> splay(E e, BinaryNode<E> t)`   | 展开方法                             |
| `private BinaryNode<E> findMin(BinaryNode<E> t)`      | 返回树的最小结点                     |
| `private BinaryNode<E> findMax(BinaryNode<E> t)`      | 返回树的最大结点                     |
| `private void printTree(BinaryNode<E> t)`             | 中序遍历打印树                       |
| `private int size(BinaryNode<E> t)`                   | 递归地遍历所有结点，返回结点总数     |
| `private BinaryNode<E> rotateRight(BinaryNode<E> k2)` | 右单旋转                             |
| `private BinaryNode<E> rotateLeft(BinaryNode<E> k1)`  | 左单旋转                             |

以下是二叉树结点嵌套类 BinaryNode 的架构。

| 类成员/方法                                                  | 描述                   |
| ------------------------------------------------------------ | ---------------------- |
| `public E element`                                           | 字段，本结点数据       |
| `public BinaryNode<E> left`                                  | 字段，本结点的左子结点 |
| `public BinaryNode<E> right`                                 | 字段，本结点的右子结点 |
| `public BinaryNode()`                                        | 构造器                 |
| `public BinaryNode(E element)`                               | 构造器                 |
| `public BinaryNode(E element, BinaryNode<E> left, BinaryNode<E> right)` | 构造器                 |

<br />

#### 主要方法

##### splay

展开。伸展树中最主要的操作，传入目标结点值 $e$ 和当前根结点 $t$ (中间树 $M$ 的根结点) ， **在寻找目标结点的过程中完成展开** 。首先新建树 $L$ 与树 $R$，初始为空树，方法中并不直接声明这两棵树，而是通过 $header, leftTreeMax, rightTreeMin$ 来动态维护。动态维护主要体现在 $L$ 中的 $leftTreeMax$ 以及 $R$ 中的 $rightTreeMin$ ，一开始令此二者为 $header$ ，该变量仅用于保存 $L$ 和 $R$ 初次不为空树时的根结点，用于最后 $M, L, R$ 的组装。如其名，在方法的整个过程中，此二者始终代表 $L$ 中最大结点以及 $R$ 中最小结点。

> 首次执行 `rightTreeMin.left = t` 时，即 `header.left = t` ，且此后 `header.left` 引用不变， `leftTreeMax.right = t` 同理。

```java
private BinaryNode<E> splay(E e, BinaryNode<E> t) { // 自顶向下展开目标结点
    BinaryNode<E> leftTreeMax, rightTreeMin;
    header.left = header.right = nullNode;
    leftTreeMax = rightTreeMin = header;
    nullNode.element = e;   // 确保能够匹配，便于编程
    while(true) {
        int compareRes = e.compareTo(t.element);
        if(compareRes < 0) { // 目标在t的左子树中
            if(e.compareTo(t.left.element) < 0) t = rotateRight(t); // 一字型右旋(右单旋)
            if(t.left == nullNode) break; // t无左儿子，已完成一次单旋(包括之字形)，跳出循环
            rightTreeMin.left = t; // 挂接到R下，同时保存R首次不为空时的根，且此后head.left不变
            rightTreeMin = t; // 更新rightTreeMin
            t = t.left; // 令t.left为中间树M的根结点
        }
        else if(compareRes > 0) { // 目标在t的右子树中
            if(e.compareTo(t.right.element) > 0) t = rotateLeft(t); // 一字型左旋(左单旋)
            if(t.right == nullNode) break; // t无右儿子，已完成一次单旋(包括之字形)，跳出循环
            leftTreeMax.right = t; // 挂接到L下，同时保存了L首次不为空时的根，且此后head.right不变
            leftTreeMax = t; // 更新leftTreeMax
            t = t.right; // 令t.right为中间树M的根结点
        }
        else break; // 相等即可退出
    } // 后续四句完成组装
    leftTreeMax.right = t.left;
    rightTreeMin.left = t.right;
    t.left = header.right; // header.right为L的根
    t.right = header.left; // header.left为R的根
    return t;
}
```

<br />

##### insert

插入值为 $e$ 的结点。当前树空时，将待插入的结点作为根结点，否则 **将目标结点旋转至根处** ，再根据该结点值与 $e$ 的大小调整链接关系。

```java
public void insert(E e) { // 插入结点
    if(newNode == null) newNode = new BinaryNode<>(e);
    if(root == nullNode) { // 当前为空树，将newNode作为root插入
        newNode.left = newNode.right = nullNode;
        root = newNode;
    }
    else { // 否则将目标结点旋转至根处，比较大小后插入
        root = splay(e, root);
        int compareRes = e.compareTo(root.element);
        if(compareRes < 0) { // e小于root的值，将newNode作为根插入
            newNode.left = root.left;
            newNode.right = root;
            root.left = nullNode;
            root = newNode;
        }
        else if(compareRes > 0) { // e大于root的值，将newNode作为根插入
            newNode.right = root.right;
            newNode.left = root;
            root.right = nullNode;
            root = newNode;
        }
        else return; // 相等时不插入
    }
    newNode = null; // 下一次插入时newNode == null
}
```

<br />

##### findMin/findMax

查找具有最小/最大数据的结点的操作由驱动方法和具体方法实现。与 AVL 树中对应方法的不同仅在于此处的具体方法在找到目标结点后要对其执行一次 $splay$ 操作。

```java
public E findMin() { // 查找最小结点驱动方法
    if(isEmpty()) throw new NoSuchElementException();
    return findMin(root).element;
}
private BinaryNode<E> findMin(BinaryNode<E> t) { // 返回树的最小结点
    while(t.left != nullNode) t = t.left;
    root = splay(t.element, root);
    return t;
}
public E findMax() { // 查找最大结点驱动方法
    if(isEmpty()) throw new NoSuchElementException();
    return findMax(root).element;
}
private BinaryNode<E> findMax(BinaryNode<E> t) { // 返回树的最大结点
    while(t.right != nullNode) t = t.right;
    root = splay(t.element, root);
    return t;
}
```

<br />

##### remove

调用 $contains$ 方法查找是否存在值为 $e$ 的结点，若不存在直接返回，若存在则通过 $contains$ 方法，已将该结点展开为根结点，根据此时 $root$ 有无左儿子来执行具体的删除动作。若无左儿子，可直接删除 $root$ ，即让删除后的根结点为 $root.right$ ，否则通过 `splay(e, newRoot)` 将此时根的左子树中具有最大值的根结点 (必小于 $e$) 展开至 $newRoot$ ，以其为删除后的根结点，并执行 `newRoot.right = root.right` 。此删除为 **懒惰删除** ，即只改变链接关系来达到删除的效果。

```java
public void remove(E e) { // 删除结点
    if(!contains(e)) return; // 不存在直接返回，若存在，则该目标结点已被展开至根
    BinaryNode<E> newRoot;
    if(root.left == nullNode) newRoot = root.right; // 无左儿子，直接删除(懒惰删除)
    else { // 有左儿子
        newRoot = root.left;
        newRoot = splay(e, newRoot); // 将左子树中最大者旋转至根，令其为删除操作后的新根
        newRoot.right = root.right; // 将root.right接到newTree.right上
    }
    root = newRoot;
}
```

<br />

##### contains

若为空树直接返回 $false$ ，否则以值为 $e$ 的结点为目标执行 $splay$ ，最后根据 $splay$ 的目标结点值是否等于 $e$ 来返回 $true$ 或 $false$ 。

```java
public boolean contains(E e) { // 判断树中是否有指定元素的结点
    if(isEmpty()) return false;
    root = splay(e, root);
    return root.element.compareTo(e) == 0;
}
```

<br />

##### rotateRight

右单旋转，见前述说明。

<br />

##### rotateLeft

左单旋转，见前述说明。

<br />

#### 类的实现代码

```java
class SplayTree<E extends Comparable<? super E>> {
    private BinaryNode<E> root, newNode;
    private final BinaryNode<E> nullNode;
    public SplayTree() {
        this.nullNode = new BinaryNode<>();
        this.root = this.nullNode.left = this.nullNode.right = this.nullNode;
    }
    public void insert(E e) { // 插入结点
        if(newNode == null) newNode = new BinaryNode<>(e);
        if(root == nullNode) { // 当前为空树，将newNode作为root插入
            newNode.left = newNode.right = nullNode;
            root = newNode;
        }
        else { // 否则将目标结点旋转至根处，比较大小后插入
            root = splay(e, root);
            int compareRes = e.compareTo(root.element);
            if(compareRes < 0) { // e小于root的值，将newNode作为根插入
                newNode.left = root.left;
                newNode.right = root;
                root.left = nullNode;
                root = newNode;
            }
            else if(compareRes > 0) { // e大于root的值，将newNode作为根插入
                newNode.right = root.right;
                newNode.left = root;
                root.right = nullNode;
                root = newNode;
            }
            else return; // 相等时不插入
        }
        newNode = null; // 下一次插入时newNode == null
    }
    public void remove(E e) { // 删除结点
        if(!contains(e)) return; // 不存在直接返回，若存在，则该目标结点已被展开至根
        BinaryNode<E> newRoot;
        if(root.left == nullNode) newRoot = root.right; // 无左结点，直接删除(懒惰删除)
        else { // 有左结点
            newRoot = root.left;
            newRoot = splay(e, newRoot); // 将左子树中最大者旋转至根，令其为删除操作后的新根
            newRoot.right = root.right; // 将root.right接到newTree.right上
        }
        root = newRoot;
    }
    public E findMin() { // 查找最小结点驱动方法
        if(isEmpty()) throw new NoSuchElementException();
        return findMin(root).element;
    }
    public E findMax() { // 查找最大结点驱动方法
        if(isEmpty()) throw new NoSuchElementException();
        return findMax(root).element;
    }
    public boolean contains(E e) { // 判断树中是否有指定元素的结点
        if(isEmpty()) return false;
        root = splay(e, root);
        return root.element.compareTo(e) == 0;
    }
    public void printTree(){ // 按中序遍历打印树的驱动方法
        if(isEmpty()) System.out.println("Empty tree");
        else printTree(root);
    }
    public int size() { // 求树的结点个数驱动方法
        return size(root);
    }
    public void makeEmpty() { // 树置空
        root = nullNode;
    }
    public boolean isEmpty() { // 树判空
        return root == nullNode;
    }
    private final BinaryNode<E> header = new BinaryNode<>(null);
    private BinaryNode<E> splay(E e, BinaryNode<E> t) { // 自顶向下展开目标结点
        BinaryNode<E> leftTreeMax, rightTreeMin;
        header.left = header.right = nullNode;
        leftTreeMax = rightTreeMin = header;
        nullNode.element = e;   // 确保能够匹配，便于编程
        while(true) {
            int compareRes = e.compareTo(t.element);
            if(compareRes < 0) { // 目标在t的左子树中
                if(e.compareTo(t.left.element) < 0) t = rotateRight(t); // 一字型右旋
                if(t.left == nullNode) break; // t无左儿子，已完成一次单旋(包括之字形)，跳出循环
                rightTreeMin.left = t; // 挂接到R下，同时保存R首次不为空时的根，且此后head.left不变
                rightTreeMin = t; // 更新rightTreeMin
                t = t.left; // 令t.left为中间树M的根结点
            }
            else if(compareRes > 0) { // 目标在t的右子树中
                if(e.compareTo(t.right.element) > 0) t = rotateLeft(t); // 一字型左旋
                if(t.right == nullNode) break; // t无右儿子，已完成一次单旋(包括之字形)，跳出循环
                leftTreeMax.right = t; // 挂接到L下，同时保存了L首次不为空时的根，且此后head.right不变
                leftTreeMax = t; // 更新leftTreeMax
                t = t.right; // 令t.right为中间树M的根结点
            }
            else break; // 相等即可退出
        } // 后续四句完成组装
        leftTreeMax.right = t.left;
        rightTreeMin.left = t.right;
        t.left = header.right; // header.right为L的根
        t.right = header.left; // header.left为R的根
        return t;
    }
    private BinaryNode<E> rotateRight(BinaryNode<E> k2){ // 右单旋
        BinaryNode<E> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        return k1; // 返回调整后原失衡处结点
    }
    private BinaryNode<E> rotateLeft(BinaryNode<E> k1){ // 左单旋
        BinaryNode<E> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        return k2; // 返回调整后原失衡处结点
    }
    private BinaryNode<E> findMin(BinaryNode<E> t) { // 返回树的最小结点
        while(t.left != nullNode) t = t.left;
        root = splay(t.element, root);
        return t;
    }
    private BinaryNode<E> findMax(BinaryNode<E> t) { // 返回树的最大结点
        while(t.right != nullNode) t = t.right;
        root = splay(t.element, root);
        return t;
    }
    private void printTree(BinaryNode<E> t) { // 中序遍历打印树
        if(t != nullNode) {
            printTree(t.left);
            System.out.println(t.element);
            printTree(t.right);
        }
    }
    private int size(BinaryNode<E> t) { // 递归地遍历所有结点，返回结点总数
        if(t != nullNode) {
            if(t.left != nullNode && t.right != nullNode) {
                return 1 + size(t.left) + size(t.right);
            }
            else {
                return t.left != nullNode ? 1 + size(t.left) : 1 + size(t.right);
            }
        }
        return 0;
    }
    /**
     * 二叉树结点嵌套类
     */
    private static class BinaryNode<E>{
        public E element;
        public BinaryNode<E> left, right;
        @SuppressWarnings("unused")
        public BinaryNode(){
            this(null, null, null);
        }
        public BinaryNode(E element){
            this(element, null, null);
        }
        public BinaryNode(E element, BinaryNode<E> left, BinaryNode<E> right){
            this.element = element;
            this.left = left;
            this.right = right;
        }
    }
}
```

<br />

#### 测试代码

```java
package com.yukiyama;

import java.util.NoSuchElementException;

public class SplayTreeDemo {

    public static void main(String[] args) {
        SplayTree<Integer> t = new SplayTree<>( );
        int[] elements = {3,2,1,4,5,6,7,16,15,14,13,12,11,10,8,9};
        for(int e : elements) t.insert(e);
        t.printTree();
        System.out.printf("size: %d, min: %d, max: %d\n", t.size(), t.findMin(), t.findMax()); // 输出10
        System.out.printf("has 10? %s, has 100? %s\n", t.contains(10), t.contains(100));
        t.remove(1);
        t.remove(10);
        t.remove(16);
        t.printTree();
        System.out.printf("size: %d\n", t.size());// 输出0
        System.out.println("is empty: " + t.isEmpty()); // false
        t.makeEmpty();
        System.out.println("is empty: " + t.isEmpty()); // true
    }

}
```

<br />

### 2-3树与2-3-4树

在前面的章节中，我们分别了两种平衡二叉树的实现，其中AVL树通过跟踪并动态维护树的高度信息在每次操作后严格保持树平衡，而伸展树无需维护树的高度信息，而是通过「展开」降低多次操作的摊还时间复杂度。这两种平衡树的基础均为「旋转」操作，通过旋转来调整局部树高使树保持平衡或趋向平衡。本节我们介绍的2-3树和2-3-4树也是平衡树，但它不基于「旋转」操作，而是通过 **动态地调整结点容量** 来实现平衡。

在二叉树中，每一个结点最多只有两个子结点，当某结点拥有两个子结点时，可称其为 **2-结点** ，这种结点持有一个数据项以及两个子结点。2-3树和2-3-4树不是二叉树，因为前者除了2-结点外，还可以有 **3-结点**  (3-结点持有两个数据项以及三个子结点) ， 后者除了2-结点和3-结点外，还有 **4-结点**  (4-结点持有三个数据项以及四个子结点) 。本节我们将看到2-3树和2-3-4树如何通过结点之间的动态变换来保持平衡。

![image.png](https://pic.leetcode-cn.com/1657339600-LLHCyV-image.png)

> 「算法导论」称 [ John Hopcroft](https://en.wikipedia.org/wiki/John_Hopcroft) 于1970 发明2-3树 (未发表)。
>
> 本节内容为 Robert Sedgewick & Kevin Wayne 所著 [算法: 第4版](https://github.com/hongye612430/awesome-programming-books-1/blob/master/algorithms/%E7%AE%97%E6%B3%95%EF%BC%88%E7%AC%AC4%E7%89%88%EF%BC%89.pdf) 相关章节的整理和总结。本节在简要概括原文基础上，加入了一些自己的理解，详细内容请看原书。

<br />

#### 2-3树

一棵2-3树的结点分为内部结点 (*internal nodes*) 和叶子结点 (*leaf nodes*) ，具体定义如下。

```text
内部结点:
  2-结点: 拥有1个数据项x，2个子结点。
    -左子树中任意结点数据项均小于x。
    -右子树中任意结点数据项均大于x。
  3-结点: 拥有2个数据项x,y，3个子结点。
    -左子树中任意结点数据项均小于x。
    -中间子树中任意结点数据项介于x与y之间。
    -右子树中任意结点数据项均大于y。
叶子结点: 无子结点，数据项为 1 项或 2 项。

后续我们会看到，在2-3树的操作过程中，可能会「临时」产生一些4-结点。
```

如下是一棵典型的2-3树。

![image.png](https://pic.leetcode-cn.com/1656589324-UbHgKh-image.png)

<br />

##### 结点变换

2-3树实现平衡的基础在于 **「结点变换」** ，「插入」的不同情形很好地体现了不同的变换，下面我们通过插入操作来了解2-3树结点变换的过程。

执行插入方法之前首先要执行 $find$ 方法，当待插入结点不存在时执行插入操作。查找操作与基本 BST 的不同在于3-结点存在 2 个数据项，因此需要比较两次来确定下一步要去往该结点的左、中、还是右子树。与 BST 类似， **插入总是在树的底部执行** ，略有不同的是， BST 中待插入对象总是作为叶子结点插入，而在2-3树中，若作为叶子结点插入会破坏2-3树的 **完美平衡** ，所谓完美平衡指 **2-3树的所有叶子结点到根结点的路径长度相同** 。实际上该数据结构3-结点的设计就是为了容纳待插入对象，使树能够保持完美平衡，因此待插入对象总是被插入到一个叶子结点中，但这又带来下面2中的问题。

1. 若该叶子结点为2-结点，可直接插入，此结点变为3-结点。

2. 若该叶子结点为3-结点，插入后变为4-结点，不符合2-3树的定义。

对于2，需要进行「结点变换」，我们通过下表和示意图分析不同插入情形所对应的结点变换过程。

| 情形                                    | 具体过程                                                     |
| --------------------------------------- | ------------------------------------------------------------ |
| 1. 插入至2-结点中                       | 插入后变为3-结点                                             |
| 2. 插入至3-结点中<br />(该结点为根结点) | 插入后变为4-结点，然后分解为3个2-结点。(树高+1)              |
| 3. 插入至3-结点中<br />(父结点为2-结点) | 插入后变为4-结点，然后分解为3个2-结点，但其中一个与父结点合并，使得父结点变为3-结点 |
| 4. 插入至3-结点中<br />(父结点为3-结点) | 与上一条类似，但父结点变为4-结点，继续向上(插入一个结点后)分解直到：<br />1. 遇到2-结点，转变为情形1。<br />2. 到根处仍为3-结点，转变为情形2。 |

下图展示了从左至右依次为情形1,2,3,4。

![image.png](https://pic.leetcode-cn.com/1656589879-xmBWVS-image.png)

我们看到，2-3树的插入过程十分简单，并且从中容易看出2-3树保持平衡的关键所在。在插入的过程中，若插入3-结点，则通过向上变换有机会找到一个2-结点，2-结点膨胀为3-结点将插入对象「消化」在其中，树高不变，只有向上变换到根结点处仍不能消化时，通过分解变换，树高才会增长 1，而这个增长使得 **所有叶子结点** 到根结点的路径长度 **同时增加 1** ，因此2-3树能够保持平衡，并且是 **完美平衡** 的。我们还能感到树高的增长是缓慢的，因为在插入过程中的4-结点裂变为3个2-结点时，提高了之后的「消化能力」，使得向上变换不容易到达当前根结点使树长高。在稍后的「小结」中，我们会具体计算树高 $h$ 与结点数 $n$ 的关系。

<br />

#### 2-3-4树

##### 结点变换

在理解了2-3树的基础上，2-3-4树的学习是简单的，因为后者只不过比前者多了一种4-结点。2-3-4树保持平衡的关键也是「结点变换」，过程是类似的，如下表。

| 情形                                    | 具体过程                                                     |
| --------------------------------------- | ------------------------------------------------------------ |
| 1. 插入至2-结点或3-结点中               | 插入后变为3-结点或4结点                                      |
| 2. 插入至4-结点中<br />(该结点为根结点) | 4-结点先分解为3个2-结点后 (树高+1) 再插入。                  |
| 3. 插入至4-结点中<br />(父结点为2-结点) | 4-结点先分解为3个2-结点，但其中一个与父结点合并，使得父结点变为3-结点，然后再插入。 |
| 4. 插入至4-结点中<br />(父结点为3-结点) | 与上一条类似，但父结点变为4-结点，继续向上分解直到：<br />1. 遇到2-结点或3-结点，转变为情形1。<br />2. 到根处仍为4-结点，转变为情形2。 |

插入4-结点可以统一描述为：该4-结点分解为3个2-结点，将其中一个上送后 (与4-结点的父结点结合为3-结点或4-结点)，待插入结点插入到分解后的左子结点或右子结点中。

如下示意图中，$x$ 表示插入的键，为了方便表示，其他键都用「口」表示，但它们是不同的，且符合大小顺序的要求。从这个示意图中可直观地看到插入至2-结点/3-结点/4-结点后的变化。插入4-结点时，分解后的父结点用虚线框住表示上送的结点可能插入2-结点/3-结点/4-结点。通过这个示意图我们发现2-3-4树的插入是非常简单的，但也是非常重要的，后续的「红黑树」插入过程，将完全以这张图为基础展开。

![image.png](https://pic.leetcode-cn.com/1656929234-TWNvow-image.png)

<br />

#### 小结

现在我们来考虑2-3树中结点数 $n$ 与树高 $h$ 的关系。当一棵具有 $n$ 个结点的2-3树的所有结点均为2-结点时，树高最高，所有结点均为3-结点时，树高最低。因此有：
$$
2^{h+1}-1 \leq n \leq \frac{3^{h+1}-1}{2}
$$

$$
log _{3}(2n+1)-1\leq h \leq \log _{2}(n+1)-1
$$

即树高 $h$ 为 $O(logn)$ ，从这个角度也可以看出2-3树是平衡的，且之前我们分析过，它是完美平衡的，主要操作的最坏时间复杂度均为 $O(logn)$ 。2-3-4树的分析类似，略。



相比 AVL 树，2-3树/2-3-4树在无需通过树高信息跟踪树的平衡状态的情况下就保持了完美平衡，相比伸展树，2-3树/2-3-4树总是能 **稳定地保持平衡** ，因此它们应当是十分理想的平衡树方案，但在本节中我们未给出具体实现，这是因为需要处理的情况较多，代码编写复杂，对不同情况的判断和处理会产生许多额外的开销，因此虽然理论上很理想，在实践中却并不常用。但理解这两者是非常重要的，因为一种被广泛应用的称作「红黑树」的平衡 BST 正是以其思想为基础，更确切地说，经典红黑树与2-3-4树同构，左倾红黑树与2-3树同构 (*isomorphic*)。在后续章节中，我们将分析如何根据一些简单的规则将2-3-4树构造成经典红黑树，将2-3树构造成左倾红黑树，并给出它们的具体实现，同时我们将会看到红黑树/左倾红黑树如何兼顾2-3-4树/2-3树和 BST 两者的优点。

<br />

### 红黑树

有了2-3树/2-3-4树的知识铺垫后，本节我们学习在实践中被广为应用的 **「红黑树 (*red-black tree)*」** 。区别于后续的「左倾红黑树」，本节讲解的是 **「经典红黑树」** 。

在前文中我们提到过红黑树是2-3-4树的同构，本节我们将看到如何通过两条简单的规则将2-3-4树转变为红黑树。首先，红黑树是一棵 BST ，相比基本 BST，它通过附加的 1bit 信息 (颜色) 和旋转操作，在保持 BST 结构的基础上始终与2-3-4树同构，因此它能够沿用基本 BST 的许多操作，并且能够保持 2-3-4树「完美平衡」(在红黑树中为「完美黑平衡」) 的优点。

> 红黑树由 [Rudolf Bayer](https://en.wikipedia.org/wiki/Rudolf_Bayer) 发明于 1972 年的[此篇论文](https://link.springer.com/article/10.1007/BF00289509) 中，并称此数据结构为「对称二叉B树 (*symmetric binary B-tree*)」。「红黑树」这一称呼则由 [Leonidas J. Guibas](https://en.wikipedia.org/wiki/Leonidas_J._Guibas) 和 [Robert Sedgewick](https://en.wikipedia.org/wiki/Robert_Sedgewick_(computer_scientist)) 在[此论文](https://ieeexplore.ieee.org/document/4567957/)中提出。

<br />

#### 从2-3-4树到红黑树

##### 两条规则 (定义)

只需按照如下规则 (也可视作红黑树的定义) 即可将2-3-4树转换为红黑树。显然红黑树与2-3-4树严格对应，因此说它们是同构的。

1. 所有3-结点转换为由红链链接的两个结点 (左斜或右斜都可以)，该链的父结点为黑色，子结点为红色。
2. 所有4-结点转换为两条构成「^」形状的红链，两个子结点为红色，父结点为黑色。

下图展示了2-3-4树及其对应的红黑树 (红黑树结点未标数字，对照原2-3-4树即可知道每一个结点的数字)，中间的红黑树将红链横放，虚线框住的单条红链即为一个3-结点，两条相邻红链即为一个4-结点后， **红黑树与2-3-4树严格对应** 的关系清晰可见。

※ 关于「链的颜色」: 除根结点外，树上的每个结点都有一条来自父结点的链指向它，因此我们可以把链也涂上颜色，链的颜色与它唯一指向的结点的颜色相同。

![image.png](https://pic.leetcode-cn.com/1656829242-uMxXGa-image.png)

<br />

##### 红与黑

通过上述定义和对应关系，我们指出红黑树颜色的本质：

> 红与黑是在原 BST 结点的基础上附加的 1bit 信息，使得2-3-4树在展成 BST 的情况下仍能通过该比特信息保持与原2-3-4树同构。也就是通过查询结点的红与黑标记即能还原这些结点在原2-3-4树中所对应的结点 (2-结点/3-结点/4-结点)。

可见红与黑只不过是这 1bit 信息的具体化，实际上在程序中通常用布尔值来表达，并且规定 $BLACK = true, RED = false$，你当然也可以反过来定义，还可以用数字 1 和 0 来表达，只要体现出这 1bit 信息即可。红与黑也只不过是命名人的一种选择，在 wiki 词条中介绍了当年 Guibas 和 Sedgewick 将该2-3-4树的同构命名为红黑树的原因。不得不说「红黑」的表达确实令人印象深刻。

> In a 1978 paper, "A Dichromatic Framework for Balanced Trees", [Leonidas J. Guibas](https://en.wikipedia.org/wiki/Leonidas_J._Guibas) and [Robert Sedgewick](https://en.wikipedia.org/wiki/Robert_Sedgewick_(computer_scientist)) derived the red–black tree from the symmetric binary B-tree. The color "red" was chosen because it was the best-looking color produced by the color laser printer available to the authors while working at [Xerox PARC](https://en.wikipedia.org/wiki/Xerox_PARC). Another response from Guibas states that it was because of the red and black pens available to them to draw the trees.



现在我们再回到前述两条规则。

- 对于规则1，其本质是用两个颜色相异的结点表达2-3-4树中的3-结点，若颜色相同，则等同于失去该信息 (「信息」的本质，单纯相同无信息，单纯相异也无信息，可相同可相异，有了变化和对比才有信息)，也就无法表达3-结点 (只能表达2-结点)。子结点为红，父结点为黑只是一种规定，你完全可以规定子为黑父为红 (只要相异即可)，只不过如上面引用的 wiki 中的文字所说，红色醒目，用以提示多键结点 (3-结点/4结点) 是更自然的选择。
- 对于规则2，我们指出，4-结点转换为 BST 中的「 ^ 」形结构是一种 **更恰当的人为选择** ，因为我们完全可以把4-结点转换成3个在一条直线上的结点，而不破坏 BST 的结点有序性质。如下图，我们把前面2-3-4树例子中两处 4-结点分别展成「/」形和「\」形，如下，不难看出该 (与规则2不符的) 「红黑树」仍然满足 BST 的性质 (可填入数字验证)，并且也是完美黑平衡的，只不过相比「 ^ 」形更不平衡 (针对 BST 形态而言)，且用「 ^ 」表达4-结点只需这一种形态，而「/」和「\」却是两种形态。你可能看到过 **「红黑树中不允许出现两个连续红结点」** 、**「红黑树红结点的子结点必为黑结点」** 、**「红黑树红结点的父结点必为黑结点」** 之类的描述，原因就在于我们选择了更恰当的「^」形来表达4-结点，从而使得红黑树中不存在两个连续红结点的情况。

![image.png](https://pic.leetcode-cn.com/1656832645-LUrWPn-image.png)

总之，在红黑树中，一对父黑子红的结点就对应着2-3-4树中的3-结点，除非这个父结点的另一个孩子结点也是红，那么这三个父子子结点就对应着2-3-4树中的4-结点。更一般的描述是，红黑树通过 **子结点和父结点的颜色关系** 来将具体的红黑结点与2-3-4树中的2-结点/3-结点/4-结点相对应，具体如下。

- 2-结点：当一个黑结点不存在红子结点时，它就是2-3-4树中的一个2-结点。

- 3-结点：当一个黑结点只有一个红子结点时 (可以有两个子结点，但有且只有一个红子结点)，这对父黑子红结点构成2-3-4树中的一个3-结点。

- 4-结点：当一个黑结点存在两个红子结点时，这三个结点构成2-3-4树中的一个4-结点。

 **除上述情形外，不存在其他情形。** 

![image.png](https://pic.leetcode-cn.com/1656833806-CRJKvV-image.png)

<br />

##### 五大性质

在理解红黑树定义及红黑颜色的本质后，我们指出红黑树具有以下性质。

```
1. 红黑树的结点或者为黑色或者为红色。
2. 根结点为黑色。
3. 叶子结点的null子结点(上图未画出，通常都不会画出)为黑色。
4. 红色结点的子结点为黑色。
5. 红黑树是「完美黑平衡」的，即任意叶子结点到根结点所经过的黑链数相同。

※ 注意，「算法导论」中「红黑树」一章的「叶子结点」指的是
我们通常所理解的叶子结点(有实际意义值的末端结点)的 null 子结点。
从该书的图13-1(a)可看出。
```

- 对于1，红黑颜色即前述 1bit 信息，使得2-3-4树转换为 BST 后仍能严格表达原2-3-4树。
- 对于2，假设在原2-3-4树中根结点是一个3-结点或4-结点，按照定义 (规则1和2)，根结点必须为黑色，否则形成两个相邻的红色结点。又或红黑树只有根结点，若为红，则单个红色结点无意义，而单个黑结点有意义。
- 对于3，当叶子结点为红色时，若其 null 子结点为红色，则形成两个相邻的红色结点，违反定义，所以 null 子结点必须为黑色。
- 对于4，两个相邻红结点违反定义。
- 对于5，因为2-3-4树是完美平衡的，转换成红黑树后，不考虑红链 (本质为3-结点或4-结点) 的情况下 (即只考虑黑链，回想一下红链横放的图示) 是完美平衡的，于是对整棵红黑树，我们就说它 **完美黑平衡** 。



如果把红黑树的性质看作某种理论系统，那么这个系统完全是从一条公理出发得到的，我们姑且称之为 1bit 公理，前面已叙述过，此处再次概括如下。

> 1bit 红黑信息使 BST 形态的红黑树与2-3-4树同构。

本节开头的规则1和规则2都是这一公理的具体体现 (规则2中人为选择了更恰当的「^」形) 。而前述所谓红黑树的五大性质都是遵从两条规则得到的，因此也可以说这五大性质是从这个 1bit 公理出发得到的 (第5条是对2-3-4树固有性质的继承，但也是因为 1bit 公理使得红黑树与2-3-4树同构所继承的)。换言之，1bit 公理对红黑树系统来说是完备的。



我们不厌其烦地强调2-3-4树与红黑树的对应关系，并且深入理解红黑的本质，目的都是为了在之后的红黑树实现中，能够更清晰地看出红黑树的各种操作，本质上都是为了保持与2-3-4树同构。若能在脑海中自如地切换红黑树与2-3-4树，理解红黑树将不再困难。

<br />

#### 结点变换

现在，我们深刻地理解了红黑树与2-3-4树的严格对应关系，因此我们也可以确定其保持平衡的操作必然 **与2-3-4树严格对应** ，我们已经知道，2-3-4树是通过「结点变换」来保持平衡的，之前我们通过考察2-3-4树结点插入过程分析过其结点变换过程，在本节中我们采用对照的方式，首先考察红黑树插入结点过程中的结点变换，然后考察在2-3-4树中未涉及的删除结点过程的结点变换，后者相比前者要复杂得多。

<br />

##### 插入结点

###### 插入操作

在「红黑树保持平衡的操作与2-3-4树严格对应」这一结论的指导下，我们很容易按照2-3-4树插入情形，一边对照着画出两种树的插入过程 (后续三张图)，一边写下如下红黑树与之对应的变换过程。

| 情形                                    | 2-3-4树                                                      | 红黑树                                                       |
| --------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1. 插入至2-结点                         | 变为 **3-结点**                                              | 变为 **红链** (左斜或右斜)                                   |
| 2. 插入至3-结点                         | 变为 **4-结点**                                              | 变为两条相邻的 **红链**，<br />若原3-结点左斜，则构成^,/,<<br />若原3-结点右斜，则构成^,\,><br />非「^」形要调整为「 ^ 」形 |
| 3. 插入至4-结点中<br />(该结点为根结点) | 4-结点先 **分解** 为3个2-结点后 (树高+1) 再插入。            | 4-结点 (2-3-4树) 中的3个结点 (红黑树) 各自反色即分解，然后插入 |
| 4. 插入至4-结点中<br />(父结点为2-结点) | 4-结点先分解为3个2-结点，但其中一个与父结点合并，使得父结点变为3-结点，然后再插入。 | 同上                                                         |
| 5. 插入至4-结点中<br />(父结点为3-结点) | 与上一条类似，但父结点变为4-结点，继续向上分解直到：<br />1. 遇到2-结点或3-结点，转变为情形1。<br />2. 到根处仍为4-结点，转变为情形2。 | 同上                                                         |

这里强调一下待插入结点的颜色，对应到2-3-4树中，结点一定会被插入到2-结点/3-结点/4-结点其中之一，从后续「插入调整」中的三张图中容易看出，无论哪种情形，插入后 $x$ 一定必须为红结点才符合定义，因此总是 **将待插入结点其作为红结点插入** 。

※ 除非当前树为空，此时插入结点将作为新的根结点，其为黑色，为统一操作，在程序实现上仍然将其作为红色结点插入，最后 $root$ 会执行置黑的操作。

<br />

###### 插入调整

现在我们具体分析插入结点后的调整操作。



**■ 插入2-结点 (2变3)**

如下，**若在一黑结点下插入，且该黑结点没有红子结点时**，那么这个黑结点就代表了2-结点，也就是此时我们会将 $x$ 插入一个2-结点，因此 $x$ 可直接插入。

![image.png](https://pic.leetcode-cn.com/1656929918-vMjeLz-image.png)



**■ 插入3-结点 (3变4)**

如下，**若在一红色结点下插入，且该红结点不存在红色兄弟结点时**，那么这个红结点就代表了3-结点 (与它的黑父结点构成3-结点)，也就是此时我们会将 $x$ 插入一个3-结点，因此 $x$ 可直接插入。此外，六个格子中的左下和右上两种情形，待插入结点是在黑色结点下插入的，但也属于插入3-结点情形。

如我们在上一张表格中所述，插入3-结点将产生两条相邻的红链，若原红链左斜，则构成 「^,<,/ 」形态，若原红链右斜，则构成「^,>,\」 形态，共有 6 种情形，5种形态。其中，「^」形态的两种情形无需调整，其他情形需要经过如图的旋转和反色操作调整为符合规则2要求的「 ^ 」形态。可以看到，在左斜3-结点下插入与在右斜3-结点下插入是完全对称的，在代码分析中我们会看到镜像情形的代码只需简单修改即可。

对于两种无需处理的「^」情形，结合「插入2-结点」的情形，有此结论：**当待插入结点在一黑色结点下插入时，直接插入而无需其他处理**。

![image.png](https://pic.leetcode-cn.com/1657018538-WyYnys-image.png)



**■ 插入4-结点 (4分解后2变3)**

如下，**若在一红色结点下插入，且该红结点有一红色兄弟结点时**，那么这个红结点就代表了4-结点 (与它的黑父结点以及红色兄弟结点构成4-结点)，也就是此时我们会将 $x$ 插入一个4-结点，通过下图我们发现，插入4-结点只需将原4-结点的3个结点各自反色即可，简单得令人惊讶。

![image.png](https://pic.leetcode-cn.com/1656931544-tbgsJV-image.png)



从上述对照分析中我们发现红黑树的插入确实完美地与2-3-4树一一对应，观察这样的对应甚至可以说是赏心悦目的。除了插入3-结点需要对其中的 4 种情况稍作处理外  (两种「^」直接插入) ，插入2-结点和插入4-结点都十分简单。前面三张图片是按插入2-3-4树中哪一种结点分类分析的，实际编写代码时，我们要按照插入 BST 形式的红黑树来编写，因此还需稍作整理如下。

> 表中的case1/2/3即为「算法导论」第13章 RB-INSERT-FIXUP(T, z) 伪代码中的 case1/2/3。

【插入结点的父结点为一左子结点】

| 情形  | 2-3-4树情形                               | 红黑树情形                                                   |
| ----- | ----------------------------------------- | ------------------------------------------------------------ |
| case0 | 插入2-结点 & 插入3-结点的黑结点之下的情形 | 在黑结点下插入: 直接插入                                     |
| case1 | 插入4-结点                                | 在红结点下插入，且该结点有红色兄弟结点 (插入结点的叔结点) <br />原4-结点的3个结点反色 |
| case2 | 插入3结点，「<」形                        | 在红结点下插入，且该结点无红色兄弟结点  (插入结点的叔结点)<br />插入结点为右子结点: <br />下段左旋>反色>上段右旋 |
| case3 | 插入3结点，「/」形                        | 在红结点下插入，且该结点无红色兄弟结点  (插入结点的叔结点)<br />插入结点为左子结点: <br />反色>上段右旋 |

【插入结点的父结点为一右子结点】

| 情形  | 2-3-4树情形                        | 红黑树情形                                                   |
| ----- | ---------------------------------- | ------------------------------------------------------------ |
| case0 | 插入2-结点 & 插入3-结点之「^」情形 | 在黑结点下插入: 直接插入                                     |
| case1 | 插入4-结点                         | 在红结点下插入，且该结点有红色兄弟结点 (插入结点的叔结点):<br />原4-结点的3个结点反色 |
| case2 | 插入3结点，「>」形                 | 在红结点下插入，且该结点无红色兄弟结点 (插入结点的叔结点):<br />插入结点插入后为左子结点: <br />下段右旋>反色>上段左旋 |
| case3 | 插入3结点，「\」形                 | 在红结点下插入，且该结点无红色兄弟结点 (插入结点的叔结点):<br />插入结点插入后为右子结点: <br />反色>上段左旋 |

这两个表格是两种对称的情形，表格中「红黑树情形」对应的伪代码如下 (「算法导论」第13章 RB-INSERT-FIXUP(T, z) )。

```java
RB-INSERT-FIXUP (T, z)
1 while z.p.color == RED         // 不满足则为 case0
2   if z.p == z.p.p.left         // 插入结点的父结点为一左子结点
3        y = z.p.p.right         // 插入结点的叔结点 
4     if y.color == RED          // case1 叔结点为红色 (插入4-结点)
5        z.p.color = BLACK       // case1 反色
6        y.color = BLACK         // case1 反色
7        z.p.p.color = RED       // case1 反色
8        z = z.p.p               // case1 继续上溯调平
9     else if z == z.p.right     // case2 叔结点为黑色且插入结点作为右儿子 (插入3-结点，「<」形)
10             z = z.p           // case2 准备下段左旋
11             LEFT-ROTATE(T, z);// case2 下段左旋
12       z.p.color = BLACK       // case3 反色
13       z.p.p.color = RED       // case3 反色
14       RIGHT-ROTATE(T, z.p.p)  // case3 上段右旋 「/」形
15   else (same as then clause   // 插入结点的父结点为一右子结点
         with “right” and “left” exchanged)
16 T.root.color = BLACK
```

<br />

###### 代码实现

最后将上述伪代码翻译成代码。插入方法  `put(Node h, K key, V val)`  最后一行调用的 `fixAfterInsertion(newNode)` 方法即上述伪代码的直白翻译。方法中调用的 `flipColors`, `flipColor`, `setColor`, `rotateLeft`, `rotateRight` 相对简单，其中旋转操作与我们在AVL树中看过的旋转操作一样，这些方法的具体实现请参考「类的实现代码」。

```java
public void put(K key, V val) { // 插入key-val结点
    if (key == null) throw new IllegalArgumentException("first argument to put() is null");
    if (val == null) { // 表示删除该key
        delete(key);
        return;
    }
    put(root, key, val); // 调用实际插入方法
}
private void put(Node h, K key, V val) {
    int compareRes;
    Node<K, V> cur = h, p = null; // cur: 当前结点，p: cur的父结点
    while (cur != null) {
        p = cur;
        compareRes = key.compareTo(cur.key);
        if (compareRes < 0) cur = cur.left; // 往左
        else if(compareRes > 0) cur = cur.right; // 往右
        else { // 存在key，修改其值后返回
            cur.val = val;
            return;
        }
    } // while正常结束，后续执行插入
    Node<K, V> newNode = new Node<K, V>(RED, key, val, null, null, null); // 插入的结点总是红色的
    newNode.parent = p;
    if (p != null) { // 非空树，插入到 p 下
        compareRes = newNode.key.compareTo(p.key);
        if (compareRes < 0) p.left = newNode; // 作为左子结点插入
        else p.right = newNode; // 作为右子结点插入
    }
    else this.root = newNode; // p == null 说明未进入while，树空，newNode作为根结点插入
    fixAfterInsertion(newNode); // 向上调整，恢复红黑树平衡
}
public void fixAfterInsertion(Node<K, V> k) {
    Node<K, V> p, g; // parent, grandParent
    while (((p = parentOf(k)) != null) && isRed(p)) {
        g = parentOf(p);
        if (p == g.left) { // k的父结点是一个左儿子
            Node<K, V> u = g.right; // uncle: p的兄弟结点，k的叔结点
            if (isRed(u)) { // case1: k的叔结点为红，则k插入了一个4-结点
                flipColors(g);
                k = g; // 插入4-结点只需反色，此时要上溯到变红的g
            }
            else { // k的叔结点为黑，则k插入了一个3-结点
                if (k == p.right) { // case2: k 是一个右儿子
                    k = p;
                    rotateLeft(p); // 左旋，之后k在底部
                }
                flipColor(p); // case3: 反色 setColor(p, BLACK);
                flipColor(g); // case3: 反色 setColor(g, RED);
                rotateRight(g); // case3: 右旋
            }
        }
        else { // k的父结点是一个右儿子
            Node<K, V> u = g.left;
            if (isRed(u)) {
                flipColors(g);
                k = g;
            }
            else {
                if (k == p.left) {
                    k = p;
                    rotateRight(p);
                }
                flipColor(p);
                flipColor(g);
                rotateLeft(g);
            }
        }
    }
    if (k == root) setColor(k, BLACK);
}
```

<br />

##### 删除结点

与「插入结点」操作一样，我们仍旧遵循「红黑树保持平衡的操作与2-3-4树严格对应」这一结论，来分析「删除结点」的过程。红黑树结点删除的操作向来被看作高级数据结构中最为复杂和难以理解的操作之一，乃至于一些久负盛名的算法书，例如 Sedgewick 的「算法第4版」(该树的红黑树为左倾红黑树)、Weiss的「数算」都只有只言片语，后者的红黑树 Java 实现中甚至略去了删除结点的部分。「算法导论」给出的过程较为详细，但缺少实现代码，且只基于恢复红黑性质而未能联系2-3-4树来解释，一方面令人难以理解，一方面不能对照到2-3-4树的删除过程，总是让人对删除过程的正确性信心不足。

我们指出红黑树删除操作难以理解的一个关键在于，操作是针对 BST 形态的红黑树，但本质却是要恢复2-3-4树的完美平衡约束，在多种情形下建立二者之间的联系极大地增加了我们的思考负担。但读者朋友不必担心，本小节我将用大量篇幅及配图详细叙述，通过严格地与2-3-4树对比，确保我们能够比较轻松地理解红黑树删除操作的每一处细节，并确信归约出的4种情形确实能够覆盖所有删除情形。行文顺序如下。

1. 删除操作: 说明红黑树对应的2-3-4树中删除结点的操作。指出删除3-结点或4-结点中的键是容易的， **只有删除2-结点才会导致失衡** 。
2. 情形归约: 列出 42 种删除2-结点的情形，归约出 4 种情形， **指出其中需要向上调平的情形** 。
3. 删除调整: 通过对比2-3-4树删除2-结点的过程，分析出红黑树删除2-结点的过程 (主要为如何旋转及变色)，并给出伪代码。
4. 代码实现: 给出红黑树删除结点的 Java 实现代码。

<br />

###### 删除操作

如同 BST 的删除操作那样，删除结点的方法中，首先要找到该结点，若存在，则根据目标结点的位置及其左右子树是否存在，执行具体的删除动作，无论删除的结点在何处，最终都会 **删除一个对应于2-3-4树上的叶子结点** (这一点是关键，后面详细说明)。与「插入结点」中的考虑一样，删除结点后要保证红黑树仍保持完美黑平衡 (对应2-3-4树的完美平衡)。当要删除的结点 (红黑树) 对应为2-3-4树中3-结点或4-结点中的键时，可以直接删除该键而不破坏平衡 (叶子结点仍在，只是少了一个键)，若待删除结点对应2-3-4树中的2-结点时，删除该结点将导致其父结点 (2-3-4树) 为叶子结点，它到根结点的路径长度将比其他叶子结点少 1，也即失去了完美平衡。类似「插入结点」后的操作， **关键在于删除2-结点后如何恢复完美平衡** ，这是本节重点，在进入该内容讲解之前，我们先分析2-3-4树的结点删除操作。有了 BST 删除操作的经验，我们很容易将在2-3-4树中要删除的键 ($key$) 分为如下两种情形 (见下表情形1和情形2)。

1. 情形1: $key$ 的后继键一定在叶子结点中，且如果该叶子结点为3-结点或4-结点，一定是结点中最左侧 (最小) 的那个键。例如删除图中的30，其后继为32，若删除34，其后继为35，若删除45，其后继为48。
2. 情形2: 可直接删除目标 $key$ (键值) ，若该键在3-结点或4-结点中，例如删除32或53，删除后树仍平衡。若该键在2-结点中，如删除40，则树失衡，**此情形必须恢复平衡** 。

![image.png](https://pic.leetcode-cn.com/1657353243-VnVwnq-image.png)

| 2-3-4树删除 $key$ 情形      | 删除操作                                                     | 红黑树删除结点 $x$ 情形 | 删除操作                                                     |
| --------------------------- | ------------------------------------------------------------ | ----------------------- | ------------------------------------------------------------ |
| 情形1: $key$ 不在叶子结点中 | 用 $key$ 的后继键值替换 $key$，然后删除后继键值<br />※ 后继键必为某叶子结点中的最小键 | 情形a: $x$ 有左右子结点 | 用后继结点 (的键值) 替换 $x$ (的键值)，然后删除后继结点<br />※ 删除后继结点必为情形b或情形c |
| 情形2: $key$ 在叶子结点中   | 直接删除目标键值<br />※ 若目标键在2-结点中，删除后失衡，要恢复平衡 | 情形b: $x$ 有一个子结点 | 建立子结点与 $x.parent$ 的链接，然后删除 $x$<br />※ $x$ 及其子结点构成3-结点，删除后不会失衡 |
|                             |                                                              | 情形c: $x$ 无子结点     | 删除 $x$ <br />※ $x$ 对应2-3-4树中的多种情形，可能为红或黑，若为2-3-4树中的2-结点，则删除后失衡 |

红黑树的结点删除对应表右半边的内容，详细说明如下。

1. 情形a包括了情形1以及情形2中删除4-结点的中间 $key$ 的情况，这一情形需要找到 $x$ 的后继结点，然后转为情形b或情形c。

2. 情形b除了从情形a中转移过来的情况外，还包括情形2中删除右斜3-结点左键和删除左斜3-结点右键这两种情况。它们都表现为删除3-结点中黑色的那个结点。

3. 情形c除了从情形a中转移过来的情况外，还包括情形2中删除2-结点 (1)、删除右斜3-结点右键 (2)、删除左斜3-结点的左键 (3)、删除4-结点的左键 (4)、删除4-结点的右键 (5) 这5种情况。如果是(1)，那么删除了一个2-结点，树失衡，需要恢复平衡，如果是 (2), (3), (4), (5)，可直接删除。而且我们发现这5种情况中只有 (1) 是 $x$ 为黑色。

对于情形a，当我们判断 $x$ 存在左右孩子后，令 `x = x.successor` ，就可以转为后续情形了。对于情形b，当判断 $x$ 只有一个孩子时，我们建立 $x.parent$ 与 $x.child$ 的链接关系，然后删除 $x$ 。需要注意的是，情形b保证了 $x$ 一定是黑色的，$x.child$ 一定是红色的，删除 $x$ 后原3-结点变为2-结点，因此 $x.child$ 要置为黑色，树仍平衡，删除结束。对于情形c，直接删除 $x$ ，但若 $x$ 为黑，需要恢复平衡。



通过上述分析，我们发现仅有 $x$ 无孩子结点且为黑时才对应着需要恢复平衡的2-3-4树中删除2-结点的情形。现在我们理解了红黑树的删除操作，下面直接给出代码。删除结点的操作由公有的 $delete$ 驱动方法和私有的具体方法构成。在驱动方法中先执行 $get$ 查找是否存在键为 $key$ 的结点，存在则执行具体删除方法。代码中的注释与前述分析是完全一致的，请读者对照阅读，应当不难理解。

```java
public void delete(K key) { // 删除key对应的结点
    Node<K, V> x = get(this.root, key); // 找到key对应的结点x
    if (x != null) delete(x);
}
private void delete(Node<K, V> x) { // 删除结点x
    if (x.left != null && x.right != null) { // x有左右孩子
        Node<K,V> s = successor(x); // 找到x的后继s
        x.key = s.key; // s取代x
        x.val = s.val; // s取代x
        x = s; // x此时是实际要删除的s
    } // 经过此if后，x为实际要删除的结点，x要么是无孩子的叶子结点，要么是只有一个孩子结点
    Node<K,V> r = x.left != null ? x.left : x.right; // r: replacement，即x.child，用来取代x
    if (r != null) { // 情形b: x只有左孩子或右孩子
        // 以下四句链接x.p与r
        r.parent = x.parent;
        if (x.parent == null) root = r; // 原x为root
        else if (x == x.parent.left) x.parent.left  = r; // 原x不为root且为一个左孩子
        else x.parent.right = r; // 原x不为root且为一个右孩子
        x.left = x.right = x.parent = null; // 删除x
        setColor(r, BLACK); // #1 r一定为红，置黑
        // if (x.color == BLACK) fixAfterDeletion(r); // #2 调平
    } else if (x.parent == null)  { // case2 x无孩子且无父结点，x为根结点，且该树只有此结点
        root = null;
    } else { // 情形c: x无孩子 (r为null)
        if (x.color == BLACK) fixAfterDeletion(x); // x为2结点，调平
        if (x.parent != null) { // 删除x
            if (x == x.parent.left) x.parent.left = null; // x为一左子结点
            else if (x == x.parent.right) x.parent.right = null; // x为一右子结点
            x.parent = null;
        }
    }
}
```



实际上上面给出的代码基本上就是 JDK 的 TreeMap 中的 $deleteEntry$ [方法](https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/TreeMap.java)。说基本上是因为，在源码中，有 #2 行而无 #1 行，而我们给出的方法中有 #1 行而无 #2 行。若读者理解了前述分析，相信很容易接受我们给出的写法。反而 JDK 源码的写法似乎不佳，关于这一点，需要读者先理解接下来要讲解的 $fixAfterDeletion$ 方法后才能讨论，如果确如作者分析的那样，我们应该向 Oracle 提交该方法的改进请求。详细探讨请见「补充」。

```java
setColor(r, BLACK); // #1 r一定为红，置黑
// if (x.color == BLACK) fixAfterDeletion(r); // #2 调平
```

<br />

###### 情形归约

删除2-结点 ($x$) 后要保持完美平衡 (2-3-4树)，那么 $x$ 的父结点就必须向下补充缺失的2-结点，以保持树 (2-3-4树) 的底层同高。可以这么考虑，删除 $x$ 之前，我们先利用父结点的键将该处填充为一个3-结点或4-结点，于是 $x$ 可直接删除，父结点出借了一个键，根据其键数变化，还需要一些调整。以下列出删除2-结点的不同情形，只有情形3-2需要向上调平，其他情形在常数次操作后恢复平衡。

- 情形1: 若 $x$ 的兄弟结点为3-结点。$x$ 从其父结点中取一个键到 $x$ 中组成3-结点，但父结点的键数要保持不变，否者链的数量也会减1，因此父结点从 $x$ 的兄弟结点中取一个键。删除 $x$ ，平衡恢复。
- 情形2: 若 $x$ 的兄弟结点为4-结点。$x$ 、$x$ 的父结点中的一个键、$x$ 兄弟结点中的一个键组成一个4-结点。但父结点的键数要保持不变，否者链的数量也会减1，因此父结点从 $x$ 的兄弟结点中取一个键。删除 $x$ ，平衡恢复。
- 情形3: 若 $x$ 的兄弟结点为2-结点。由于 $x$ 的兄弟结点只有一个键，不能向上述两种情形那样通过 $x$ 兄弟结点来「间接取键」，但我们可以把 $x$ 、$x$ 父结点中的一个键、$x$ 兄弟结点合并为一个4-结点。$x$ 的父结点少了一个键，但链也少了一条，结构仍是正确的。删除 $x$。
  - 情形3-1: 若父结点为3-结点或4-结点，父结点借出一个结点，缩小为2-结点或3-结点。平衡恢复。
  - 情形3-2: 若父结点为2-结点，则在合并后父结点「缺失」。如同「插入结点」最后的向上调平，此情形的结点删除也需要继续 **向上调平** 。

情形3-2向上调平的过程中，若遇到一个3-结点或4-结点，它被亏空处「借键」后变为2-结点或3-结点)，平衡恢复。否则一直调平到根处，根为2-结点，补充亏空后整棵2-3-4树高度减1，所有叶子结点到根的路径长度同时减1，平衡恢复。

![image-20220708123110943](https://tva1.sinaimg.cn/large/e6c9d24egy1h3zeri8aepj20ce0b03z4.jpg)

※ 此图并未画出所有情形的所有子情形 (例如 $x$ 的父结点可以为2-结点/3-结点/4-结点，又如 $x$ 的位置不一定在最左边等)，但对解释删除2-结点的操作来说已经完备，读者若不放心，可依据此图过程画出其他情形。



经过上述分析，我们发现删除后的调整过程是关键。当我们试图对照2-3-4树中删除2-结点的各种情形画出红黑树删除过程中结点变换的过程时，我们很快发现 **该情形实在太多** ，逐个讨论耗时甚巨，很容易迷失在旋转与变色中，因此需要减少讨论情形。如同算法导论，我们也会指出删除结点的 **4 种情形** ，但与算导直接从抽象的红黑性质入手不同，本小节避免谈及所红黑树的5条性质，而是将2-3-4树与红黑树对照着分析，从众多具体的2-3-4树情形归约到 4 种情形。由于能够清楚地看到每一种情形的2-3-4树和红黑树，归约得到的4种情形是很容易理解和接受的。



下图全面分析删除2-结点的不同情形，建议读者预先验证下每个情形的2-3-4树是否与红黑树对应。$x$ 为一个 **左子结点** 的情形已用绿色框框住，可以看到，当它是一个右子结点时，有同样多的 **镜像情形** ，根据「插入结点」的经验，实际编程时，只需将 $x$ 为左子结点的代码中的 $left$ 和 $right$ 交换即得到镜像情形的代码。于是对于整张图的42种情形 (红黑树)，只需看绿色框中的21种。

![image.png](https://pic.leetcode-cn.com/1657191505-LgyJPv-image.png)



如下，我们列出这21种情形的标号，实际上仍未列完，图中红黑树未接结点的黑色链条，可以接2-结点、3-结点或4-结点，其中3-结点又分为左斜或右斜。不过我们 **保证已经覆盖了所有删除情形** ，因为只有与 $x$ 相邻的黑色链条才可能影响变换的结果，而在2-3-4树示意图中与 $x$ 相邻的「..□..」（即红黑树中的黑色链条所链接的2-结点/3-结点/4-结点），总能够在已经给出的某种情形中找到对应 (例如 1-4 对应2-3-4树中 $x$ 右侧的 「..□..」，可以为2-结点，3-结点或4-结点，分别由1-5，2-5，3-5对应的2-3-4树所对应)。

| $x$ 的兄弟结点 | $x$ 的父结点 | 情形               |
| -------------- | ------------ | ------------------ |
| 2-结点         | 2-结点       | 1-1                |
|                | 3-结点       | 1-2, 1-3, 1-4, 1-5 |
|                | 4-结点       | 1-6, 1-7           |
| 3-结点         | 2-结点       | 2-1                |
|                | 3-结点       | 2-2, 2-3, 2-4, 2-5 |
|                | 4-结点       | 2-6, 2-7           |
| 4-结点         | 2-结点       | 3-1                |
|                | 3-结点       | 3-2, 3-3, 3-4, 3-5 |
|                | 4-结点       | 3-6, 3-7           |



现在，我们观察所列情形的2-3-4树和对应的红黑树的形态，归约其中的等价情形。再次强调，以下讨论中 $x$ 是一个左子结点。

1. 我们首先看到 $x.p$ 为4-结点的情形，例如 1-6 ，一个红色结点连着两个黑色子结点的部分，与 1-2 是一样的。通过与它们对应的2-3-4树容易观察到，**相同部分才会参与变换**，不同的部分不参与变换，所以它们可以看作一种情形。同理，1-7, 2-6, 2-7, 3-6, 3-7 都不必重复讨论，这样就去掉了 6 种情形。

2. 利用同样的方法 (对照2-3-4树)，我们观察到 1-1, 1-2, 1-5 参与变换的部分也是一样的，同理 2-1, 2-2, 2-5 情况等价， 3-1, 3-2, 3-5 情况等价，于是再去掉 6 种情形。

3. 对于1-4，其 $x$ (在红黑树中) 的兄弟结点只能是黑色结点 (即黑链下挂的未画出的结点)，若为2-结点，则 1-1 与该部分对应对应，若为3-结点，则 2-1 与该部分对应，若为4-结点，则3-1与该部分对应，因此1-4可以不用重复讨论。同理，2-4，3-4也可以去掉。注意，虽然「^」形结构父结点在 1-1 中为黑，在 1-4 中为红，但通过对2-3-4树的观察可知，变换所涉及的结点只有「^」结构的三个结点，因此它们是等价的 (颜色变化后续说明)。

4. 现在只剩下1-1, 2-1, 3-1, 1-3, 2-3, 3-3 六种情形。更进一步，我们分析1-3, 2-3, 3-3 这三种情形。它们的共同特点是 $x$ (在红黑树中的) 的兄弟结点为红色，实际上意味着在2-3-4树中 $x$ 的父结点为 (右斜的) 3-结点。因为1-3, 2-3, 3-3 分别与1-2, 2-2, 3-2 对应同一种2-3-4树，只是前三个的 $x.p$ (3-结点) 为左斜，后三个为右斜，所以我们尝试左旋 $x.p$ 使后者与前者相同， **左旋后发现确实转换成了 1-2, 2-2, 3-2 情形** 。于是，我们遇到 $x$ 的兄弟结点为红色结点时，左旋 $x.p$ (及相应变色) 即可得到之前讨论过的情形，而 1-2, 2-2, 3-2 在上述第2条的讨论中，已经被我们去掉了，1-1, 2-1, 3-1 是它们的等价。

![image.png](https://pic.leetcode-cn.com/1657202985-hxfSCu-image.png)

最终我们从众多情形中归约出4种情形，包括三种基本情形 1-1, 2-1, 3-1，以及情形 x-3 (表示 1-3 & 2-3 & 3-3，共同点是 $x$ 的兄弟结点为红色，左旋 $x.p$ 后转换为基本情形)。

※ 情形2-1有两种，但只需要将左侧的 $w$ 右旋即可得到右侧，我们从2-3-4树的角度将此二者看作一种情形，后续实际编程时的4种情形与此处略有不同。



接下来分析这四种情形的结点删除过程，以及删除后的调整。

<br />

###### 删除调整

为方便叙述，我们将前述归约出的4种情形与「算法导论」给出的 case1~4 对照如下。

| 算法导论4情形                                 | 对应前述4情形                                                |
| --------------------------------------------- | ------------------------------------------------------------ |
| case1: $w$ 为红色                             | 情形x-3<br />只需对 $x.p$ 置红及 $w$ 反色并左旋 $x.p$ 后转为后续情形 |
| case2: $w$ 为黑色，且其孩子左黑右黑           | 情形1-1                                                      |
| case3: $w$ 为黑色，且其孩子左红右黑           | 情形2-1左侧<br />只需对 $w$ 及 $w.left$ 反色并右旋 $w$ 即为 case4 |
| case4: $w$ 为黑色，且其孩子左黑右红或左红右红 | 情形2-1右侧 & 情形3-1                                        |

※ $w$ 是待删除结点 $x$ 的兄弟结点。



现在我们画出 case1~4 删除结点 $x$ 前后的2-3-4树和红黑树。左侧的「删除前后 (2-3-4树)」是简单的，我们根据左侧2-3-4树删除 $x$ 后的结果，考虑并尝试对删除前的红黑树做旋转和颜色调整操作，不难得到右侧「删除前后 (红黑树)」中的过程。

![image.png](https://pic.leetcode-cn.com/1657258262-RCDMKq-image.png)

为了便于读者观察，黑色椭圆框框住的 $x.p$ 结点只考察了2-结点的情形，只有此情形才可能在 case2 时，需要继续向上尝试调平。如果 $x.p$ 为3-结点或4-结点，如我们在前面「删除操作」小节中讨论的那样，在本次调平后必然能够恢复平衡。而且 $x.p$ 必然为红色 (3-结点或4-结点的子结点必为红色，请看情形1-2和情形1-6的2-3-4树) ，调整后这个结点是原3-结点或4-结点出借的结点，如果还保持红色，将无法脱离原3-结点或4-结点 (2-3-4树)，因此必须置黑。这是 RB-DELETE-FIXUP(T, x) 伪代码最后一行的作用。



至此，我们已经完成了红黑树删除结点操作中最为困难的「删除后调整」的分析，并写下了在红黑树中四种删除2-结点情形的调整动作。现在只需将上图「删除前后 (红黑树)」中具体动作写成代码即可。下面是「算法导论」给出的 RB-DELETE-FIXUP(T, x) 伪代码，与我们在图中写下的过程是一样的，以下逐行给出注释。

```java
RB-DELETE-FIXUP(T, x)                     // 从被删除的结点x开始调整
1  while x ≠ T.root and x.color == BLACK  // x未上溯到根，且x为黑
2    if x == x.p.left                     // x是一个左孩子
3      w = x.p.right                      // w是x的叔结点
4      if w.color == RED                  // case1 w为红 (则x.p为3-结点，其子结点必为黑)
5        w.color = BLACK                  // case1 w置黑(反色)
6        x.p.color = RED                  // case1 x.p置红(反色)
7        LEFT-ROTATE(T, x.p)              // case1 左旋x.p (前两行反色是为了左旋后变为case2)
8        w = x.p.right                    // case1 有了第3行，此行可省略(因为旋转时x.p.right引用会相应调整)
9      if w.left.color == BLACK           
            and w.right.color == BLACK    // case2 w的孩子结点左黑右黑
10        w.color = RED                   // case2 w置红(反色，进入该分支时w一定是黑色，反色目的是让它作为一个3-结点中的红色结点)
11        x = x.p                         // case2 继续向上调整，此情况的x.p可能为黑，表示上一行注释中
                                          // 所说的3-结点是通过3个2-结点合并而来的(合并为4-结点后删去x)，因此x.p(2-结点)亏空
12     else if w.right.color == BLACK     // case3 w的孩子结点左红右黑，此情形结束后必平衡
13             w.left.color = BLACK       // case3 w左孩子置黑(反色)
14             w.color = RED              // case3 w置红(反色, 进入该分支时w一定是黑色)
15             RIGHT-ROTATE(T, w)         // case3 右旋w (前两行反色是为了右旋后变为case4)
16             w = x.p.right              // case3 有了第3行，此行可省略(因为旋转时x.p.right引用会相应调整)
                                          // 从下一行开始是w孩子结点为左黑右红或左红右红的情形，此情形结束后必平衡
17          w.color = x.p.color           // case4 继承x.p的颜色，后续左旋x.p后w会取代x.p的位置
18          x.p.color = BLACK             // case4 x.p置黑，目的是为了让它作为调整后原x位置新形成的3-结点中的黑色结点
19          w.right.color = BLACK         // case4 w右孩子置黑(反色，目的是为了让它成为一个2-结点)
20          LEFT-ROTATE(T, x.p)           // case4 左旋x.p，令左侧挂上一个3-结点(原x被删除的位置)
21          x = T.root                    // case4 此句用于退出while，因为case3和case4调整后必平衡
22   else (same as then clause with 
           "right" and "left" exchanged)  // x是右孩子，为镜像情形，将前面代码中的left与right交换即可得到本处代码
23 x.color = BLACK                        // while结束要么是case3/case4调整后已平衡 x被被置为root后主动退出，
                                          // 要么是case1/case2 x为红。若为前者无需此句(此时的root一定是黑的)
                                          // 若为后者，说明此时的x结点是原3-结点或4-结点出借的结点，如果还保持红色，
                                          // 将无法脱离原3-结点或4-结点 (2-3-4树)，因此必须置黑。
                                          // 此句也可以写成这样: if(x != root) x.color = BLACK
```

<br />

###### 代码实现

下面给出删除结点的完整代码。`delete` 驱动方法和具体方法前面已给出。

```java
public void delete(K key) {} // 前面已给出，此处省略
private void delete(Node<K, V> x) {} // 前面已给出，此处省略
public void fixAfterDeletion(Node<K, V> x) {
    Node<K, V> parent = parentOf(x);
    while (isBlack(x) && x != root) {
        if (x == leftOf(parent)) { // x是一个左子结点
            Node<K, V> sib = rightOf(parent);
            // case1：sib为红，转换为后续case
            if (isRed(sib)) {
                setColor(parent, RED);
                setColor(sib,BLACK);
                rotateLeft(parent);
                // sib = parent.right; //「算法导论」伪代码有此句，可以省略
            }
            // case2:左黑右黑，这种情形可能需要继续向上调平
            if (isBlack(leftOf(sib)) && isBlack(rightOf(sib))) {
                setColor(sib, RED);
                x = parent; // 向上调平
                parent = parentOf(x); // 更新parent
            } else { // case3 & case4 一定能够调平
                // case3: 右黑，其实就是左红右黑，转换为case4
                if (isBlack(rightOf(sib))) {
                    setColor(sib.left, BLACK);
                    setColor(sib, RED);
                    rotateRight(sib);
                    // sib = parent.right; //「算法导论」伪代码有此句，可以省略
                } // 以下是case4: 右红，其实就是左红右红或左黑右红，这种情形一定会调平
                setColor(sib, colorOf(parent));
                setColor(parent, BLACK);
                setColor(rightOf(sib), BLACK);
                rotateLeft(parent);
                x = root; //此句用于退出while，因为case3和case4调整后必平衡
            }
        } else {
            Node<K, V> sib = leftOf(parent);
            if (isRed(sib)) {
                setColor(parent, RED);
                setColor(sib, BLACK);
                rotateRight(parent);
            }
            if (isBlack(leftOf(sib)) && isBlack(rightOf(sib))) {
                setColor(sib, RED);
                x = parent;
                parent = parentOf(x);
            } else {
                if (isBlack(leftOf(sib))) {
                    setColor(sib.right, BLACK);
                    setColor(sib, RED);
                    rotateLeft(sib);
                }
                setColor(sib, colorOf(parent));
                setColor(parent, BLACK);
                setColor(leftOf(sib), BLACK);
                rotateRight(parent);
                x = root;
            }
        }
    }
    // while结束要么是case3/case4调整后已平衡 x被被置为root后主动退出，
    // 要么是case1/case2 x为红。若为前者无需此句(此时的root一定是黑的)
    // 若为后者，说明此时的x结点是原3-结点或4-结点出借的结点，如果还保持红色，
    // 将无法脱离原3-结点或4-结点 (2-3-4树)，因此必须置黑。
    setColor(x, BLACK); // 也可以写成这样 if(x != root) setColor(x, BLACK);
}
```

<br />

###### 补充

【补充1: JDK TreeMap类源码中的deleteEntry方法】

在「删除操作」小节中，我们指出 JDK 的 TreeMap 类的 $deleteEntry$ [方法](https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/util/TreeMap.java)，源码的实现略有不妥，即该方法中有如下 #2 行而无 #1 行，由于 $x.color$ 一定是黑，因此总是会执行调整方法，进入 $fixAfterDeletion$ 方法后，又因为 $r$ 的兄弟结点是一黑色的 $null$ ，因此会进入 case2 分支，执行 $x = x.p$ (即原 $r.p$ ) 语句后，满足 $x.color == BLACK$，继续调整。到这里我们可以这么理解，源码的写法使得原 $r.p$ 被看作亏空的2-结点 (确实被删除了，$r$ 取代之)，通过 $fixAfterDeletion$ 方法一定能够补上此亏空 (即向上调平)，而 $r$ 仍是红色，将与补上的2-结点 (见case2的2-3-4树) 或3-结点 (见case3或case4的2-3-4树) 组成3-结点或4-结点，因此原来补亏后亏空处变为2-结点或3-结点，现在变成了3-结点或4-结点，一方面红黑性质不变，一方面平衡也能得到保证，因此源码是正确的。但原本该处并不需要调整 (该分支删除3-结点的键，删除后并不导致失衡)，执行这样的调整显然是多余的。目前作者正尝试向 Oracle 报告该问题，若读者有不同看法也欢迎与作者交流 (hainanlxs AT yahoo.co.jp)。

```java
setColor(r, BLACK); // #1 r一定为红，置黑
// if (x.color == BLACK) fixAfterDeletion(r); // #2 调整
```



【补充2: 算法导论两处伪代码及注释】

我们给出的删除结点的方法基本上应用的是 JDK TreeMap的 `remove/deleteEntry` 方法，不过下面也给出如下「算法导论」中的相关伪代码，供读者对照学习。

```java
RB-TRANSPLANT (T, u, v)  // v取代u (链接u.p和v)
1 if u.p == T.nil        // 若u为根
2   T.root = v           // 则新根为v
3 else if u == u.p.left  // 否则若u为一左儿子
4   u.p.left = v         // 其父的左儿子更新为v
5 else u.p.right == v    // 否则若u为一右儿子，其父的右儿子更新为v
6 v.p = u.p              // v父置为u父
```

```java
RB-DELETE(T, z)                        // 待删除结点z
1  y = z
2  y-original-color = y.color          // 记录待删除结点的颜色
3  if z.left == T.nil                  // z无左孩子
4    x = z.right                       //   x为z的右孩子
5    RB-TRANSPLANT(T, z, z.right)      //   链接z.p和x
6  else if z.right == T.nil            // z无右孩子
7    x = z.left                        //   x为z的左孩子
8    RB-TRANSPLANT(T, z, z.left)       //   链接z.p和x
9  else y = TREE-MINIMUM(z.right)      // z具有两个孩子，令y为z的后继，y将用于替换z，随后删除y
10   y-original-color = y.color        // 记录y的颜色
11   x = y.right                       // x是y的右儿子（y必无左儿子）
12   if y.p == z                       // 若y的父亲为z
13     x.p = z                         //   令x的父亲为z (删除y) // 这一行CLRS写错了
14   else RB-TRANSPLANT(T, y, y.right) // 否则链接y.p和x (删除y)
15     y.right = z.right               // 将z右子树挂到y右侧 (此时y已经是x了)
16     y.right.p = y                   // 令z的右子树指向y (与上一行一起链接y和z.right)
17   RB-TRANSPLANT(T, z, y)            // 链接z.p和y
18   y.left = z.left                   // 将z左子树挂到y左侧 
19   y.left.p = y                      // 令z的左子树指向y (与上一行一起链接y和z.left)
20   y.color = z.color                 // y继承z的颜色
21 if y-original-color == BLACK        // 说明删除了一个2-结点，要调平
22   RB-DELETE-FIXUP(T, x)             // 上溯调平
```

<br />

#### 红黑树类架构

以下是红黑树类 (RedBlackTree) 架构。

| 类成员/方法 | 描述 |
| ----------- | ---- |
|             |      |

<br />

#### 主要方法



<br />

#### 时空复杂度



<br />

#### 类的实现代码

```java

```

<br />

#### 测试代码

```java

```

<br />

#### 小结

作者在这里强调，删除结点后的调整操作确实是我们分析推理出来的，而不是看了什么资料后强行背下来的。

我们才好说红黑树删除结点各情形的操作不是我们从那份资料上背下来的，而是我们分析推理出来的。

<br />

### 左倾红黑树

这一节我们学习前述经典红黑树的一种变体，即著名的 *Algorithms 4th* 一书中介绍的 **左倾红黑树 ( *Left-Leaning Red-black Tree, LLRBT* )** ，LLRBT 的提出者正是该书作者 Sedgewick。

我们已经知道，经典红黑树与2-3-4树同构，本节中我们将看到  **LLRBT 与2-3树同构** ，它也是 BST ，因此在保持2-3树的「完美平衡」优点的基础上 (在 *LLRBT* 中体现为完美黑平衡)，也能够直接继承基本 BST 操作的写法，这一点与经典红黑树是一样的。在 LLRBT 中，尤其是在其删除操作中，我们将领略技巧十分高超的代码实现。

> 「左倾红黑树」由 Sedgewick 在[这篇论文](https://sedgewick.io/wp-content/themes/sedgewick/papers/2008LLRB.pdf)中提出。
>
> [Eddie Kohler](http://read.seas.harvard.edu/~kohler/) 的文章 [Left-Leaning Red-Black Trees Considered Harmful](https://read.seas.harvard.edu/~kohler/notes/llrb.html) 指出了 LLRBT 的一些缺点，文章中对经典红黑树和 LLRBT 做了许多比较，推荐阅读。

<br />

#### 从2-3树到LLRBT

从2-3树转换为 LLRBT 比2-3-4树到红黑树的转换更为简单，只需将2-3树的所有3-结点转变为一条 **左斜的红链** (这就是 LLRBT 名称的由来) 即可。子结点 (左下结点) 为红色，父结点 (右上结点) 为黑色。显然 LLRBT 可与一棵2-3树严格对应。下图将红黑树中的红链横放，将红链看作一个3-结点后，能够很清楚地看出 LLRBT 与2-3树严格对应。

※ LLRBT 规定红链左斜是为了使红黑树更易于实现。本节图片多为 *Algorithms 4th* 的原图。

![image.png](https://pic.leetcode-cn.com/1656579122-NSljEB-image.png)

有了这样的定义和对应关系后，我们指出 LLRBT 具有以下性质。

```
1. 所有红链都是左斜的。
2. 不存在与同一个结点相连的两条红链。
3. LLRBT 是「完美黑平衡」的，即任意叶子结点到根结点所经过的黑链数相同。
```

- 1由定义决定。
- 对于2，在「红黑树」一节中我们已经知道，两条相邻的红链是4-结点。
- 对于3，因为2-3树是完美平衡的，转换成 LLRBT 后，不考虑红链 (本质为一个3-结点) 的情况下 (即只考虑黑链) 是完美平衡的，于是对整棵 LLRBT ，我们就说它完美黑平衡。

<br />

#### 结点变换

LLRBT 与2-3树严格对应，因此其保持平衡的操作也应当 **与2-3树相对应** ，我们已经知道，2-3树是通过「结点变换」来保持平衡的，之前我们通过考察2-3树结点插入过程分析过其结点变换过程，同样地，在本节中我们采用对照的方式，首先考察 LLRBT 插入结点过程中的结点变换，然后考察在2-3树中未涉及的删除结点过程中的结点变换，后者相比前者要更为复杂。

<br />

##### 插入结点

我们直接对比2-3树的插入情形，写出 LLRBT 与之对应的变换过程。

1. 情形1。在2-3树中插入目标键后2-结点变为3-结点，对应到 LLRBT 即按照基本 BST 方式插入后，插入结点与其父结点的链为 **红链** (红链才能对应到2-3树中的3-结点)，实际表现为该插入结点为红色。如果红链为右链，那么根据性质1，需左旋该链，实际操作为左旋其父结点 (左旋方法参数传入父结点)。
2. 情形2。对于2-3树插入目标键 ($x$) 后3-结点 (两个键分别为 $y,z$ ) 变为4-结点，然后分解为3个2-结点。这个分解实际上包含了三种细分情形，$x < y < z$， $y < x < z$，$y < z < x$ ，使得分解后 $x,y,z$ 的相对位置有所不同，但形态上是一样的。但对应到 LLRBT 中，这三种情形的形态各不相同，分别为 **「/」形、「<」形及「^」形** ，如后图。这三种形态都表现为 **「两条相邻的红链」** ，我们知道这代表了4-结点，所以也要像2-3树那样分解为3个2-结点，具体操作如下。
   1. 首先考虑「^」形，此形态 **本身已经是三个2-结点** ，因此直接将两条红链反色为两条黑链即可，即将左右结点的颜色属性改为黑色。需要注意的是还要将中结点 (父结点) 的颜色置为红色，这是情形3而不是情形2所要求的，此处是为了统一操作，具体原因仍然与2-3树的相关动作有关，稍后在情形3中叙述。
   2. 对于「/」形，只需将上段红链右旋后 (对右上顶点执行右旋) 即可转变为「^」形，随后反色。
   3. 对于「<」形，只需将下段红链左旋后 (对中间顶点执行左旋) 即可转变为「/」形，然后将上段红链右旋变为「^」形，最后反色。
3. 情形3。在2-3树中也是4-结点分解为3个2结点，但父结点会变为3-结点，对应到 LLRBT 中，根据情形2的分析，变换为3个2结点最终都对应着「^」形结构，父结点变为3-结点对应着 「^」 形结构的 **中结点要被置为红色** ，相当于向父结点中放入一个结点。这一对应使得该情形的 「^」 形反色时，左右两个结点被置为黑色的同时，中结点要被置为红色，并且为了统一操作，在情形2中也如此操作 (尽管在情形2中并不是必须的，但这么的另一个好处是当情形2中出现「^」形反色时我们知道此时树高增加 1)。
4. 情形4。如下图，三种情形最终都会变成右侧形态，即对应2-3树中父结点变为4-结点 (两条相邻红链)，此后继续向上按规则变换即可 (在实现中在递归的回溯过程中执行)。

![image.png](https://pic.leetcode-cn.com/1656579594-VeVCZn-image.png)

※ 在情形2中，由于 LLBRT 在操作后只有左红链，所以插入结点后一定不会出现「\」形或「>」形。

| 情形                                    | 2-3树                                                        | LLRBT                                                        |
| --------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1. 插入至2-结点中                       | 变为 **3-结点**                                              | 变为 **红链** ，若为右红链，则左旋                           |
| 2. 插入至3-结点中<br />(该结点为根结点) | 变为4-结点，分解为3个2-结点                                  | 根据新键与原3-结点(红链连接的两个结点)中两键的大小关系，有三种情形。<br />1. 「^」形，反色<br />2. 「/」形，上段右旋为「^」后反色<br />3. 「<」形，下段左旋为「/」后上段右旋为「^」后反色 |
| 3. 插入至3-结点中<br />(父结点为2-结点) | 变为4-结点，分解为3个2-结点，但其中一个与父结点合并，使得父结点变为3-结点 | 同上                                                         |
| 4. 插入至3-结点中<br />(父结点为3-结点) | 与上一条类似，但父结点变为4-结点，继续向上(插入一个结点后)分解直到：<br />1. 遇到2-结点，转变为情形1。<br />2. 到根处仍为3-结点，转变为情形2。 | 「^」「/」「<」最终都使得其上侧变为两条相邻的红链，此后再继续向上变换。 |

下图展示了在 LLRBT 的2-结点和3-结点中插入结点的过程。

![image.png](https://pic.leetcode-cn.com/1656593349-jhEnAc-image.png)

通过上述对照分析，我们看到通过颜色调整和旋转 LLRBT 的实现确实与2-3树一一对应，这也解释了一些一开始不太好理解的操作细节，例如令插入结点为「红色」、三种「相邻红链」情形的变换过程，以及「^」形时的反色动作 (两个子结点变黑，父结点变红)， 这些都是 LLRBT 与2-3树严格对应所要求的。

```java
public void put(K key, V val) { // 插入key-val结点
    if (key == null) throw new IllegalArgumentException("first argument to put() is null");
    if (val == null) { // 表示删除该key
        delete(key);
        return;
    }
    root = put(root, key, val); // 调用实际插入方法
    root.color = BLACK; // 每次插入结点后根结点都要描黑
}
private Node put(Node h, K key, V val) { // 在以h为根的树中插入结点key-val
    if (h == null) return new Node(key, val, RED, 1); // 插入 (与父结点用红链连接)
    int compareRes = key.compareTo(h.key);
    if (compareRes < 0) h.left = put(h.left, key, val); // 在左子树中寻找插入位置
    else if (compareRes > 0) h.right = put(h.right, key, val); // 在右子树中寻找插入位置
    else h.val = val; // key相等，更新键
    return balance(h); // 回溯过程中向上调整
}
private Node balance(Node h) { // 恢复结点h处的LLRBT性质
    if (!isRed(h.left) && isRed(h.right)) h = rotateLeft(h); // 左黑右红（包含「<」形），左旋
    if (isRed(h.left) && isRed(h.left.left)) h = rotateRight(h); // 「/」形，上段右旋
    if (isRed(h.left) && isRed(h.right)) flipColors(h); // 「^」型，反色
    h.size = size(h.left) + size(h.right) + 1;
    return h;
}
```

<br />

###### 旋转

现在我们来看 LLRBT 中的旋转操作。下图分别展示了左旋和右旋过程以及相应的代码，我们之前说过，2-3树/2-3-4树不是通过旋转，而是通过结点变换来保持平衡，但是，当我们用红黑树/LLRBT 来表示2-3-4树/2-3树时，为了能够在保持与2-3-4树/2-3树的对应，是需要旋转操作的，这一点我们已经在前面分析过了。从下图可以看到，LLRBT 的旋转操作与以前我们学习过的旋转操作基本一样，只是因为要保持链的颜色不变，因此多了 **结点颜色调整** 的步骤 (以及子树结点数的更新)。

![image.png](https://pic.leetcode-cn.com/1656662489-Tkudlb-Snipaste_2022-07-01_16-01-08.png)

<br />

##### 删除结点

如同 BST 的删除操作那样，删除结点的方法中，首先要找到该结点，然后用该结点右子结点为根结点的子树中的最小结点 (键值) 来替换删除目标结点，再执行删除最小结点方法删掉被替换的最小结点，因此需要 **先实现删除最小结点方法** 。

我们暂时先用2-3树来考虑删除的过程，首先把「删除结点」的表述替换成「删除键」(在2-3树中，只有最小键在2-结点中才会「删除结点」，否则只是删除键)。最小键一定在叶子结点中，当该叶子结点为3-结点时 (最小键为该3-结点的两个键中较小的那个)，直接删除该最小键即可。若最小键对应的叶子结点是2-结点，直接删除会导致2-3树失去完美平衡。为了保持2-3树的完美平衡性质，一个简单的想法是，通过某种 **「膨胀调整」** ，使得删除最小键时，它所在的叶子结点的容量比2-结点大，这时候就可以直接删除它 (此时它是结点中最左边的键)，结点仍在 (只是缩小了)，也就能够保持完美平衡。

因为我们不知道什么时候会到达最小键所在的叶子结点，为了能够让最小键所在结点最终调整成比2-结点大的结点，我们需要从根开始这一调整，在从根到目标结点的路径上，考察途径的当前结点，当此结点为2-结点时，将其膨胀。在「插入结点」过程中，对临时出现的4-结点，我们采取了分解操作，相对应地，膨胀可以看作 **分解的逆过程** 。

「结点膨胀」的实现稍后讲解，先假设已经实现，那么经过上述操作，我们 **一定能够保证** 到达最小键所在结点时，该结点比2-结点大，从而能够删除最小键而不破坏2-3树的完美平衡性质。此外，如下事实也是易知的。

1. 过程中可能会出现4-结点 (但不会出现更大的结点) ，也可以说删除操作使得这棵树的 **中间态为一棵2-3-4树** 。
2. 如果是根结点及其左右儿子结点均为2-结点的情况，这三个2-结点将膨胀为一个4-结点，树高将减 1 (对2-3-4树而言减1，对 LLRBT 而言则不变) 。
3. 最小键对应到 BST 中，一定是一个 **左斜红链下的红色叶子结点** 。

对于第 3 点，我们也可以说删除最小键所做的膨胀操作，就是为了保证我们最终删除的最小键，是一个左斜链下的红色叶子结点。

![image.png](https://pic.leetcode-cn.com/1656597810-EriWBE-image.png)

完成删除后，程序开始回溯，在回溯的过程中分解删除路径上临时产生的4-结点，这一过程与「插入结点」的回溯过程完全相同。回溯到根结点时，若删除开始之前根结点及其左右儿子结点均为2-结点的情况，它们会合成为一个4-结点，那么此时会被分解为三个2-结点，树高加 1  (对2-3-4树而言加1，对 LLRBT 而言则不变) 。

<br />

###### 膨胀

现在我们来分析「结点膨胀」，这一部分将是整个 LLRBT 最难的内容，请读者将如下文字描述与示意图和代码结合起来理解。示意图中 LLRBT 以常规的 BST 形式呈现，为了集中精力理解膨胀过程，不再表现键值，一些不重要的分支也不画出。注意，描述时我们必须同时将 LLBRT 看作2-3-4树 (虽然 LLBRT 对应的是2-3树，但删除的过程的中间态是2-3-4树) ，必要时我会在「结点」一词后用括号 (BST) 或 (2-3-4树) 来强调此时说的结点是哪种形态中的结点。之所以这样做是因为代码实现是将 LLRBT 作为 BST 来写的，但其内在逻辑遵循2-3树/2-3-4树的性质，因此当行文强调2-3树/2-3-4树时，读者不妨在脑海中将 LLRBT 中的红链放平，将水平的结点看作一个结点 (2-3树/2-3-4树的结点)。以下，我们将当前结点 (BST) 为根结点 (BST) 的情况记作case1，不为根结点的情况记作case2。



**首先处理case1** 。当前结点 (BST) 是根结点 (BST) ，为黑色，我们要考察它是2-结点还是3-结点。先列出我们的目标：

1. 如果根结点是3-结点，无需处理，继续前往左子树。
2. 如果根结点是2-结点。
   1. 且两个子结点都是2-结点，将这三个2-结点膨胀为一个4-结点。
   2. 若左子结点为2-结点，右子结点不是2-结点，就通过右子结点借一个键到左子结点中 (通过旋转，实际借的是根结点的键)。

现在来实现上述目标。在删除最小键驱动方法中，若不满足 `if (!isRed(root.left) && !isRed(root.right))` ，则说明根结点为3-结点，记作case1-1，否则根结点为2-结点，记作case1-2 (注意，根据 LLRBT 的性质，根结点及其左右子结点的形态只能是case1-1或case1-2)。对于case1-2，先将根结点 (BST) 翻红，这么操作的原因稍后解释。接着调用删除最小键具体方法，执行 `root = deleteMin(root)` 。

- case1-1: 根结点为3-结点，无需膨胀，但不直接去往左子树，而是与case1-2一样，先执行 `root = deleteMin(root)` 。
- case1-2: 根结点为2-结点，继续考察，执行  `root = deleteMin(root)` 。
  - case1-2-1: 通过 `if (!isRed(h.left) && !isRed(h.left.left))` 考察根结点的左子结点 (2-3-4树)，若不满足 $if$ 条件，则根结点的左子结点为3-结点或case1-1，无需膨胀，执行下一句 `h.left = deleteMin(h.left)` ，去往左子树递归删除。
  - case1-2-2: 若满足上述 $if$ 条件，则根结点的左子结点为2-结点，需膨胀，但还不知道是「三个2-结点膨胀为一个4-结点」，还是从根结点的右子结点 (间接地) 「借键膨胀」，这取决于根结点的右子结点是否为2-结点，于是执行 `h = moveRedLeft(h)` 进一步处理。进入该方法后首先执行反色语句 `flipColors(h)` ，这么做的原因我们马上会知道。
    - case1-2-2-1: 反色后通过 `if (isRed(h.right.left))` 考察根结点的右子结点是否为2-结点，若不满足，则为2-结点，需要将根结点及其左右子结点膨胀为一个4-结点， **而刚才的反色操作已经完成了这一膨胀** ，这就是进入 `moveRedLeft(h)` 方法后先执行反色操作的原因。
    - case1-2-2-2: 若满足，则根结点的右子结点为一个3-结点，于是通过 **两次旋转** 将左子结点膨胀为一个3-结点 (借用了原根结点的键，根结点则借来了其右子结点的键，因此可以说左子结点借了原根的键，也可以说左子结点「间接地」借了右子结点的键)。两次旋转完成后还需 **一次反色** 恢复 LLRBT 性质。另外，这一次的反色操作让我们看清了 case1-2 先将根结点翻红的原因，详细解释请看【补充QA】。

通过上述操作，当前结点为根结点的情况 (case1) 处理完成，我们保证了接下来要去往的 **根结点的左子结点** 为3-结点 (case1-1, case1-2-1, case1-2-2-2) 或4-结点 (case 1-2-2-1) 。

![image.png](https://pic.leetcode-cn.com/1656757397-byYtDn-image.png)



**接着处理case2。** 不妨假设当前结点是根结点的左子结点，根据前述分析，当前结点是一个3-结点或4-结点的最小键所在的结点 (BST) ，且为红色。我们要考察它的左子结点 (2-3-4树) 是否需要膨胀。由于当前结点不是根结点，因此在程序中此时位于删除最小键的具体方法 `deleteMin(Node h)` 中，如果当前结点的左子结点为 $null$ ，那么当前结点就是最小键，返回 $null$ 即意味着将其删除，即此句 `if (h.left == null) return null`。如果不是 $null$ ，那么有如下情况。

- case2-1: 通过 `if (!isRed(h.left) && !isRed(h.left.left))` 考察当前结点的左子结点 (2-3-4树)，若不满足 $if$ 条件，则根结点的左子结点为3-结点，无需膨胀，执行下一句 `h.left = deleteMin(h.left)` ，去往左子树递归删除。
- case2-2: 若满足上述 $if$ 条件，则当前结点的左子结点为2-结点，需膨胀，但还不知道是「三个2-结点膨胀为一个4-结点」，还是从根结点的右子结点 (间接地) 「借键膨胀」，这取决于根结点的右子结点是否为2-结点，于是执行 `h = moveRedLeft(h)` 进一步处理。进入该方法后首先执行反色语句 `flipColors(h)` ，这么做的原因我们在case1中已经见过了。
  - case2-2-1: 反色后通过 `if (isRed(h.right.left))` 考察当前结点的右子结点是否为2-结点，若不满足，则为2-结点，需要将当前结点 (BST) 及其左右子结点膨胀为一个4-结点， **而刚才的反色操作已经完成了这一膨胀** 。
  - case2-2-2: 若满足，则当前结点的右子结点为一个3-结点，于是通过 **两次旋转** 将左子结点膨胀为一个3-结点 (借用了当前结点 (2-3-4树) 中的最小键，当前结点则借来了其右子结点的键，因此可以说左子结点借了原根的键，也可以说左子结点「间接地」借了右子结点的键)。两次旋转完成后还需 **一次反色** 恢复 LLRBT 性质。

![image.png](https://pic.leetcode-cn.com/1656757415-iUfkUF-image.png)



通过上面的分析，可以感受到这部分代码极具技巧性，case2 在代码上就是 case1-2 的复用 (实际意义上只有极细微的差别)，返回前的 `balance(h)` 也与插入结点时的回溯一样，反色后旋转在一定规则的指导下竟然能配合得如此奇妙，实在是令人拍案叫绝。

```java
public void deleteMin() { // 删除最小键驱动方法
    if (isEmpty()) throw new NoSuchElementException("BST underflow");
    if (!isRed(root.left) && !isRed(root.right)) root.color = RED; // 根结点为2-结点
    root = deleteMin(root); // 调用删除最小键具体方法
    if (!isEmpty()) root.color = BLACK; // 恢复根结点颜色为黑色
}
private Node deleteMin(Node h) { // 删除以h为根结点的最小键
    if (h.left == null) return null; // 找到最小键，删除(即返回null，使得这个最小键的父结点.left=null)
    if (!isRed(h.left) && !isRed(h.left.left)) h = moveRedLeft(h); // 借键
    h.left = deleteMin(h.left); // 向左子树递归删除
    return balance(h); // 回溯过程中恢复路径上结点的LLRBT性质(分解4-结点)
}
private Node moveRedLeft(Node h) {
    flipColors(h);
    if (isRed(h.right.left)) { // h.left 的兄弟结点是3-结点
        h.right = rotateRight(h.right);
        h = rotateLeft(h);
        flipColors(h);
    } // 若不满足，说明
    return h;
}
```



【补充QA】

- 在删除最小键驱动方法 $deleteMin$ 中，case1-2 时的 `root.color = RED` 的意义？
  - 我们已经知道，一个「^」形所代表的4-结点 (父黑左右子结点红，以下简称黑红红) 分解为三个2-结点时，形态不变，只需将三个结点的颜色翻转 (翻转为父红左右子结点黑，以下简称红黑黑)。膨胀是其逆过程，因此也只需将三个结点的颜色翻转，但是不要忘了，初始时，根结点的颜色总是黑色的，因此需要先将根结点颜色翻红。通过后续动作很容易验证这一操作的必要性及正确性，根结点翻红后三个结点为红黑黑，而后的三种情况如下，均符合 LLRBT (含中间态) 的性质。
    - 不反色为case1-2-1，红黑黑。
    - 经过一次反色变为case1-2-2-1，黑红红。
    - 经过两次反色变为case1-2-2-2，红黑黑。
- $moveRedLeft$ 方法实现「借键」，这个方法名应该怎么理解？
  - (仅为作者的个人看法) 这个方法的命名大概是想表达 move red to left。整个过程看起来像是从兄弟结点借键，但实际上借的是父结点的键，只不过父结点能够借出给左子结点，是因为右子结点把其较小键借给了父结点，这是通过两次旋转实现的传递。总之代码作者想可能是想表达该方法最终让 $left$ 变 $red$ 了，但不关心是从谁那 $move$ 来的。



$deleteMax / moveRedRight$ 的分析分别与 $deleteMin/moveRedLeft$ 类似，但各自都有一条语句的区别。

- 在删除最大键的具体方法 $deleteMax$ 中，第一行的 `if (isRed(h.left)) h = rotateRight(h)` 是删除最小键具体方法所没有的。这是因为对于删除最小键，膨胀变换保证了这个最小键对应左斜链下的红色叶子结点，因此可直接删除。而最大键如果在左斜红链父结点中，就不能直接删除，需要右旋将最大键置于右链子结点后才可以直接删除。如果最大键在4-结点中，可直接删除，不过前述语句对这两种情况都统一做了右旋，使得最终可以直接删除最大键所在的右下末端结点。示意图如下。

  ![image.png](https://pic.leetcode-cn.com/1656754338-xsZTbe-image.png)

- ~~在 $moveRedRight$ 中因为「/」形执行一次上段右旋即可完成借键，无需像 $moveRedLeft$ 那样先从「>」形执行下段右旋为「\」形再上段左旋完成借键。~~ 这段话有问题，应该是为了保持 BST 结点大小性质所要求的。



最后来分析删除指定键的方法 $delete$ (包括驱动方法和具体方法) 。与 $deleteMin$ 一样，首先考虑目标键在叶子结点中 (2-3树)，且该叶子结点为2-结点中，直接删除会导致树失去完美平衡 (2-3树)。因此也要像 $deleteMin$ 那样自顶向下「膨胀」，在删除指定键的路径上，总是使当前结点不为2-结点。找到目标后在以其右子结点为根结点的子树中寻找最小键，用其键值替换掉删除目标的键值，而后执行 $deleteMin$ 删除这个最小键。具体请看如下代码注释。

```java
public void delete(K key) { // 删除指定键驱动方法
    if (key == null) throw new IllegalArgumentException("argument to delete() is null");
    if (!contains(key)) return; // 检测删除目标是否存在
    if (!isRed(root.left) && !isRed(root.right)) root.color = RED; // 根结点为2-结点
    root = delete(root, key); // 调用具体删除指定键的方法
    if (!isEmpty()) root.color = BLACK; // 恢复根结点颜色为黑色
}
private Node delete(Node h, K key) { // 在以h为根结点的树中删除指定键
    if (key.compareTo(h.key) < 0)  { // 目标在当前h的左子树中
        if (!isRed(h.left) && !isRed(h.left.left)) h = moveRedLeft(h); // h.left是一个2-结点，借键膨胀
        h.left = delete(h.left, key); // 递归删除
    }
    else { // 目标可能等于h.key也可能在h的右子树中
        if (isRed(h.left)) h = rotateRight(h); // 避免目标结点无右子树 (若无右子树则无法用min(h.right)来完成替换)
        if (key.compareTo(h.key) == 0 && (h.right == null)) return null; // h为目标结点且无右子树，说明目标结点为叶子结点，可直接删除
        if (!isRed(h.right) && !isRed(h.right.left)) h = moveRedRight(h); // h.right是一个2-结点，借键膨胀
        if (key.compareTo(h.key) == 0) { // h为目标结点且有右子树
            Node x = min(h.right); // 找到h的后继x
            h.key = x.key; // x取代h
            h.val = x.val; // x取代h
            h.right = deleteMin(h.right); // 删除x
        }
        else h.right = delete(h.right, key); // 递归删除
    }
    return balance(h); // 回溯过程中恢复路径上结点的LLRBT性质(分解4-结点)
}
```

<br />

#### 主要方法

##### put

<br />

#### 时空复杂度



<br />

#### 类的实现代码



<br />

#### 测试代码



<br />

### treap(树堆)

treap树

<br />

### JDK中的BST

发出来与大家一起学习

<br />

## B树&B+树

B树

<br />

❗️ **【NEW】** ❗️7-22 新文章发布: [树状数组 (先行版)](https://leetcode.cn/circle/discuss/qGREiN/)

小白 yuki 最近打算发一个 「树ADT」的专题，眼花缭乱的树里有一个不太典型的但特别有意思的树状数组，先发出来与大家一起学习，文中若有疏漏，还请大家不吝赐教。

另外，感谢官方，刚发出来俩小时就被 置顶+推荐 了，着实汗颜😅。

yuki的其他文章如下，欢迎阅读指正！

| 文章                                                         | 发布时间   | 数据 (截至07-12)                    |
| ------------------------------------------------------------ | ---------- | ----------------------------------- |
| [树状数组 (先行版)](https://leetcode.cn/circle/discuss/qGREiN/) | 2022-07-22 | 1w+字                               |
| [图论算法从入门到放下](https://leetcode.cn/circle/discuss/FyPTTM/) | 2022-06-17 | 5.3w+字<br />览5.4k+ 藏480+ 赞130+  |
| [十大排序从入门到入赘](https://leetcode.cn/circle/discuss/eBo9UB/) | 2022-05-16 | 2.3w+字<br />览28k+ 藏2.1+ 赞540+   |
| [并查集从入门到出门](https://leetcode.cn/circle/discuss/qmjuMW/) | 2022-05-14 | 1.2w+字<br />览8.1k+ 藏660+ 赞180+  |
| [二分查找从入门到入睡](https://leetcode.cn/circle/discuss/ooxfo8/) | 2022-05-09 | 2.2w字<br />览27.1k+ 藏1.8k+ 赞400+ |
| [图论相关证明文章列表](https://leetcode.cn/circle/discuss/GV0JrV/) | 2022-05 ~  | 系列文章，目前共6篇                 |



[2022-07-25]

-  [@isuxiz](/u/isuxiz/) (isuxiz) 指出一出笔误，感谢 🙏。

***

## 树状数组

[树状数组 (二元索引树 / 二元下标树 / Binary Indexed Tree, BIT, Fenwick Tree):](https://en.wikipedia.org/wiki/Fenwick_tree) 树状数组虽名为数组，但从其英文名可看出它实际上是一种被表达为树的数据结构，对于大小为 $n$ 的序列 $nums$ 的单个元素更新以及区间求和操作，时间复杂度都是 $O(logn)$ 。最基本的树状数组支持 $nums$ 上的这两种操作。

- 更新 $nums$ 中单个元素的值，即 **单点修改** 。
- 求 $nums$ 任意区间的元素值之和，即 **区间查询** 。

这是两种非常简单的操作，最简单的做法是直接操作 $nums$ ，单点修改的时间复杂度为 $O(1)$ ，区间查询为 $O(n)$ 。此外，利用「前缀和」，我们也可以先用 $nums$ 计算出前缀和数组  $preSum$ ，那么求 $[l , r]$ 区间和，即是求 $preSum[r+1] - preSum[l]$ ( $preSum[0]=0, preSum[1]=nums[0]$ )，时间复杂度为 $O(1)$ 。但单点修改 $nums[i]$ 要求 $preSum[i+1]$ 及之后的前缀和元素都要相应更新 (否则之后求区间和会出错)，这使得单点修改时间复杂度为 $O(n)$ 。

无论是使用普通数组还是利用前缀和数组，对于上述两种操作，均有一种的时间复杂度为 $O(n)$ 。而树状数组通过维护一个与 $nums$ 等大的 (有效元素个数相同)，在逻辑上为树状结构的数组 $tree[]$ ，能够实现两种操作的时间复杂度均为 $O(logn)$ 。

| 序列操作 | 数组   | 前缀和 | 树状数组  |
| -------- | ------ | ------ | --------- |
| 单点修改 | $O(1)$ | $O(n)$ | $O(logn)$ |
| 区间查询 | $O(n)$ | $O(1)$ | $O(logn)$ |

与 [并查集](https://leetcode.cn/circle/discuss/qmjuMW/) 一样， **树状数组是一种极具巧思，代码实现极轻巧却不失高效的数据结构** 。我们马上会看到树状数组如何借助 **二进制形式的 $nums$ 的下标值 ($[1,n]$)** ，将 $nums$ 划分为多个子区间，这些子区间构成逻辑树形结构，利用树的特点使得两种基本操作都复杂度都是 $O(logn)$ 。



为方便后续行文，我们提前介绍如下操作，并约定称呼及简称。

| 操作                        | 定义                                                 |
| --------------------------- | ---------------------------------------------------- |
| 单点修改 (Point Update, PU) | 修改 $nums$ 的单个元素                               |
| 单点查询 (Point Query, PQ)  | 查询 $nums$ 的单个元素                               |
| 区间修改 (Range Update, RU) | 修改 $nums$ 的某个区间<br />※ 区间元素都加上同一个数 |
| 区间查询 (Range Query, RQ)  | 求 $nums$ 的某个区间的区间和                         |



> 根据 wiki，树状数组最早由 Boris Ryabko (前苏联) 于1989年 [提出](http://boris.ryabko.net/dan1989.pdf) ，并在1992 年发表了一个 [改进版本](http://boris.ryabko.net/ryabko1992.pdf) 。 Peter Fenwick  在其1994年的 [文章](https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.8917) 中描述了该数据结构，随后此数据结构便以 Fenwick tree 之名广为人知。
>
> This structure was proposed by Boris Ryabko in 1989[[1\]](https://en.wikipedia.org/wiki/Fenwick_tree#cite_note-1) with a further modification published in 1992.[[2\]](https://en.wikipedia.org/wiki/Fenwick_tree#cite_note-2) It has subsequently become known under the name Fenwick tree after [Peter Fenwick](https://en.wikipedia.org/w/index.php?title=Peter_Fenwick_(computer_scientist)&action=edit&redlink=1), who described this structure in his 1994 article.[[3\]](https://en.wikipedia.org/wiki/Fenwick_tree#cite_note-3)
>
> 
>
> 作者的「树状数组」知识，最初学自 OI wiki [树状数组](https://oi-wiki.org/ds/fenwick/)。

<br />

### PURQ BIT (单改区查)

最基本的树状数组是支持「单点修改 (PU)」和「区间查询 (RQ)」的 PURQ BIT。

<br />

#### 区间划分

使用普通数组或利用前缀和数组实现 PU/RQ 两种操作时，均有一种操作需要遍历 **一段连续的区间**，在 $nums$ 上的「连续」操作使得时间复杂度为 $O(n)$ 。为了提高操作效率，我们必须减少操作的次数。首先考虑求长度为 $k$ 的区间的区间和操作，我们会想，如果不是连续地相加 $k$ 次，而是通过某种预先处理的手段，将大小为 $k$ 的区间 **划分为多个子区间** ，子区间个数少于 $k$ ，每一个子区间的区间和都被实时维护，那么求区间和时，就只需要执行少于 $k$ 次的相加了 (子区间的区间和相加)。例如下图，当我们求 $nums$ 区间 $[4, 9]$ (下标从1开始) 的区间和时，如果我们能通过某种方式，找到子区间1 $[4,5]$ 、 子区间2 $[6,8]$ 、子区间3 $[8,8]$ ，且这些子区间的区间和总是能够被实时维护，那么只需3次相加即可得到要求的区间和 $0+5+19+8=32$。  

![image.png](https://pic.leetcode-cn.com/1657792001-iysLcR-image.png)

**那么树状数组是这一想法的实现吗？答案是：不完全是。** 树状数组确实将 $nums$ 划分成了多个区间，但并不是对任意区间 $[l,r]$ 划分连续子区间，而是通过「前缀区间和」做差的方式来得到指定区间的「区间和」。我们提前指出，树状数组这一数据结构，对输入数组 $nums$ 划分为多个子区间，使得对任意的 $[0,k]$ 前缀区间，都可以由划分结果中的若干个连续的子区间构成，代表每个子区间的区间和相加即可得到「前缀区间和」。对于任意区间 $[l,r]$ ，将右界前缀区间 $[0, r]$ 的区间和减去左界前一位的前缀区间 $[0,l-1]$ 的区间和，即为 $[l,r]$ 区间和。

区间划分的思考也许会让你想到利用「倍增思想」的快速幂算法 [leetcode #50-pow(x, n)](https://leetcode-cn.com/problems/powx-n/) ，该算法不是通过「连续」地将 $x$ 相乘 $n$ 次，而总是借助已经算出的结果来快速得到新的更大范围的中间结果，这个中间结果又能用于之后求更大范围的结果的计算中。实际上除了倍增思想，ß动态规划、记忆化搜索都体现了这种 **「从已完成的处理开始下一步处理」** 的思想。现在，我们重新将 **树状数组解决区间和问题** 的灵感来源描述如下: 

> - $nums$ 上任意 $[l, r]$ 的区间和，将通过 $[0,r]$ 和 $[0, l-1]$ 的区间和 (前缀和) 做差得到。
> - 前缀区间由若干个相邻的子区间构成，这些子区间的区间和相加得到前缀区间的区间和。
> - 所有的子区间，是根据 $nums$ 下标的二进制表示来划分的。

很抽象，尤其是最后一句，无法得知如何处理下标的二进制数来得到子区间划分，不过没关系，我们马上对大小为 8 (下标范围为 $[1,8]$)的 $nums$ 实践上述描述。 首先明确为了实现「更快地求区间和」的需求：

※ 这里要注意下标，原本输入数组 $nums$ 的下标为 $[0,n-1]$ ，但我们先将其看作 $[1,n]$ ，后面你会知道为何要这样处理。

1. 将指定长度的 $nums$ 划分为若干区间。对 $nums$ 下标的划分动作应当是一种 **可循环的操作** 。
2. $nums$ 上的任意区间 $[l, r]$ 的区间和可由 $[1,r]$ 区间和与 $[1,l-1]$ 区间和做差得到，这是「前缀和」的思想。这要求 $[1, l-1], [1,r]$  均由 $nums$ 划分结果中的若干 **相邻区间** 所构成。从这里可以看出， 对 $nums$ 的划分，不只是对 $[1,n]$ 的划分，而是对 $[1,k](k∈[1,n])$ 的划分，划分后，一定能由若干连续区间构成任意的 $[1,k](k∈[1,n])$ 。
3. 子区间的区间和被 **实时维护** 。需要用一个 $tree[]$ 数组保存这些子区间和 (我们马上会知道为什么命名为 $tree$)。
4. 求给定区间的区间和，即求两次前缀区间和再做差。求前缀区间和需要通过 **某种规则** 一边寻找其子区间 $i$ ，一边将 $tree[i]$ 累计到结果中。
5. 更新 $nums[i]$ 时，通过 **某种规则** 更新包含该值的所有子区间的区间和。

前述描述的后半句提到了「二进制表示」，以划分区间 $[1,7]$ 为例，我们先写出 7 的二进制表示 $7=(111)_2$ 。我们要求划分动作是可循环的操作，且对于任意长度的 $nums$，都能通过同样的方式完成划分。显然，区间 $[1,7]$ 的最右子区间的右界是 7 ，最左子区间的左界是 0 (开区间，稍后可知子区间为何是左开右闭形式) 。我们将最右子区间作为当前区间，从当前子区间右界下标 7 开始考虑。

一个容易想到的方法是，每次都将当前子区间右界下标最低位的 1 换成 0 ，作为当前区间的左界下标，同时也是其 **左邻子区间的右界下标** ，重复该操作直到当前区间右界下标为 0 (二进制数所有位都没有 1) ，这时候划分就完成了。于是区间 $[1,7]$ 被划分为这三个左开右闭区间 $((000)_2,(100)_2]$ , $((100)_2,(110)_2]$ , $((110)_2,(111)_2]$ ，即 $(0,4]$ , $(4,6]$ , $(6,7]$。一番验证后，我们发现，这样的区间划分方式完全符合前述 5 点要求，具体如下。

1. 规则是固定的，因此操作是可循环的，通过这种方式，我们一定能够将 $nums$ 的任意 $[1, k]$ 区间划分为一些子区间。 也容易看出，$[1,k]$ 无论怎么划分，一定有且只有一个以 $k$ 为右界的子区间。$k$ 的取值有 $n$ 种，因此 **长度为 $n$ 的 $nums$ 划分出 $n$ 个子区间** ，这些子区间的右界是 $\{1,2,3,...,n\}$  ，左界是 $\{1-lowbit(1),2-lowbit(2),3-lowbit(3),...,n-lowbit(n)\}$ ($lowbit(i)$ 就是最低位的 1 代表的数字，后续介绍其实现)。
2. 根据1，对于任意的 $[l,r]$ ，一定有对应的 $[1,l-1]$ 和 $[1,r]$ ，将二者的区间和做差即可得到 $[l,r]$ 的区间和。
3. 单点修改会导致包含被修改的元素值的区间的区间和发生变动，需要对这些区间的区间和做同样的更新操作。现在我们还不知道要怎么找 「**包含给定元素的所有区间」** ，留到后续说明。
4. 「将当前子区间右界下标最低位的 1 换成 0」的划分方式即为该规则。
5. 同3，后续说明。

根据上述1，我们得知 $tree[]$ 的大小为 $n+1$，因为划分的 $n$ 个子区间的右界元素都唯一地存在于该区间中，当我们要表达这些区间 (的区间和 $tree[]$ ) 时，可由区间右界作为 $tree[]$ 的下标，例如 $tree[5]$ 指的是右界为5的区间的区间和 (只有该区间包含了 $nums$ 中的第 5 个元素)，或者也可以说是 $nums$ 的第5个区间的区间和 (注意，$tree[0]$ 无意义)。另外，左界中的 $i-lowbit(i)$ 就是我们介绍的划分方式的位运算实现，下面先介绍 $lowbit$ 方法。



还是抽象？再坚持一下，$lowbit$ 之后上图。

<br />

##### lowbit

前面我们说过「将当前子区间右界 $i$ 的二进制表示中最低位的 1 换成 0 后作为该子区间左界，也即其左邻子区间右界 (更新 $i$ )」，在代码中我们通过巧妙的位运算来实现 $i$ 的这一更新。 下图以两个例子 (110101, 101000) 展示这一运算过程，也即下式。
$$
i=i\&(\sim i+1)
$$
![image.png](https://pic.leetcode-cn.com/1657804443-daTLhp-image.png)

正数 $i$ (「下标」大于等于1，必为正) 的相反数 $-i$ 是负数，[我们知道](https://en.wikipedia.org/wiki/Signed_number_representations)，负数在计算机中以补码 (*two's complement*) 表示，**负数 $-i$ 的补码为对应正数 $i$ 的除符号位外按位取反后再加1**，即 $-i=\sim i+1$ ，恰好与上述式子与运算 $\&$ 的右边相同，于是我们给出如下 $lowbit(i)$方法，如其方法名所表达的那样， **该方法返回下标 $i$ 的二进制表示中的最低位的 1 所代表的数** 。后续我们可以用该方法方便地对当前子区间右界 $i$ 求其左界，即其左邻子区间右界 ( $i-lowbit(i)$ )。

```java
private int lowbit(int i){
    return i & -i;
}
```

下图展示了大小为 16 的 $nums$ (图中的 $a$ 数组) 的子区间划分，$t[]$ 即 $tree[]$ ，16个矩形代表划分出的16个子区间，$tree[]$ 的大小为 $n+1=17$ ，有效区间和元素下标范围为 $[1, 16]$ 。$tree[1]$ 表示右界为 $nums$ 第 1 个元素的区间的区间和，$tree[2]$ 表示右界为 $nums$ 第 2 个元素的区间的区间和，依次类推。蓝线表示 **区间包含关系** 。单点修改操作需要更新所有包含修改点的区间的区间和，寻找包含修改点的区间的过程就是 **沿着蓝线向上** 的过程。将该图稍作调整即可得到下一张更标准的树形图。到这里，相信读者们应该对「树状数组」和 「*Binary Indexed Tree*」有了更深的理解。需要强调的是，$tree$ 所代表的逻辑树并非二叉树，英文名称中的 binary 指的是下标二进制表示中的 0 或 1，表达的是下标二进制数位的 01 变化，与 $tree$  逻辑结点的索引关系。

![image.png](https://pic.leetcode-cn.com/1657805887-koFSHU-image.png)



![image.png](https://pic.leetcode-cn.com/1657805919-gmDwXI-image.png)



接下来我们分析如何实现「单点修改」和「区间查询」，分析过后你会知道之前需求 3 和 5 是如何被满足的。

<br />

#### 单点修改

更新 $nums$ 的第 $k$ 项 ($nums[k - 1]$) ，需要相应地更新包含它的所有区间的区间和 $tree[]$ 。通过前面的树状图，我们不难看到，**第一个要更新的区间和一定是 $tree[k]$**  (图中的 $a[]$ 即为 $nums[]$ ，注意 $a[]$ 的下标是从 1 开始的)。沿着蓝线上升，考虑蓝线连接的父子结点的下标二进制表示，我们发现包含修改点 (子结点) 的下一个更大的区间 (父结点) 的右界总是 $i = i + lowbit(i)$ ，这也是下一个包含 $nums[k-1]$ 的更大区间和逻辑结点的下标 (父结点下标)。每上升一层，就会找到包含修改点的更大范围的区间。

单点修改方法的方法签名为 `public void update(int i, int val)` ，表示更新 `nums[i] = val`  ，但对于蓝色链条上的「区间和」 $tree[i]$ 的更新，要做的是使 $tree[i]$ 加上增量，即 `tree[i] += val - nums[i]` 。因此该 $update$ 方法调用 `private void add(int k, int x)` 方法，表示为第 $k$ 个区间和结点的区间和加上增量 $x$ 。每次更新 $tree[i]$，都通过调用 $add$ 方法从第 $i$ 个区间沿着蓝色链条完成所有区间和的更新，可见 $add$ 方法的主体是一个循环，蓝色链条上的区间和结点下标 $i$ 的更新我们已经知道，于是不难写出如下 $update$ 和 $add$ 方法。寥寥数行，配合 $lowbit$ 向上更新，十分奇妙。

```java
public void update (int i, int val){ // 单点修改: nums[i] = val
    add(i + 1, val - nums[i]); // 第一个包含 nums[i] 的区间对应树状数组中的第 i+1 项 tree[i+1]
    nums[i] = val; // 更新 nums[i] 为val
}
private void add(int k, int x){ // 单点修改: nums[k-1] += x (nums[k-1]是 nums 中的第 k 项)
    for(int i = k; i <= n; i += lowbit(i)){ // 下一个区间和结点下标为i += lowbit(i)
        tree[i] += x; // 包含第k项的区间都加上x
    }
}
```

下图展示了 $add(5,2)$ 的过程。

![image.png](https://pic.leetcode-cn.com/1657847860-UpKilj-image.png)

<br />

#### 区间查询

给定 $nums$ 上的区间 $[l,r]$ ，求区间和。利用前缀和的思想，我们定义方法 `private int query(int k)` ，表示求 $nums$ 的前 $k$ 项和，那么求 $[l,r]$ 的区间和即为 `query(r + 1) - query(l)` 。在「区间划分」中我们已经知道通过 `i = i - lowbit(i)` 的方式从 $i = r + 1$ 开始依次求出组成 $[0,r]$ 区间的子区间的右界下标，也即区间和逻辑结点 $tree[i]$ 的下标，依次将得到的 $tree[i]$ 累计即可得到要求的前缀区间和。可见 `query(k)` 方法的主体是一循环，循环终止条件是 `i == 0` ，循环终止时求出 $nums$ 的前 $k$ 项和，不难写出如下 $sum$ 和 $query$ 方法。

```java
public int sum(int l, int r){ // 查询区间和: 求nums[l]到nums[r]之和
    return query(r + 1) - query(l);
}
private int query(int k){ // 查询前k项和
    int ans = 0;
    for(int i = k; i > 0; i -= lowbit(i)){ // 下一个左邻区间和结点下标为i -= lowbit(i)
        ans += tree[i];
    }
    return ans;
}
```

下图展示了 $query(15)$ 的过程。

![image.png](https://pic.leetcode-cn.com/1657847786-pRDRJc-image.png)

<br />

#### 初始化

从「区间划分」入手，我们轻松地得出了基本树状数组所要解决的单点修改和区间查询操作，但这两种操作都要建立在最初 $tree[]$ 有值的情况下，现在我们回过头分析 $tree[]$ 的初始化。 一开始 $tree[]$ 所有元素值均为0，前面我们说过，单点修改 $nums[i]$ 时，首个需要更新的结点的区间和为 $tree[i + 1]$ ，调用 $add$ 方法，更新 $tree[i + 1]$ 之后，$add$ 中的 $for$ 循环会沿着蓝色链条向上更新所有包含该修改点的更大的区间结点的区间和。因此， $tree[]$ 的初始化可以按任意顺序调用 $n$ 次 $add$ 初始化 $n$ 个区间和，每次调用 $add$ 更新某个区间和时，总能保证受影响的更大区间和得到更新。一般我们按 $1 \sim n$ 的顺序初始化 $tree$ ，在树状数组的构造器中的初始化如下。

```java
class BIT{
    int[] nums, tree; // nums为输入数组，tree为区间和数组
    int n; // nums大小
    public BIT(int[] nums){
        this.nums = nums;
        this.n = nums.length;
        this.tree = new int[this.n + 1];
        for(int i = 0; i < n; i++){ // 依次更新第1个到第n个区间和结点tree[i+1]
            add(i + 1, nums[i]);
        }
    }
}
```

<br />

#### 时空复杂度

**时间复杂度:** 

1. 单点修改时间复杂度: $O(logn)$ 。

   取决于更新结点到根结点的路径上的结点数，更新 $nums[0]$ 时路径上结点数最多，其数量为 $tree[i]$ 的下标 $i$ 从 $(000...001)_2$ 通过 $i += lowbit(i)$ 逐位更新到 $(100...000)_2$ 的更新次数 (初始算一次)，也即 $(n)_2$ 的位数，也即 $logn$ ，因此单点修改的时间复杂度为 $O(logn)$。
2. 区间查询时间复杂度: $O(logn)$ 。

   区间为 $[l, r]$。 取决于 $[1,r]$ 区间的连续子区间个数。根据子区间界的计算方法，子区间个数与 $r$ 的二进制数中 1 的数量有关，假设 $r$ 的二进制数有 $k$ 位，则 $n=2^k-1$ 时 1 的位数最多，共 $k$ 个， $k=log(r+1)$。根据 $sum$ 方法，先求 $[1,l], [1,r]$ 的前缀区间和，$l$ 不大于 $r$，时间复杂度为 $O(2*logr)$ ，$r$ 最大为 $n$ ，因此区间查询的时间复杂度为 $O(logn)$。

3. 初始化时间复杂度： 调用 $n$ 次 $add$ ，时间复杂度为 $O(nlogn)$ 。

**空间复杂度:** $O(n)$ ，取决于 $tree$ 数组大小。 

<br />

#### 类的实现代码

以下是「基本树状数组」 类 $BIT$ (PURQ) 的实现代码，所有方法均已分析。

```java
class BIT{
    int[] nums, tree; // nums为输入数组，tree为区间和数组
    int n; // nums大小
    public BIT(int[] nums){
        this.nums = nums;
        this.n = nums.length;
        this.tree = new int[this.n + 1];
        for(int i = 0; i < n; i++){
            add(i + 1, nums[i]);
        }
    }
    public int sum(int l, int r){ // 查询区间和: 求nums[l]到nums[r]之和
        return query(r + 1) - query(l);
    }
    public void update (int i, int val){ // 单点修改: 令nums[i] = val
        add(i + 1, val - nums[i]); // nums[i]对应树状数组中的第i+1项tree[i+1]
        nums[i] = val; // 更新 nums[i] 为val
    }
    private int query(int n){ // 查询前n项和
        int ans = 0;
        for(int i = n; i > 0; i -= lowbit(i)){ // 下一个左邻区间和结点下标为i -= lowbit(i)
            ans += tree[i];
        }
        return ans;
    }
    private void add(int k, int x){ // 单点修改: nums[k-1] += x (nums[k-1]是 nums 中的第 k 项)
        for(int i = k; i <= n; i += lowbit(i)){ // 下一个区间和结点下标为i += lowbit(i)
            tree[i] += x; // 包含第k项的区间都加上x
        }
    }
    private int lowbit(int i){
        return i & -i;
    }
}
```

<br />

### RUPQ BIT (区改单查)

前述基本树状数组 (PURQ BIT) 很好地支持了「单点修改」及「区间查询」操作，当我们需要更多的区间操作时，例如「区间修改」操作，即将指定区间的每一个元素都加上同一个值，如果仍用基本树状数组，我们只能对区间内的每一个元素都执行一次单点修改来实现，易知该操作的时间复杂度为 $O(nlogn)$ 。接下来我们介绍的 RUPQ BIT 引入差分数组 $diff[]$ ，使得「区间修改」和「单点查询」操作的时间复杂度均为 $O(logn)$ 。

<br />

#### 差分数组

「RUPQ BIT」实现的关键是 **「差分数组」** 。对于大小为 $n+1$ 的输入数组 $nums$ ，我们规定 $nums[0]=0$ ，其有效数字范围为 $[1,n]$ 。对差分数组 $diff[]$ ，有 $diff[i] = nums[i] - nums[i - 1]$ 。下面我们指出关于差分数组的重要性质。 

1. 区间修改: $[l, r]$ 区间每个元素加 $x$ 。根据 $diff$ 的定义，$nums$ 上完成该区间修改后 (实际不修改 $nums$)，除了 $diff[l] += x$ 、$diff[r+1] -= x$ 外，其他 $diff$ 元素值不变，因为区间内做差的两个值都增加了 $x$ ，差值不变。 
2. 单点查询: 由于我们不修改 $nums$  的元素 (否则时间复杂度为 $O(n)$ )，因此区间修改后，我们将无法再通过 $nums$ 来查询单个元素值。但通过下式，我们有 $nums[k] = \sum_{i=1}^{k} diff[i]$，也就是 $diff$ 到第 $k$ 项的前缀和为 $nums[k]$ 。 

$$
\begin{aligned}
nums[k] &=(nums[k]-nums[k-1])+(nums[k-1]-nums[k-2])+...+(nums[1]-nums[0]) \\
&= diff[k]+diff[k - 1]+...+diff[1]
\end{aligned}
$$

例如 $nums = \{0,4,2,-2,7,8\}$  (有效数字是 $\{4,2,-2,7,8\}$ )，则 $diff =\{0,4,-2,-4,9,1\}$ 。我们对先对 $[2,4]$ 区间加 3，然后再求 $nums[3]$ 。 

| 操作             | nums                                  | diff                |
| ---------------- | ------------------------------------- | ------------------- |
| 初始             | $\{0,4,2,-2,7,8\}$                    | $\{0,4,-2,-4,9,1\}$ |
| $[2,4]$ 区间加 3 | $\{0,4,5,1,10,8\}$ <br />※ 实际不修改 | $\{0,4,1,-4,9,-2\}$ |

$nums[3]=diff[1]+diff[2]+diff[3]=1$ ，通过 $diff$ 前缀和完成了单点查询。容易看出，借助「差分数组」，对 $nums$ 的区间修改实际上是对 $diff$ 的两次单点修改，的时间复杂度为 $O(1)$ ，对 $nums$ 的单点查询实际上是对 $diff$ 的区间查询 (前缀区间查询)， 时间复杂度为 $O(n)$ 。

通过上述分析我们发现，如果把 $diff[]$ 数组看作基本BIT (PURQ) 中的 $nums[]$ ，那么区间查询时对 $diff[l]$ 和 $diff[r+1]$ 的修改就对应了基本BIT中的 $add$ 操作，单点查询则对应基本BIT中的 $query$ 操作。下面我们分析 RUPQ BIT，并给出实现。

<br />

#### 从PURQ到RUPQ 

快速理解 RUPQ BIT 的关键只需明确一点: RUPQ BIT 中的 $tree[]$ 对应的是 $diff[]$ 的所有子区间的区间和。如下是 PURQ BIT 和 RUPQ BIT 的简单对比。

|                  | 单点修改区间查询 (PURQ)                    | 区间修改单点查询 (RUPQ)                    |
| ---------------- | ------------------------------------------ | ------------------------------------------ |
| 输入数组         | $nums[]$                                   | $nums[]$                                   |
| 前缀区间求解对象 | $nums[]$                                   | $diff[]$                                   |
| 逻辑二元索引树   | $nums[]$ 的所有子区间的区间和构成 $tree[]$ | $diff[]$ 的所有子区间的区间和构成 $tree[]$ |

通过「差分数组」的学习，我们知道 RUPQ BIT 的「区间修改」，实际上只需要执行 $add(l, x)$ 以及  $add(r+1,x)$ 。我们已经知道，$add$ 方法中的 $for$ 循环会沿着结点的父链不断更新更大区间的区间和。这一点保证了「单点查询」时， 执行 $query(k)$ 能够取得正确的 $diff[1] \sim diff[k]$ 的和，也就是 $nums[k]$  。除了需要从 $nums$ 求出 $diff$ ，RUPQ BIT 的 $add$ 和 $query$ 方法与 PURQ BIT 是完全相同的。

<br />

#### 时空复杂度

分析方法及结果均同 PURQ BIT。

<br />

#### 类的代码实现

```java
class RUPQBIT { // 区间修改单点查询
    int[] diff, tree; // nums为输入数组，diff为差分数组，tree代表的是 diff 的区间和。
    int n;
    public RUPQBIT(int[] nums){ // 输入的nums有效元素从 nums[1] 开始，共 n 个，nums大小为 n+1
        this.n = nums.length - 1; // 有效元素个数
        this.diff = new int[this.n + 1];
        this.tree = new int[this.n + 1];
        for(int i = 1; i <= n; i++){ // 求diff[]
            diff[i] = nums[i] - nums[i - 1];
        }
        for(int i = 1; i <= n; i++){ // 初始化tree[]
            add(i, diff[i]);
        }
    }
    public void rangeUpdate(int l, int r, int x){ // 区间修改
        add(l, x);
        add(r + 1, -x);
    }
    public int query(int k){ // 单点查询 nums[k]
        int ans = 0;
        for(int i = k; i > 0; i -= lowbit(i)){ // 下一个左邻区间和结点下标为i -= lowbit(i)
            ans += tree[i];
        }
        return ans;
    }
    private void add(int k, int x){ // 为第k个结点tree[k]加上x
        for(int i = k; i <= n; i += lowbit(i)){ // 下一个区间和结点下标为i += lowbit(i)
            tree[i] += x; // 包含第k项的区间都加上x
        }
    }
    private int lowbit(int i){
        return i & -i;
    }
}
```

<br />

### RURQ BIT (区改区查)

本小节介绍第三种 BIT 。RURQ BIT 以 $O(logn)$ 时间复杂度支持「区间修改」及「区间查询」。

<br />

#### 从RUPQ到RURQ

该版本的 BIT 在 RUPQ BIT 差分数组的基础上， **通过算式推导发现只需再引入一棵逻辑树即可实现「区间查询」** 。推导过程如下。
$$
\begin{aligned}
sum(l,r) &= preSum(r)-preSum(l-1) \\
&= (nums[1]+nums[2]+,...,+nums[r])-(nums[1]+nums[2]+...+nums[l-1]) \\
\\
preSum(k)&=nums[1]+nums[2]+,...,+nums[k] \\
&=(diff[1])+(diff[1]+diff[2])+,...,+(diff[1]+diff[2]+,...,+diff[k])\\
&=k*diff[1]+(k-1)*diff[2]+,...,+(k-(k-1))*diff[k] \\
&=k*(diff[1]+diff[2]+,...,+diff[k])\\
&\quad-(0*diff[1]+1*diff[2]+,...,+(k-1)*diff[k])
\end{aligned}
$$
从 $preSum(k)$ 的推导结果可以看到，减号左边是 $k$ 倍的 $query(k)$ (RUPQ BIT)，而右边可以引入一棵新的逻辑树 $helperTree$ 来维护数组 $helperArr=\{(i-1)*diff[i]\}, i∈[1,n]$ 的区间和，每次区间修改时，同时修改 $tree, helperTree$ ，如此，便可通过上面给出的式子实现「区间查询」。具体实现请看「类的实现代码」。

<br />

#### 时空复杂度

分析方法及结果均同 PURQ BIT。

<br />

#### 类的实现代码

```java
class RURQBIT { // 区间修改区间查询
    int[] diff, tree, helperTree; // nums为输入数组，diff为差分数组，tree是diff的区间和构成的逻辑树，helperTree是辅助逻辑树
    int n;
    public RURQBIT(int[] nums){
        this.n = nums.length - 1; // 有效元素个数
        this.diff = new int[n + 1];
        this.tree = new int[n + 1];
        this.helperTree = new int[n + 1];
        for(int i = 1; i <= n; i++){ // 求diff[]
            diff[i] = nums[i] - nums[i - 1];
        }
        for(int i = 1; i <= n; i++){ // 初始化tree[]和helperTree
             add(tree, i, diff[i]);
             add(helperTree, i, (i - 1) * diff[i]);
        }
    }
    // 查询区间和: 求nums[l]到nums[r]之和 preSum(r)-preSum(l-1)
    public int sum(int l, int r){
        int preSum0 = (l - 1) * query(tree, l - 1) - query(helperTree, l - 1);
        int preSum1 = r * query(tree, r) - query(helperTree, r);
        return preSum1 - preSum0;
    }
    public void rangeUpdate(int l, int r, int x){ // 区间修改
        add(tree, l, x);
        add(tree, r + 1, -x);
        add(helperTree, l, (l - 1) * x);
        add(helperTree, r + 1, r * (-x));
    }
    public int query(int[] thisTree, int k){ // 区间查询，求前缀和 preSum[k]
        int ans = 0;
        for(int i = k; i > 0; i -= lowbit(i)){ // 下一个左邻区间和结点下标为i -= lowbit(i)
            ans += thisTree[i];
        }
        return ans;
    }
    private void add(int[] thisTree, int k, int x){ // 为第k个结点thisTree[k]加上x
        for(int i = k; i <= n; i += lowbit(i)){ // 下一个区间和结点下标为i += lowbit(i)
            thisTree[i] += x; // 包含第k项的区间都加上x
        }
    }
    private int lowbit(int i){
        return i & -i;
    }
}
```

<br />

### 小结

关于「树状数组」，总结如下。

1. 基本的树状数组 (PURQ BIT) 以 $O(logn)$ 复杂度解决长度为 $n$ 的序列的 **单点修改** 及 **区间查询** 问题。
2. 我们从区间查询出发，思考如何利用类似倍增思想那样的做法来划分子区间，从而提高区间查询的效率。
3. 通过对 $nums$ 下标二进制形式的观察，找到了一种将输入序列划分为 $n$ 个子区间的方式。链接子区间及包含它的更大一点的子区间后，这些子区间构成一棵逻辑上的 **「二元索引树」** 。
4. 单点修改及区间查询的时间复杂度都与 $(n)_2$ 的位数相关，简单分析后可知它们都是时间为 $O(logn)$ 的操作。
5. 在 PURQ BIT 的基础上，引入 **差分数组** ，实现了 RUPQ BIT。
6. 在 RUPQ BIT 的基础上，根据 **算式推导** ，引入 **辅助树状数组** ，实现了 RURQ BIT。

总结不同方法的 PU/PQ/RU/RQ 操作的时间复杂度如下。

|                     | 单点修改    | 单点查询    | 区间修改    | 区间查询    |
| ------------------- | ----------- | ----------- | ----------- | ----------- |
| 普通数组            | $O(1)$      | $O(1)$      | $O(n)$      | $O(n)$      |
| 普通数组+前缀和数组 | $O(n)$      | $O(1)$      | $O(n)$      | $O(1)$      |
| 差分数组            | $O(1)$      | $O(n)$      | $O(1)$      | $O(n)$      |
| PURQ BIT            | ★ $O(logn)$ | $O(1)$      | $O(nlogn)$  | ★ $O(logn)$ |
| RUPQ BIT            |             | ★ $O(logn)$ | ★ $O(logn)$ |             |
| RURQ BIT            |             |             | ★ $O(logn)$ | ★ $O(logn)$ |

<br />

### 实战应用

[307. 区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/) 是基本树状数组 (PURQ BIT) 模版题，利用我们给出的代码可轻松解决，详细请看后表中相关题解。下面我们重点介绍巧用树状数组解决的一类常见问题 ── **区间内大小在 $[lower, upper]$ 范围内的元素数** 。

<br />

#### 区间内在给定取值范围内的元素数

首先从「逆序对」问题开始。求输入数组 $nums$ 的逆序对， **是树状数组的经典应用，更是一个「妙用」** ，我们指出，它是本节标题「区间内在给定取值范围内的元素数」的一个应用。以 [剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/) 为例，树状数组解法代码见 [题解](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/by-yukiyama-elnl/)，可以看到，其中的 BIT 类与我们在前面提供的 PURQ BIT 类的实现代码几乎相同。但我们注意到，在主方法 ($reversePairs$) 中，调用 $add$ 时，传入的增量 $x$ 是固定的 1。我们知道对于一般的 BIT，  $nums[k -1]$ 增加 $x$ 后，调用 $add(k,x)$ ，从第一个包含 $nums[k-1]$ 的区间的区间和开始，都增加 $x$ ，即从 $tree[k]+=x$ 开始，沿着父链更新所有包含 $nums[k-1]$ 的区间和。那么 $add(nums[i], 1)$ 是什么意思呢？

先看 $nums$ ，在执行 $add(nums[i],1)$ 之前，原大小为 $n$ 的输入数组 $nums$ 已由 **「离散化」** 操作变为了这样一个数组:

> 离散化后的 $nums$ 的所有元素的取值范围变为 $[1,n]$ (指松离散，另外还有紧离散，见后续)，且任意一对 $nums[i]$ 与 $nums[j]$ 的大小关系与原 $nums$ 中 $nums[i]$ 与 $nums[j]$ 的大小关系一致。

例如 $\{-2,6,-10\}$ 离散化后为 $\{2,3,1\}$  。

接着分析 $add(nums[i], 1)$ 的含义。这个操作是在遍历 $nums$ 过程中进行的，实际动作是对于 $nums[i]$ ，从 $tree[nums[i]]$ 开始，沿着父链上升，使得包含下标 $nums[i]$ 的代表更大区间的 $tree[x]+= 1$ 。$tree$ 的 $[1,n]$ 下标与 $nums$ 元素值的大小范围一致。 $add$ 的这一操作，相当于加入 $nums[i]$  时，告知 $nums$ 中在 $i$ 之后的比 $nums[i]$ 更大的数，在它前面新增了一个小于它的数。有点难以理解，没关系，结合下图，我们实际操作一下。

```
按照上述方式对 nums = {3,1,5,4,7,8,6,2} 中的元素依次执行 add(nums[i],1)
① add(3, 1)
② add(1, 1)
③ add(5, 1)
④ add(4, 1)
⑤ add(7, 1)
⑥ add(8, 1)
⑦ add(6, 1)
⑧ add(2, 1)
```

![image.png](https://pic.leetcode-cn.com/1658400428-eNpbln-image.png)

我们发现，每次加入一个 $nums[i]$ 之后，我们总是能够 **通过前缀和查询当前「小于等于」某个数的元素个数** 。例如，第 ④ 步过后，「小于等于」3 的个数，为 $query(3) = 2$ 。第 ⑥ 步过后「小于等于」7 的个数，为 $query(4)=5$ 。而当我们问介于 $[lower, upper]$ 之间的数有多少个时，实际上就是求 $query(upper) - query(lower - 1)$ 。 还需注意的是， $lower, upper$ 的取值范围要在 $[1,n]$ 之间，否则查询越界 (在 [327. 区间和的个数](https://leetcode.cn/problems/count-of-range-sum/) 中我们将看到查询范围超过 $[1,n]$ 时该如何处理)。



总之，我们将一个 $nums$ 离散化后，遍历它，先执行 $query(x)$ ，再执行 $add(nums[i], 1)$，这个操作即为每次添加 $nums[i]$ 前询问当前 $nums$ 中小于等于 $x$ 的元素个数。又因为我们总是先询问然后再插入第 $i$ 个元素，那么，在插入 $nums[i]$ 之前:

- 若执行 $query(upper)$ ，即为询问 $nums[0]$ 到 $nums[i-1]$ 中，小于等于 $upper$ 的个数；
- 若执行 $query(lower-1)$ ，即为询问 $nums[0]$ 到 $nums[i-1]$ 中，小于等于 $lower - 1$ 的个数； 
- 若执行 $query(upper)-query(lower-1)$ ，即为询问 $nums[0]$ 到 $nums[i-1]$ 中，取值范围为 $[lower,upper]$  的元素个数。

这就是本小节标题所谓的「区间内在给定取值范围内的元素数」 的含义，区间指 $[0,i-1]$ 区间，给定取值范围指 $[lower, upper]$ 。



现在分析「逆序对」问题就简单多了。由于离散化不改变任意一对元素的大小关系，因此 **对原数组求逆序数等同于对离散化后的数组求逆序数** 。我们要做的是询问 $nums[i]$ 的前面，有多少个大于它的数，刚好相当于在 $nums$ 中插入 $nums[i]$ 之前， 求 $i - query(nums[i])$ 。即 $[0,i-1]$ 范围内，有 $i$ 个数，其中「小于等于」$nums[i]$ 的有 $query(nums[i])$ 个，因此  $i - query(nums[i])$ 即为所求。



在完全理解了「遍历离散化后的 $nums$ ，在遍历过程中查询 $query(x)$ ，查询后通过 $add(nums[i],1)$ 插入 $nums[i]$」 这一操作的意义后，类似的题目如下:

-  [315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/) 题，与「逆序数」问题的区别仅在此题要求解「小于」，逆序数问题中涉及的是「小于等于」，只需要在「小于等于」版本的代码上做简单调整即可，详情见题解。
- [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/) 也是用树状数组求对于当前元素它之前的「小于等于」它的元素个数的问题，具体实现需结合二分查找，这是树状数组与其他方法相结合的一个好例子。
- [493. 翻转对](https://leetcode.cn/problems/reverse-pairs/) 。「逆序对」的变形题，$query(x)$ 中 $x$ 的范围超过了离散化后 $nums$ 的取值范围，这一点类似 327 题，可能被查询的数值要与原 $nums$ 中的数一起离散化。
- [327. 区间和的个数](https://leetcode.cn/problems/count-of-range-sum/) 。此题是更进阶的题目，不仅求解对象从 $nums$ 变成了 $preSums$ ，$lower, upper$ 的范围也不再是 $[1,n]$  ($n$ 是 $nums$ 的大小) 。这道题细节处理较多，详细内容请看题解。

关于这几题的详细题解和更多的树状数组题目，请参考后表。

<br />

#### 松离散与紧离散

在前面的分析中，我们提到了「离散化」的概念，即在题目只关心输入数组 $nums$ 元素的大小关系而不关心具体的值时，为了压缩空间，我们先将 $nums$ 离散化。常见的离散化方式有两种，它们都基于排序，但其中一种借助了 $set$ 去重，使得离散化后的有效数字更少，取值范围更小，我把这种方式称为「紧离散」；另一种则没有去重，因此离散化后的有效数字更多 (存在相同的数字)，取值范围也更大，我称之为「松离散」。以下是两种离散化方式的实现。

```java
// 松离散
private void discrete(int[] nums){ 
    int n = nums.length;
    int[] tmp = new int[n];
    System.arraycopy(nums, 0, tmp, 0, n);
    Arrays.sort(tmp);
    for (int i = 0; i < n; ++i) {
        nums[i] = Arrays.binarySearch(tmp, nums[i]) + 1;
    }
}

// 紧离散
private Map<Integer, Integer> discrete(int[] nums){ 
    Map<Integer, Integer> map = new HashMap<>();
    Set<Integer> set = new HashSet<>();
    for(int num : nums) set.add(num);
    List<Integer> list = new ArrayList<>(set);
    Collections.sort(list);
    int idx = 0;
    for(int num : list) map.put(num, ++idx);
    return map;
}
```

例如对于 $nums=\{2,4,4,6\}$ ，松离散得到 $nums=\{1,2,2,4\}$，离散化后的 $nums$ 大小与原来相同；紧离散得到 $map=\{(2,1),(4,2),(6,3)\}$ ， $key$ 为 $nums$ 中的元素，对应的 $value$ 为其离散化值，$value$  一定是从 1 开始的没有重复的连续正整数。两种方式离散化后虽然有效数字不同，取值范围也不同，但求解结果都是正确的 (读者可以思考一下为什么)。松离散无需哈希计算，通常速度更快，但有的题目可能更适合返回 $map$ 的紧离散 (例如 [327. 区间和的个数](https://leetcode.cn/problems/count-of-range-sum/) 和 [493. 翻转对](https://leetcode.cn/problems/reverse-pairs/) )。

<br />

#### 题目

| 题目                                                         | 难度 | 题解                                                         |
| ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |
| [307. 区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/)<br />※ PURQBIT模版题 | 中等 | [题解](https://leetcode.cn/problems/range-sum-query-mutable/solution/yukiyama-by-yukiyama-euo5/) |
| [剑指 Offer 51. 数组中的逆序对](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/) | 困难 | [题解](https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/solution/by-yukiyama-elnl/) |
| [315. 计算右侧小于当前元素的个数](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/) | 困难 | [题解](https://leetcode.cn/problems/count-of-smaller-numbers-after-self/solution/yukiyama-by-yukiyama-nqas/) |
| [406. 根据身高重建队列](https://leetcode.cn/problems/queue-reconstruction-by-height/) | 中等 | [题解](https://leetcode.cn/problems/queue-reconstruction-by-height/solution/yukiyama-shu-zhuang-shu-zu-er-fen-by-yuk-1ovu/) |
| [493. 翻转对](https://leetcode.cn/problems/reverse-pairs/)   | 困难 | [题解](https://leetcode.cn/problems/reverse-pairs/solution/by-yukiyama-ljyp/) |
| [327. 区间和的个数](https://leetcode.cn/problems/count-of-range-sum/) | 困难 | [题解](https://leetcode.cn/problems/count-of-range-sum/solution/by-yukiyama-e9on/) |
| [P3368 【模板】树状数组 2](https://www.luogu.com.cn/problem/P3368)<br />※ 给出的 RUPQBIT 类代码调整为 long 类型后可解决，但有若干用例TLE |      | 模版题                                                       |
| [132. 树状数组 3](https://loj.ac/p/132)<br />※ 给出的 RURQBIT 类代码调整为 long 类型后可解决，但有若干用例TLE |      | 模版题                                                       |

<br />

## 线段树

我们已经知道，针对序列上的「区间操作」，相比普通数组和前缀和数组，基本树状数组 (PURQ BIT) 对「单点修改」及「区间查询」这两种操作实现了平衡，即均为 $O(logn)$ 时间复杂度。借助差分数组，从 PURQ BIT 发展而来的 RUPQ BIT 和 RURQ BIT 还可以实现 $O(logn)$ 复杂度区间修改操作，但需要针对不同的需要选择不同版本的树状数组。另外，当我们需要将区间内元素修改为同一元素时，或者求给定区间的区间最大/最小值时，三种树状数组均不能以 $O(logn)$ 时间复杂度完成该操作。

对于这些需求，有一种数据结构能够以 $O(logn)$ 时间复杂度完成，它就是我们马上要学习的大名鼎鼎的 **「线段树」** 。

[线段树 (Segment Tree)](https://en.wikipedia.org/wiki/Segment_tree): 线段树是一种用以支持序列区间操作的数据结构，相比基本树状数组，能够支持的操作种类更多，因此对一般的序列区间问题更具 **普适性** 。



在后续内容中，我们先通过 **「完全二叉树下标性质」** 和 **「分治算法」** 来理解基本线段树的工作原理。在掌握了支持「单点修改」和「区间查询」的基本线段树后，引入**「懒惰标记」** 和 **「延迟修改」** 的概念，用以实现 「区间修改」。在给出带懒惰标记的线段树实现后，我们马上尝试解决  [699. 掉落的方块](https://leetcode.cn/problems/falling-squares/) ，为解决此题需借用在「树状数组」中介绍过的 **「离散化」** 方法。接着尝试解决  [715. Range 模块](https://leetcode.cn/problems/range-module/) ，并发现该题具有「[强制在线](https://en.wikipedia.org/wiki/Online_algorithm)」的特点，由于无法离散化，这要求我们实现能够 **「动态开点」**  (动态创建结点) 的线段树。根据是否可以提前估计树的大小，我们将分别介绍  **「结点数组法动态开点线段树」** 以及 **「结点指针 (引用) 法动态开点线段树」** ，在给出它们的完整的类代码后，演示如何将其用于解决 699 题以及 715 题。

在讲解过程中，我会给出八种线段树的完整类代码，基本能够覆盖力扣上的常见线段树题目。

> 线段树由 Jon Bentley 于1977年发明。
>
> The segment tree was invented by [Jon Bentley](https://en.wikipedia.org/wiki/Jon_Bentley_(computer_scientist)) in 1977; in "Solutions to Klee’s rectangle problems".[[7\]](https://en.wikipedia.org/wiki/Segment_tree#cite_note-Schwarzkopf4-7)
>
> 
>
> 作者的「线段树」知识，最初学自 OI wiki [线段树](https://oi-wiki.org/ds/seg/) 。

<br />

### 基本线段树

如果我们只要求线段树像基本树状数组 (PURQ BIT) 那样，只需支持「单点修改」和「区间查询」，那么我们将得到最基本的线段树。

在「树状数组」中我们从如何提高区间查询的效率这一问题入手，提出了将原数组 $nums$ 分成若干子区间的想法，且这些子区间构成一棵逻辑树，通过树的结构实现 $O(logn)$ 的复杂度。树状数组毕竟太具技巧性，我们会想，除了树状数组利用 $lowbit$ 那样巧妙构造树的方法，有没有 **更一般** 的方法能够将 $nums$ 划分为多个子区间，这些子区间作为结点构成一棵树，树上的结点相比树状数组 **更直观** 地组成任意区间 (直接结合而非前缀区间作差)，且仍能通过下标的某些性质来操作结点呢 (主要是定位到需要的区间和结点) ？

根据树结点下标性质来操作结点这一要求中，我们嗅到了 **「完全二叉树」** 的味道。在完全二叉树中，结点 $i$ (根结点为结点 1) 的左子结点下标为 $2*i$ ，右子结点下标为 $2*i+1$ 。顺着这个想法，我们尝试将「线段树」构造为一棵「完全二叉树」。

<br />

#### 线段树的形态

下面是我们将「线段树」构造为一棵「完全二叉树」的思考过程。

- 首先，既然是完全二叉树，那么这棵线段树可以与一个数组对应，数组的一个元素对应一个树的一个结点。树的一个结点代表某个区间的区间和，我们用 $tree[]$ 数组表达这棵线段树，其大小暂时未知。

- 更大的区间总是由更小区间构成，因此代表 $nums$ 中单个元素的结点 $tree[x]$  **应当在树的最底层** ，即线段树的每一个叶子结点都与 $nums$ 中的一个值对应 $tree[x] = nums[i]$ ，且是从左到右对应的。
- 更大的区间是从叶子结点开始向上构成的，例如代表 $nums[0]$ 的叶子结点是一个左子结点，代表 $nums[1]$ 的叶子结点是一个右子结点，那么他们的父节点即为代表区间 $[0,1]$ 的结点。
- 查询区间 $[l,r]$ 的区间和，总是从上到下查询。从根结点开始，为了知道指定区间包含哪些区间结点，需要将 $l,r$ 与结点的标号联系起来，也就是将 $nums$ 的下标与 **形如完全二叉树的线段树的结点标号** 相联系，这个「完全二叉树结点下标性质」我们很熟悉，将数组 $nums$ 看作完全二叉树时，树的结点代表 $nums$ 中的某个值， 而在线段树中，树的结点代表 $nums$ 中的某段区间和。

在熟知完全二叉树下标性质的基础上，上述分析是简单的。$tree[i]$ 表示标号为 $i$ 的结点所代表的区间的区间和。令根结点标号为 1。根结点 $tree[1]$ 代表整个 $nums$ 所有元素之和。很自然地，根结点的左右子结点应当代表左右两半区间的区间和，即 $tree[2]$ 表示区间 $[0, \frac{n-1}{2}]$ 的区间和，$tree[3]$ 表示区间 $[\frac{n-1}{2}+1, n-1]$ 的区间和，依次向下， **结点标号总是与该结点代表的区间一一对应** 。

> 代表区间 $[l,r]$ 的结点 $tree[i]$ ，其左子结点 $tree[2*i]$ 表示区间 $[l,\frac{l+r}{2}]$ 的区间和；其右子结点 $tree[2*i+1]$ 表示区间 $[\frac{l+r}{2}+1,r]$ 的区间和。



于是我们很容易得到一棵线段树的一般表示，下图表示大小为 15 的 $nums=\{a0,a1,...,a14\}$ 对应的线段树。可以看到，对于任意区间 $[l,r], l,r∈[0,n-1]$ ，我们都可以通过从 $l$ 到 $r$ 的若干个子区间来表达，这一点是线段树与树状数组的显著区别。 

![image.png](https://pic.leetcode-cn.com/1658564316-ptpqfb-image.png)

了解了线段树的区间划分、结点所代表的具体区间与结点下标的关系后，接下来我们给出基本线段树的「初始化」、「单点修改」以及「区间查询」实现。在这之前先简单分析线段树的大小。

<br />

#### 线段树的大小

对于长度为 $n$ 的输入数组 $nums$ ，初始化它所对应的线段树前，我们需要知道 $tree[]$ 的大小。$n$ 对应的是线段树叶子结点数，我们设总结点数为 $m$ ，可以 **根据线段树为一棵完全二叉树的特点来寻找 $n$ 与 $m$ 的关系** 。$m$ 与 $n$ 的关系证明见 [oi-wiki 线段树](https://oi-wiki.org/ds/seg/) ，作者未完全看懂最大有 $m=4*n-5$ 的证明过程。如果读者能提供较严格的数学证明，盼赐教。

总之，在实际使用时，我们总是不精确地令 $m=4*n$ 。

<br />

#### 初始化

如果读者熟悉归并排序和快速排序这类 **分治算法** 的「对原问题域递归地划分为左右子问题域」的操作，那么线段树的主要方法都将是简单的。我们直接给出如下线段树类 $SegmentTree$ 的构造器代码。

```java
class SegmentTree {
    int[] nums, tree;
    int n;
    public SegmentTree(int[] nums){
        this.nums = nums;
        this.n = nums.length;
        this.tree = new int[4 * n]; // 线段树结点数不超过 4*n
        build(0, n - 1, 1);
    }
    private void build(int s, int t, int i){ // 构建线段树(tree数组), i: 当前区间结点下标
        if(s == t) { // s: start,nums当前区间左界，t: terminal,nums当前结点区间右界
            tree[i] = nums[s];
            return;
        }
        int c = s + (t - s) / 2;
        build(s, c, i * 2);
        build(c + 1, t, i * 2 + 1);
        tree[i] = tree[i * 2] + tree[i * 2 + 1];
    }
}
```

构造器通过 `build(0, n - 1, 1)` 完成线段树的构建。在 $build$ 中，自根结点往下，按照我们在「线段树的形态」中所说的那样，递归地将 $nums$ 分为左右两半，直到叶子结点，每次递归， **区间和结点的下标总是和该区间的左右界一起被传入** 。

根据 `s == t` 判断到达叶子结点后，令 `tree[i] = nums[s]` ，使得每个叶子结点从左到右对应 $nums$ 的每个元素值。在回溯过程中通过 `tree[i] = tree[i * 2] + tree[i * 2 + 1]`  自底向上地初始化所有区间结点的区间和。这行语句在线段树的实现中较常用，我们可以将它封装为一个辅助方法 $pushUp$ 。

```java
// 更新 tree[i]
private void pushUp(int i){ 
    tree[i] = tree[i * 2] + tree[i * 2 + 1];
}
```

后面我们将看到，线段树的所有主要方法的执行过程，都是类似 **二叉树后序 $dfs$ 的递归过程** ，因此我们会感到线段树不同方法的写法十分类似，也很容易理解。

<br />

#### 单点修改

单点修改有两种，**增量式修改，即加上某值** (记为 $add$ 方法) $nums[i]+=x$  或 **覆盖式修改，即改为某值** (记为 $update$ 方法) $nums[i]=x$。如下。

```java
// 单点修改(驱动): nums[i] += x
public void add(int i, int x){ 
    add(i, x, 0, n - 1, 1);
}
// 单点修改(驱动): nums[i] = x
public void update(int i, int x){
    update(i, x, 0, n - 1, 1);
}
// 单点修改: nums[idx] += x
private void add(int idx, int x, int s, int t, int i){
    if(s == t) {
        tree[i] += x; // 增量更新
        return;
    }
    int c = s + (t - s) / 2;
    if(idx <= c) add(idx, x, s, c, i * 2);
    else add(idx, x, c + 1, t, i * 2 + 1);
    pushUp(i);
}
// 单点修改: nums[idx] = x
private void update(int idx, int x, int s, int t, int i){
    if(s == t) {
        tree[i] = x; // 覆盖更新
        return;
    }
    int c = s + (t - s) / 2;
    if(idx <= c) update(idx, x, s, c, i * 2);
    else update(idx, x, c + 1, t, i * 2 + 1);
    pushUp(i);
}
```

$add$ 和 $update$ 均采用上述写法时，可以不用维护 $nums$ ，由于 $nums$ 不可用，单点查询可实现如下。

```java
// 单点查询 (驱动): 查询 nums[i]
public int query(int i){ 
    return query(i, 0, n - 1, 1);
}
// 单点查询 (具体): 查询 nums[i]，尾递归
private int query(int idx, int s, int t, int i){
    if(s == t) return tree[i];
    int c = s + (t - s) / 2;
    if(idx <= c) return query(idx, s, c, i * 2);
    else return query(idx, c + 1, t, i * 2 + 1);
}
```

 当然我们也可以实时地维护 $nums$ ，那么 $add$ 写法不变， $update$ 可借助 $add$ 实现。由于 $nums[i]$ 是实时维护的，单点查询时直接返回 $nums[i]$ 即可。

```java
// 单点修改(驱动): nums[i] = x
public void update(int i, int x){ 
    add(i, x - nums[i], 0, n - 1, 1);
    nums[i] = x; // 实时维护 nums[i]
}
public int query(int i){ // 单点查询: 查询 nums[i]
    return nums[i];
}
```



实际上，由于单点查询和单点修改都可以视作区间长度为 1 的区间查询和区间修改。上述方法也可以由区间查询和区间修改代替。

<br />

#### 区间查询

区间查询 (求和) 也是简单的。与单点操作不同的是，区间和需要累积，因此 `if(l <= c)` 与 `if(r > c)` 是并列关系。

```java
// 区间查询(驱动): nums[l]~nums[r]之和
public int sum(int l, int r){ 
    return sum(l, r, 0, n - 1, 1);
}
// 区间查询: nums[l]~nums[r]之和
private int sum(int l, int r, int s, int t, int i){
    if(l <= s && t <= r) return tree[i]; // 当前结点区间在所求范围之间
    int c = s + (t - s) / 2, sum = 0;
    if(l <= c) sum += sum(l, r, s, c, i * 2); // 递归累加目标区间落在c左侧(含c)的区间和
    if(r > c) sum += sum(l, r, c + 1, t, i * 2 + 1); // 递归累加目标区间落在c右侧的区间和
    return sum;
}
```

也可以查询区间最值，以区间最小值为例。

```java
// 区间查询 (驱动): 查询[l,r]中的最小值
public int min(int l, int r){ 
    return min(l, r, 0, n - 1, 1);
}
// 区间查询: 查询[l,r]中的最小值
private int min(int l, int r, int s, int t, int i){
    if(s == t) return tree[i]; // 叶子结点
    int c = s + (t - s) / 2, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;
    if(l <= c) lmin = min(l, r, s, c, i * 2);
    if(r > c) rmin = min(l, r, c + 1, t, i * 2 + 1);
    return Math.min(lmin, rmin);
}
```

<br />

#### 类的实现代码

将前述方法的实现代码组合起来即可 (实时维护 $nums$ 或不维护 $nums$ 两个版本)，见后。



不过，我们在一开始说过线段树能很好地支持「区间修改」操作，为什么还没提供相关方法就在这里给出类的代码呢？这是因为，与树状数组 (RUPQ/RURQ BIT) 区间修改时只需要在 $add$ 中沿着父链修改 $O(logn)$ 次不同， **线段树修改一段区间涉及到一个或多个子树空间的修改** 。例如若修改整个 $nums$ ，那么就要从根结点 $dfs$ 整棵树，修改涉及所有结点，时间复杂度为 $O(n)$ 。对于随机区间来说，平均时间复杂度为 $O(n)$ ，且由于所有区间结点的数量大于 $n$ ，这样的操作甚至劣于直接遍历 $nums$ 逐个修改。

为了解决这个问题，我们不是直接 $dfs$ 修改，而是通过一种称为 **「懒惰标记」** 的技巧，使子树中的修改操作 **延迟** 到后续修改和查询操作中，此技巧使得区间修改的时间复杂度仍为 $O(logn)$ 。



为了更稳固地学习后续内容，建议读者先基于目前为止讲解的内容尝试解决 [307. 区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/) ，代码可参考「实战应用」一节给出的题解。

<br />

##### 实时维护 $nums$ 的版本

```java
/**
 * 基本线段树1 (无懒标记，无区间修改方法，实时维护 nums[i])
 * 支持：单点修改 / 单点查询 / 区间查询
 */
class SegmentTreeBasic1 {
    int[] nums, tree;
    int n;
    public SegmentTreeBasic1(int[] nums){
        this.nums = nums;
        this.n = nums.length;
        this.tree = new int[4 * n];
        build(0, n - 1, 1);
    }
    public void add(int i, int x){ // 单点修改(驱动): nums[i] += x
        add(i, x, 0, n - 1, 1);
    }
    public void update(int i, int x){ // 单点修改(驱动): nums[i] = x
        add(i, x - nums[i], 0, n - 1, 1);
        nums[i] = x; // 实时维护 nums[i]
    }
    public int query(int i){ // 单点查询: 查询 nums[i]
        return nums[i];
    }
    public int sum(int l, int r){ // 区间查询(驱动): nums[l]~nums[r]之和
        return sum(l, r, 0, n - 1, 1);
    }
    public int min(int l, int r){ // 区间查询 (驱动): 查询[l,r]中的最小值
        return min(l, r, 0, n - 1, 1);
    }
    public int max(int l, int r){ // 区间查询 (驱动): 查询[l,r]中的最大值
        return max(l, r, 0, n - 1, 1);
    }
    // 单点修改: nums[idx] += x
    private void add(int idx, int x, int s, int t, int i){
        if(s == t) {
            tree[i] += x; // 增量更新
            return;
        }
        int c = s + (t - s) / 2;
        if(idx <= c) add(idx, x, s, c, i * 2);
        else add(idx, x, c + 1, t, i * 2 + 1);
        pushUp(i);
    }
    // 区间查询: nums[l]~nums[r]之和
    private int sum(int l, int r, int s, int t, int i){
        if(l <= s && t <= r) return tree[i]; // 当前结点区间在所求范围之间
        int c = s + (t - s) / 2, sum = 0;
        if(l <= c) sum += sum(l, r, s, c, i * 2); // 递归累加目标区间落在c左侧(含c)的区间和
        if(r > c) sum += sum(l, r, c + 1, t, i * 2 + 1); // 递归累加目标区间落在c右侧的区间和
        return sum;
    }
    // 区间查询: 查询[l,r]中的最小值
    private int min(int l, int r, int s, int t, int i){
        if(s == t) return tree[i]; // 叶子结点
        int c = s + (t - s) / 2, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;
        if(l <= c) lmin = min(l, r, s, c, i * 2);
        if(r > c) rmin = min(l, r, c + 1, t, i * 2 + 1);
        return Math.min(lmin, rmin);
    }
    // 区间查询: 查询[l,r]中的最大值
    private int max(int l, int r, int s, int t, int i){
        if(s == t) return tree[i];
        int c = s + (t - s) / 2, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;
        if(l <= c) lmax = max(l, r, s, c, i * 2);
        if(r > c) rmax = max(l, r, c + 1, t, i * 2 + 1);
        return Math.max(lmax, rmax);
    }
    // 构建线段树(tree数组)
    private void build(int s, int t, int i){
        if(s == t) { // s: start,nums当前区间起点下标，t: terminal,nums当前结点区间末尾下标
            tree[i] = nums[s];
            return;
        }
        int c = s + (t - s) / 2;
        build(s, c, i * 2);
        build(c + 1, t, i * 2 + 1);
        pushUp(i);
    }
    // pushup: 更新 tree[i]
    private void pushUp(int i){
        tree[i] = tree[i * 2] + tree[i * 2 + 1];
    }
}
```

<br />

##### 不维护 $nums$ 的版本

```java
/**
 * 基本线段树2 (无懒标记，无区间修改方法，不维护 nums[i])
 * 支持：单点修改 / 单点查询 / 区间查询
 */
class SegmentTreeBasic2 {
    int[] nums, tree;
    int n;
    public SegmentTreeBasic2(int[] nums){
        this.nums = nums;
        this.n = nums.length;
        this.tree = new int[4 * n];
        build(0, n - 1, 1);
    }
    public void add(int i, int x){ // 单点修改(驱动): nums[i] += x
        add(i, x, 0, n - 1, 1);
    }
    public void update(int i, int x){// 单点修改(驱动): nums[i] = x
        update(i, x, 0, n - 1, 1);
    }
    public int query(int i){ // 单点查询 (驱动): 查询 nums[i]
        return query(i, 0, n - 1, 1);
    }
    public int sum(int l, int r){ // 区间查询(驱动): nums[l]~nums[r]之和
        return sum(l, r, 0, n - 1, 1);
    }
    public int min(int l, int r){ // 区间查询 (驱动): 查询[l,r]中的最小值
        return min(l, r, 0, n - 1, 1);
    }
    public int max(int l, int r){ // 区间查询 (驱动): 查询[l,r]中的最大值
        return max(l, r, 0, n - 1, 1);
    }
    // 单点查询 (具体): 查询 nums[i]，尾递归
    private int query(int idx, int s, int t, int i){
        if(s == t) return tree[i];
        int c = s + (t - s) / 2;
        if(idx <= c) return query(idx, s, c, i * 2);
        else return query(idx, c + 1, t, i * 2 + 1);
    }
    // 单点修改: nums[idx] += x
    private void add(int idx, int x, int s, int t, int i){
        if(s == t) {
            tree[i] += x; // 增量更新
            return;
        }
        int c = s + (t - s) / 2;
        if(idx <= c) add(idx, x, s, c, i * 2);
        else add(idx, x, c + 1, t, i * 2 + 1);
        pushUp(i);
    }
    // 单点修改: nums[idx] = x
    private void update(int idx, int x, int s, int t, int i){
        if(s == t) {
            tree[i] = x; // 覆盖更新
            return;
        }
        int c = s + (t - s) / 2;
        if(idx <= c) update(idx, x, s, c, i * 2);
        else update(idx, x, c + 1, t, i * 2 + 1);
        pushUp(i);
    }
    // 区间查询: nums[l]~nums[r]之和
    private int sum(int l, int r, int s, int t, int i){
        if(l <= s && t <= r) return tree[i]; // 当前结点区间在所求范围之间
        int c = s + (t - s) / 2, sum = 0;
        if(l <= c) sum += sum(l, r, s, c, i * 2); // 递归累加目标区间落在c左侧(含c)的区间和
        if(r > c) sum += sum(l, r, c + 1, t, i * 2 + 1); // 递归累加目标区间落在c右侧的区间和
        return sum;
    }
    // 区间查询: 查询[l,r]中的最小值
    private int min(int l, int r, int s, int t, int i){
        if(s == t) return tree[i]; // 叶子结点
        int c = s + (t - s) / 2, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;
        if(l <= c) lmin = min(l, r, s, c, i * 2);
        if(r > c) rmin = min(l, r, c + 1, t, i * 2 + 1);
        return Math.min(lmin, rmin);
    }
    // 区间查询: 查询[l,r]中的最大值
    private int max(int l, int r, int s, int t, int i){
        if(s == t) return tree[i];
        int c = s + (t - s) / 2, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;
        if(l <= c) lmax = max(l, r, s, c, i * 2);
        if(r > c) rmax = max(l, r, c + 1, t, i * 2 + 1);
        return Math.max(lmax, rmax);
    }
    // 构建线段树(tree数组)
    private void build(int s, int t, int i){
        if(s == t) { // s: start,nums当前区间起点下标，t: terminal,nums当前结点区间末尾下标
            tree[i] = nums[s];
            return;
        }
        int c = s + (t - s) / 2;
        build(s, c, i * 2);
        build(c + 1, t, i * 2 + 1);
        pushUp(i);
    }
    // pushup: 更新 tree[i]
    private void pushUp(int i){
        tree[i] = tree[i * 2] + tree[i * 2 + 1];
    }
}
```

<br />

### 懒惰标记

回顾一下前述 $sum$ 方法，给定区间 $[l,r]$ ，当方法递归到一个完全位于 $[l,r]$ 的 $[s,t]$ 区间 (即 `l <= s && t <= r` ) 时，我们直接累积该区间的区间和。可见，区间查询时，只要当前区间完全处于查询区间之内，我们就不需要知道此区间以下的区间的信息。这指导我们对于区间修改操作，递归到一个包含于修改区间之内的区间时，似乎可以 **只修改代表该区间的区间和** ，而无需继续深入修改它的子区间的区间和。下面分析这一做法。

因为递归方法总是同时传入结点下标 $i$ 及该结点代表区间的左右界 $[s,t]$ ，因此可以通过 `if(l <= s && t <= r)` 来判断当前结点代表的区间是否完全包含于 $[l,r]$ 的区间内，若包含，由于知道左右界信息，因此可以直接更新 $tree[i]$ 。此后查询包含 $[s,t]$ 的区间 $[l,r]$ ，$dfs$ 递进到代表 $[s,t]$ 区间的结点 $tree[i]$ 时，$tree[i]$ 总是正确的。但如果 $[l,r]$ 值只覆盖了一部分 $[s,t]$ ，就必须从 $tree[i]$ 结点继续向下访问 $[s,t]$ 的子区间，而先前我们并没有将区间修改进行到子区间，因此查询将得不到正确结果。

解决办法是在前一次修改 $[s,t]$ 的 $tree[i]$ 值时，另外使用一个与 $tree[]$ 等大的 $lazy[]$ 数组标记此时的修改 (修改 $lazy[i]$ )，以便于下次查询到 $tree[i]$ 时 **将这个修改传递给子区间** 。我们将这个动作称为 **「延迟修改」** ，将这个标记形象地称作 **「懒惰标记」** 。有点不好理解？没关系，我们马上结合示意图与代码来跟踪相关操作。

<br />

#### 区间修改 (增量式)

我们先分析 **为区间内所有元素增加同一值的增量式「区间修改」** 操作。

如下图，执行 `add(6, 11, 2)` 为区间 $[6,11]$ 的每个元素都加上 2 。 递归调用到 $tree[6]$ 以及 $tree[11]$ 时 (暂时忽略递进到此处之前的操作)，会分别执行 `tree[6] += (11 - 8 + 1) * 2` 和 `tree[11] += (7 - 6 + 1) * 2` 。同时，增量 2 也会被 $lazy[6]$ 和 $lazy[11]$ 记录。由于 **标记可能还记录了前面的修改，而修改是增量式的，因此需累加** 。

![image.png](https://pic.leetcode-cn.com/1658637495-uxFmaD-image.png)



接着，我们查询 $[6,9]$ 的区间和 ( $sum(6,9)$ )，递进访问到 $tree[6]$ 结点时，要将懒标记记录的修改量 $lazy[6]$ 传递给 $tree[12]$ 和 $tree[13]$ 。同样地，访问到 $tree[11]$ 结点时，要将懒标记记录的修改量 $lazy[11]$ 传递给 $tree[22]$ 和 $tree[23]$ 。 **「推送」** 指的是通过 $pushDown$ 方法完成 **当前区间以及它的两个子结点区间的区间和以及懒标记的更新** 。

![image.png](https://pic.leetcode-cn.com/1658588970-kOwQAr-image.png)



现在我们很容易理解下面的实现代码。`private void add` 方法中，当递进到所代表的区间完全包含于 $[l,r]$ 内的 $tree[i]$ 结点时 (代表区间 $[s,t]$ )，我们执行 `tree[i] += (t - s + 1) * x` 语句更新 $tree[i]$ ，接着执行 `if(s != t) lazy[i] += x`  后返回。懒标记更新前的判断使得 **叶子结点不会被标记** ，因为 **叶子结点之下不再有需要推送标记的结点** 。当然也可以不用判断，因为无论是查询还是修改，到达叶子结点时一定会进入方法开始的 $if$ 语句后通过 $return$ 返回，叶子结点没有向下推送的机会。

`if(lazy[i] != 0) pushDown(s, c, t, i)` 表示在递归进入左右子结点前，检查当前 $tree[i]$ 顶点值是否要向下推送标记，`lazy[i] != 0` 说明当前 $tree[i]$ 有 **尚未推送的修改** ，需要在这个时候推送到下一层，否则递归进入左右子结点时，左右子结点的区间和是旧的。

$pushDown$ 方法传入 $s,c,t,i$ ，用于更新 $tree[i]$ 的左子结点区间和 $tree[2*i]$ 、右子结点区间和 $tree[2*i+1]$  以及它们的懒标记。更新结束后 $tree[i]$ 结点的「推送修改量」的任务就完成了，需要将其懒标记设置为 0 ，即 `lazy[i] = 0` ，否则下次修改或查询再经过 $tree[i]$ 时，会重复推送。

$add$ 方法的最后一行调用 $pushUp$ 方法，这是递归的 **「后序」** 动作，回溯过程中自底向上更新递进路径上的 $tree[i]$ 。 

```java
// 区间修改(驱动): [l,r]区间所有元素加上x
public void add(int l, int r, int x){ 
    add(l, r, x, 0, n - 1, 1);
}
// 区间修改: 增量式 [l,r] 区间所有元素加上x
private void add(int l, int r, int x, int s, int t, int i){ 
    if(l <= s && t <= r){ // 当前结点代表的区间在所求区间之内
        tree[i] += (t - s + 1) * x; // 结点i的区间和加上t-s+1个x
        if(s != t) lazy[i] += x; // 结点i不是叶子结点，懒标记值加上x
        return;
    }
    int c = s + (t - s) / 2;
    if(lazy[i] != 0) pushDown(s, c, t, i); // 当前结点懒惰标记不为0，推送标记
    if(l <= c) add(l, r, x, s, c, i * 2);
    if(r > c) add(l, r, x, c + 1, t, i * 2 + 1);
    pushUp(i); // 后序动作，自底向上更新结点区间和 tree[i]
}
// 更新结点i左右子结点的区间和以及懒惰标记值，最后重置结点i的懒惰标记值
private void pushDown(int s, int c, int t, int i){ 
    tree[i * 2] += (c - s + 1) * lazy[i]; // 更新其左子结点的区间和
    lazy[i * 2] += lazy[i]; // 传递懒标记(增量标记)
    tree[i * 2 + 1] += (t - c) * lazy[i];
    lazy[i * 2 + 1] += lazy[i];
    lazy[i] = 0; // 重置当前结点懒惰标记值（增量标记置0）
}
// 更新 tree[i]
private void pushUp(int i){ 
    tree[i] = tree[i * 2] + tree[i * 2 + 1];
}
```

<br />

#### 区间修改 (覆盖式)

与单点覆盖式修改方法可以通过调用单点增量式修改方法来实现不同，由于 **涉及多个值的修改** ，区间覆盖式修改不能通过调用区间增量式方法来实现。且覆盖式修改可能将 $nums$ 的原元素值改为 0，因此不能再以 `lazy[i] != 0` 来作为推送标记的标志。我们可以创建一个新的 `boolean updated[]` 数组来记录结点 $i$ 当前的修改状态，若 `updated[i] == true` 说明结点 $i$ 的 **覆盖式修改未推送** 。需注意的是， $pushDown$ 方法也需要若干调整。如下是区间覆盖式修改的相关代码实现，与增量式区间修改代码的区别仅仅是用 `if(updated[i])` 代替了 `if(lazy[i] != 0)` ，以及将「增量运算」的 `+=` 改为「覆盖赋值」 `=` ，以及相应的 $updated[i]$ 的设置和更新。

如果我们能确定覆盖式区间修改不会将元素值改为 0 的话，那 $updated[]$ 数组不是必须的，仍可用 $lazy[i]$ 是否为 0 作为判断条件，这种情况下增量式与覆盖式的代码将十分相似，几乎只有 `+=` 和 `=` 的区别。例如 [699. 掉落的方块](https://leetcode.cn/problems/falling-squares/) 一题，需要实现覆盖式区间修改，但题目保证了修改值不会是 0 ，实现代码就不需要另外使用 `boolean updated[]` ，具体请看「实战应用」中该题 [题解](https://leetcode.cn/problems/falling-squares/solution/-by-yukiyama-lxtu/)。

```java
// 区间修改(驱动): 覆盖式 [l,r] 区间所有元素改为x
public void update(int l, int r, int x){ 
    update(l, r, x, 0, n - 1, 1);
}
// 区间修改: 覆盖式 [l,r] 区间所有元素改为x
private void update(int l, int r, int x, int s, int t, int i){ 
    if(l <= s && t <= r){ // 当前结点代表的区间在所求区间之内
        tree[i] = (t - s + 1) * x; // 结点i的区间和等于t-s+1个x
        if(s != t) { // 结点i不是叶子结点
            lazy[i] = x; // 懒标记值等于x
            updated[i] = true; // updated[i]置于为为true
        }
        return;
    }
    int c = s + (t - s) / 2;
    if(updated[i]) pushDown(s, c, t, i); // 当前结点updated为true，推送标记
    if(l <= c) update(l, r, x, s, c, i * 2);
    if(r > c) update(l, r, x, c + 1, t, i * 2 + 1);
    pushUp(i); // 后序动作，自底向上更新结点区间和 tree[i]
}
// 更新结点i左右子结点的区间和/懒惰标记值/updated[i]，最后重置懒惰标记值/updated[i]
private void pushDown(int s, int c, int t, int i){ 
    tree[i * 2] = (c - s + 1) * lazy[i]; // 更新其左子结点的区间和
    lazy[i * 2] = lazy[i]; // 传递懒标记(覆盖式标记)
    updated[i * 2] = true;
    tree[i * 2 + 1] = (t - c) * lazy[i];
    lazy[i * 2 + 1] = lazy[i];
    updated[i * 2 + 1] = true;
    lazy[i] = 0; // 重置当前结点懒惰标记值（覆盖式标记置0）
    updated[i] = false; // 重置当前结点updated[i]为false
}
```

<br />

#### 类的实现代码

##### 增量式区间修改版

```java
/**
 * 静态线段树 (带懒标记，增量式区间修改)
 * 支持：单点修改 / 单点查询 / 区间求和 / 增量式区间修改
 */
class SegmentTreeAdd{
    int[] nums, tree, lazy;
    int n;
    public SegmentTreeAdd(int[] nums){
        this.nums = nums;
        this.n = nums.length;
        this.tree = new int[4 * n];
        this.lazy = new int[4 * n];
        build(0, n - 1, 1);
    }
    public void add(int i, int x){ // 单点修改(驱动): 增量式 nums[i] += x
        add(i, x, 0, n - 1, 1);
    }
    public void update(int i, int x){ // 单点修改(驱动): 覆盖式 nums[i] = x
        update(i, x, 0, n - 1, 1);
    }
    public int query(int i){ // 单点查询 (驱动): 查询 nums[i]
        return query(i, 0, n - 1, 1);
    }
    public void add(int l, int r, int x){ // 区间修改(驱动): 增量式 [l,r] 区间所有元素加上x
        add(l, r, x, 0, n - 1, 1);
    }
    public int sum(int l, int r){ // 区间查询(驱动): nums[l]~nums[r]之和
        return sum(l, r, 0, n - 1, 1);
    }
    public int min(int l, int r){ // 区间查询 (驱动): 查询[l,r]中的最小值
        return min(l, r, 0, n - 1, 1);
    }
    public int max(int l, int r){ // 区间查询 (驱动): 查询[l,r]中的最小值
        return max(l, r, 0, n - 1, 1);
    }
    // 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。
    private void add(int idx, int x, int s, int t, int i){
        if(s == t) {
            tree[i] += x; // 增量更新
            return;
        }
        int c = s + (t - s) / 2;
        if(lazy[i] != 0) pushDown(s, c, t, i); // 是否推送标记
        if(idx <= c) add(idx, x, s, c, i * 2);
        else add(idx, x, c + 1, t, i * 2 + 1);
        pushUp(i); // 后序动作，自底向上更新结点区间和 tree[i]
    }
    // 单点修改: 覆盖式 令nums[idx] = x。修改叶子结点，无关标记。
    private void update(int idx, int x, int s, int t, int i){
        if(s == t) {
            tree[i] = x; // 覆盖更新
            return;
        }
        int c = s + (t - s) / 2;
        if(lazy[i] != 0) pushDown(s, c, t, i); // 是否推送标记
        if(idx <= c) update(idx, x, s, c, i * 2);
        else update(idx, x, c + 1, t, i * 2 + 1);
        pushUp(i);  // 后序动作，自底向上更新结点区间和 tree[i]
    }
    // 单点查询 (具体): 查询 nums[i]，尾递归
    private int query(int idx, int s, int t, int i){
        if(s == t) return tree[i];
        int c = s + (t - s) / 2;
        if(lazy[i] != 0) pushDown(s, c, t, i); // 是否推送标记
        if(idx <= c) return query(idx, s, c, i * 2);
        else return query(idx, c + 1, t, i * 2 + 1);
    }
    // 区间修改: 增量式 [l,r] 区间所有元素加上x
    private void add(int l, int r, int x, int s, int t, int i){
        if(l <= s && t <= r){ // 当前结点代表的区间在所求区间之内
            tree[i] += (t - s + 1) * x; // 结点i的区间和加上t-s+1个x
            if(s != t) lazy[i] += x; // 结点i不是叶子结点，懒标记值加上x
            return;
        }
        int c = s + (t - s) / 2;
        if(lazy[i] != 0) pushDown(s, c, t, i); // 是否推送标记
        if(l <= c) add(l, r, x, s, c, i * 2);
        if(r > c) add(l, r, x, c + 1, t, i * 2 + 1);
        pushUp(i); // 后序动作，自底向上更新结点区间和 tree[i]
    }
    // 区间查询: 求 nums[l]~nums[r]之和
    private int sum(int l, int r, int s, int t, int i){
        if(l <= s && t <= r) return tree[i]; // 当前结点代表的区间在所求区间之内
        int c = s + (t - s) / 2, sum = 0;
        if(lazy[i] != 0) pushDown(s, c, t, i); // 是否推送标记
        if(l <= c) sum += sum(l, r, s, c, i * 2);
        if(r > c) sum += sum(l, r, c + 1, t, i * 2 + 1);
        return sum;
    }
    // 区间查询: 查询[l,r]中的最小值
    private int min(int l, int r, int s, int t, int i){
        if(s == t) return tree[i]; // 叶子结点
        int c = s + (t - s) / 2, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;
        if(lazy[i] != 0) pushDown(s, c, t, i); // 是否推送标记
        if(l <= c) lmin = min(l, r, s, c, i * 2);
        if(r > c) rmin = min(l, r, c + 1, t, i * 2 + 1);
        return Math.min(lmin, rmin);
    }
    // 区间查询: 查询[l,r]中的最大值
    private int max(int l, int r, int s, int t, int i){
        if(s == t) return tree[i];
        int c = s + (t - s) / 2, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;
        if(lazy[i] != 0) pushDown(s, c, t, i);
        if(l <= c) lmax = max(l, r, s, c, i * 2);
        if(r > c) rmax = max(l, r, c + 1, t, i * 2 + 1);
        return Math.max(lmax, rmax);
    }
    // 构建线段树(tree数组)
    private void build(int s, int t, int i){
        if(s == t) { // s: start,nums当前结点区间起点下标，t: terminal,nums当前结点区间末尾下标
            tree[i] = nums[s];
            return;
        }
        int c = s + (t - s) / 2;
        build(s, c, i * 2);
        build(c + 1, t, i * 2 + 1);
        pushUp(i);  // 后序动作，自底向上更新结点区间和 tree[i]
    }
    // pushup: 更新 tree[i]
    private void pushUp(int i){
        tree[i] = tree[i * 2] + tree[i * 2 + 1];
    }
    // pushdown: 更新当前结点及其左右子结点的懒标记
    private void pushDown(int s, int c, int t, int i){
        tree[i * 2] += (c - s + 1) * lazy[i]; // 更新其左子结点的区间和
        lazy[i * 2] += lazy[i]; // 传递懒标记(增量标记)
        tree[i * 2 + 1] += (t - c) * lazy[i];
        lazy[i * 2 + 1] += lazy[i];
        lazy[i] = 0; // 重置当前结点懒惰标记值（增量标记置0）
    }
}
```

<br />

##### 覆盖式区间修改版

```java
/**
 * 静态线段树 (带懒标记，覆盖式区间修改为)
 * 支持：单点修改 / 单点查询 / 区间求和 / 覆盖式区间修改
 */
class SegmentTreeUpdate{
    int[] nums, tree, lazy;
    boolean[] updated;
    int n;
    public SegmentTreeUpdate(int[] nums){
        this.nums = nums;
        this.n = nums.length;
        this.tree = new int[4 * n];
        this.lazy = new int[4 * n];
        this.updated = new boolean[4 * n];
        build(0, n - 1, 1);
    }
    public void add(int i, int x){ // 单点修改(驱动): 增量式 nums[i] += x
        add(i, x, 0, n - 1, 1);
    }
    public void update(int i, int x){ // 单点修改(驱动): 覆盖式 nums[i] = x
        update(i, x, 0, n - 1, 1);
    }
    public int query(int i){ // 单点查询 (驱动): 查询 nums[i]
        return query(i, 0, n - 1, 1);
    }
    public void update(int l, int r, int x){ // 区间修改(驱动): 覆盖式 [l,r] 区间所有元素改为x
        update(l, r, x, 0, n - 1, 1);
    }
    public int sum(int l, int r){ // 区间查询(驱动): nums[l]~nums[r]之和
        return sum(l, r, 0, n - 1, 1);
    }
    public int min(int l, int r){ // 区间查询 (驱动): 查询[l,r]中的最小值
        return min(l, r, 0, n - 1, 1);
    }
    public int max(int l, int r){ // 区间查询 (驱动): 查询[l,r]中的最大值
        return max(l, r, 0, n - 1, 1);
    }
    // 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。
    private void add(int idx, int x, int s, int t, int i){
        if(s == t) {
            tree[i] += x; // 增量更新
            return;
        }
        int c = s + (t - s) / 2;
        if(updated[i]) pushDown(s, c, t, i); // 是否推送标记
        if(idx <= c) add(idx, x, s, c, i * 2);
        else add(idx, x, c + 1, t, i * 2 + 1);
        pushUp(i); // 后序动作，自底向上更新结点区间和 tree[i]
    }
    // 单点修改: 覆盖式 令nums[idx] = x。修改叶子结点，无关标记。
    private void update(int idx, int x, int s, int t, int i){
        if(s == t) {
            tree[i] = x; // 覆盖更新
            return;
        }
        int c = s + (t - s) / 2;
        if(updated[i]) pushDown(s, c, t, i); // 是否推送标记
        if(idx <= c) update(idx, x, s, c, i * 2);
        else update(idx, x, c + 1, t, i * 2 + 1);
        pushUp(i);  // 后序动作，自底向上更新结点区间和 tree[i]
    }
    // 单点查询 (具体): 查询 nums[i]，尾递归
    private int query(int idx, int s, int t, int i){
        if(s == t) return tree[i];
        int c = s + (t - s) / 2;
        if(updated[i]) pushDown(s, c, t, i); // 当前结点懒惰标记不为0
        if(idx <= c) return query(idx, s, c, i * 2);
        else return query(idx, c + 1, t, i * 2 + 1);
    }
    // 区间修改: 覆盖式 [l,r] 区间所有元素改为x
    private void update(int l, int r, int x, int s, int t, int i){
        if(l <= s && t <= r){ // 当前结点代表的区间在所求区间之内
            tree[i] = (t - s + 1) * x; // 结点i的区间和等于t-s+1个x
            if(s != t) { // 结点i不是叶子结点
                lazy[i] = x; // 更新懒标记
                updated[i] = true; // 更新updated
            }
            return;
        }
        int c = s + (t - s) / 2;
        if(updated[i]) pushDown(s, c, t, i); // 是否推送标记
        if(l <= c) update(l, r, x, s, c, i * 2);
        if(r > c) update(l, r, x, c + 1, t, i * 2 + 1);
        pushUp(i); // 后序动作，自底向上更新结点区间和 tree[i]
    }
    // 区间查询: 求 nums[l]~nums[r]之和
    private int sum(int l, int r, int s, int t, int i){
        if(l <= s && t <= r) return tree[i]; // 当前结点代表的区间在所要求的区间之内
        int c = s + (t - s) / 2, sum = 0;
        if(updated[i]) pushDown(s, c, t, i); // 是否推送标记
        if(l <= c) sum += sum(l, r, s, c, i * 2);
        if(r > c) sum += sum(l, r, c + 1, t, i * 2 + 1);
        return sum;
    }
    // 区间查询: 查询[l,r]中的最小值
    private int min(int l, int r, int s, int t, int i){
        if(s == t) return tree[i]; // 叶子结点
        int c = s + (t - s) / 2, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;
        if(updated[i]) pushDown(s, c, t, i); // 是否推送标记
        if(l <= c) lmin = min(l, r, s, c, i * 2);
        if(r > c) rmin = min(l, r, c + 1, t, i * 2 + 1);
        return Math.min(lmin, rmin);
    }
    // 区间查询: 查询[l,r]中的最大值
    private int max(int l, int r, int s, int t, int i){
        if(s == t) return tree[i];
        int c = s + (t - s) / 2, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;
        if(updated[i]) pushDown(s, c, t, i);
        if(l <= c) lmax = max(l, r, s, c, i * 2);
        if(r > c) rmax = max(l, r, c + 1, t, i * 2 + 1);
        return Math.max(lmax, rmax);
    }
    // 构建线段树(tree数组)
    private void build(int s, int t, int i){
        if(s == t) { // s: start,nums当前结点区间起点下标，t: terminal,nums当前结点区间末尾下标
            tree[i] = nums[s];
            return;
        }
        int c = s + (t - s) / 2;
        build(s, c, i * 2);
        build(c + 1, t, i * 2 + 1);
        pushUp(i);  // 后序动作，自底向上更新结点区间和 tree[i]
    }
    // pushup: 更新 tree[i]
    private void pushUp(int i){
        tree[i] = tree[i * 2] + tree[i * 2 + 1];
    }
    // pushdown: 更新当前结点及其左右子结点的懒标记和updated
    private void pushDown(int s, int c, int t, int i){
        tree[i * 2] = (c - s + 1) * lazy[i]; // 更新其左子结点的区间和
        lazy[i * 2] = lazy[i]; // 传递懒标记(覆盖式标记)
        updated[i * 2] = true;
        tree[i * 2 + 1] = (t - c) * lazy[i];
        lazy[i * 2 + 1] = lazy[i];
        updated[i * 2 + 1] = true;
        lazy[i] = 0; // 重置当前结点懒惰标记值
        updated[i] = false; // 重置当前结点updated[i]为false
    }
}
```

<br />

### 离散化

学会了带懒惰标记的线段树后，对于「区间问题」，我们终于掌握了一个比「树状数组」更强大的工具。对于大小为 $n$ 的序列 $nums$ ，带懒惰标记的线段树，同时以 $O(logn)$  时间复杂度支持 **「单点修改」、「单点查询」、「区间修改」和「区间查询」** 。其中，「区间修改」支持增量式或覆盖式，「区间查询」除了能求区间和，也可以求区间最值。实际上线段树经过一些调整，能够实现更多的区间运算。

当我们信心满满开始用这把锤子去敲线段树题目钉子时，我们马上会遇到一个问题 ── 空间爆炸！仍以 [699. 掉落的方块](https://leetcode.cn/problems/falling-squares/) 为例，本题实际上就是要实现「覆盖式区间修改」和「区间最大值查询」操作。根据题目的数据范围提示，求解区间从 1 到 **最右边方块的右界** 为止，这个值是 $n=10^8+10^6$ 。按照我们目前为止讲解的堆式线段树的做法，$tree[]$ 的大小将达到 $4*n=4*(10^8+10^6)$ ，会 $MLE$ 。

好在解决办法我们在「[树状数组](https://leetcode.cn/circle/discuss/qGREiN/)」中介绍过，那就是在不影响求解的情况下，先将求解区间离散化。以 699 题为例，方块 $[l,l+h]$ 掉落时，我们首先在 $[l,l+h-1]$ 区间内查询最大高度 $height$ ，然后将此区间修改为 $h + height$ 。我们发现，只要保证所有方块的左右界的前后关系 (大小关系) 保持不变， 则像下图那样将所有方块的左右界一起离散化后，原问题的解不变。具体求解过程和代码可参考 [题解](https://leetcode.cn/problems/falling-squares/solution/-by-yukiyama-lxtu/) 。

![image.png](https://pic.leetcode-cn.com/1658738555-GFbSIZ-image.png)

离散化主要分为紧离散和松离散，二者的区别已在「[树状数组](https://leetcode.cn/circle/discuss/qGREiN/)」中讲解过。

```java
// 松离散
private void discrete(int[] nums){ 
    int n = nums.length;
    int[] tmp = new int[n];
    System.arraycopy(nums, 0, tmp, 0, n);
    Arrays.sort(tmp);
    for (int i = 0; i < n; ++i) {
        nums[i] = Arrays.binarySearch(tmp, nums[i]) + 1;
    }
}

// 紧离散
private Map<Integer, Integer> discrete(int[] nums){ 
    Map<Integer, Integer> map = new HashMap<>();
    Set<Integer> set = new HashSet<>();
    for(int num : nums) set.add(num);
    List<Integer> list = new ArrayList<>(set);
    Collections.sort(list);
    int idx = 0;
    for(int num : list) map.put(num, ++idx);
    return map;
}
```

<br />

### 动态开点

现在，有了「离散化」这一工具，我们重新出发。在用「离散化」锤掉 699 题之后，继续尝试解决 [715. Range 模块](https://leetcode.cn/problems/range-module/) 一题。按如下理解题意，不难看出这也是一道非常典型的线段树题目。可用支持覆盖式「区间修改」和「区间查询 (求和)」的线段树实现。

- $addRange$ 方法即覆盖式「区间修改」，我们可以视作将区间 $[left,right-1]$ 的每个元素修改为 1。
- $queryRange$ 方法即「区间查询」，对区间 $[left,right-1]$ 求和，若 $sum = right-left$  返回 $true$ ，否则返回 $false$ 。
- $removeRange$ 方法也是覆盖式「区间修改」，将区间 $[left,right-1]$ 的每个元素修改为 0。

根据题目给出的取值范围，我们看到「区间」范围为 $[1,10^9]$ ，直接用堆式线段树则 $tree[]$ 数组大小达到 $4*10^9$ ，会 $MLE$ 。当我们打算通过「离散化」来缩小区间时，发现本题是 **[强制在线](https://en.wikipedia.org/wiki/Online_algorithm)** 的，也就是并未提前告诉我们所有涉及询问和修改的区间范围，因此无法离散化。

※ $log(4*10^9) > 31 ，2^{31} = 2Gbit$  ，因此要创建大小为 $4*10^9$ 的数组，就需要超过 $2Gb$ 的空间。



现在请看向本小节的标题 —— **「动态开点」** ，如果你此前有瞥过一些线段树的文章，你应该没少看到过这个词。总之你大概知道既然不能在程序开始时就完成初始「线段树」的构建的话，那就在区间查询或区间修改时，根据届时传入的区间信息来「动态地」创建结点，那么如何做到呢？

为了引出如何动态创建结点，我们先回顾「堆式线段树」的操作。每个结点代表一个确定的区间，当我们需要查询或修改区间 $[l,r]$ 时，就要找到代表 $[l,r]$ 的若干结点，操作它们的 $tree[i]$ 值和相应的 $lazy/updated$ (如果有的话)。我们需要知道搜索过程中结点代表的区间范围 $[s,t]$ ，通过与 $[l,r]$ 的比较来确定是否是目标区间，同时也要知道这个结点的下标 $i$ 使得我们能够操作 $tree[i]$ ，因此 $s,t,i$ 三者是绑定的。总之，查找目标区间的关键是:

> **方法执行过程中保证结点值 (指 $tree[i]$，一般为区间和 ) 和该结点代表的区间 $[s,t]$ 是同时获知的**。

堆式线段树通过 $i, 2*i, 2*i+1$ 下标关系实现了这一点。但只要我们能实现以上描述，线段树不必是「堆式」的。



一个直接的想法是不再由 `int[] tree` 来存储结点值信息，而是以 `Node[] tree` 来维护结点信息，$Node$ 可以作为线段树类中的嵌套类，它持有结点的值信息 $val$ (一般为区间和) ，此外还持有它的左右孩子的下标 $lIdx, rIdx$ ，这样当我们要递归进入左右孩子结点 (左右子区间) 时，就可以直接从当前结点读取下标，将 $tree[tree[i].lIdx]$ 或 $tree[tree[i].rIdx]$ 传入方法中，实现结点信息 ($tree[tree[i].lIdx].val$ 或 $tree[tree[i].rIdx].val$) 和 $[s,t]$ 的同时获知。

到这里，我们实际上已经给出了「动态开点线段树」的第一种实现方式 —— 结点数组法。

<br />

#### 结点数组法

我们直接给出如下包含了构造器和区间修改 (增量式) 的代码，结合后图分析 **「结点数组法动态线段树」** 是如何「动态开点」的。

```java
class DynamicSegmentTreeArrayAdd{ 
    private class Node{
        int lIdx, rIdx, lazy, val;
    }
    Node[] tree;
    int n, count;
    public DynamicSegmentTreeArrayAdd(int n, int m){
        this.n = n;
        this.count = 1;
        this.tree = new Node[m];
    }
    public void add(int l, int r, int x){ // 区间修改(驱动): 增量式 [l,r] 区间所有元素加上x
        add(l, r, x, 0, n - 1, 1);
    }    
    // 区间修改: 增量式 [l,r] 区间所有元素加上x
    private void add(int l, int r, int x, int s, int t, int i){
        if(l <= s && t <= r){ // 当前结点代表的区间在所求区间之内
            tree[i].val += (t - s + 1) * x; // 结点i的区间和加上t-s+1个x
            if(s != t) tree[i].lazy += x; // 结点i不是叶子结点，懒标记值加上x
            return;
        }
        addNode(i); // 动态开点
        int c = s + (t - s) / 2;
        if(tree[i].lazy != 0) pushDown(s, c, t, i); // 是否推送标记
        if(l <= c) add(l, r, x, s, c, tree[i].lIdx);
        if(r > c) add(l, r, x, c + 1, t, tree[i].rIdx);
        pushUp(i); // 后序动作，自底向上更新结点区间和 tree[i]
    }
    // 动态开点
    private void addNode(int i){
        if(tree[i] == null) tree[i] = new Node(); // 当前结点未建，创建之
        if(tree[i].lIdx == 0) { // 若 tree[i] 结点无左孩子，添加之
            tree[i].lIdx = ++count; // 赋予结点标号
            tree[tree[i].lIdx] = new Node(); // 开辟实例
        }
        if(tree[i].rIdx == 0) { // 若 tree[i] 结点无右孩子，添加之
            tree[i].rIdx = ++count;
            tree[tree[i].rIdx] = new Node();
        }
    }
}
```

首先看构造器。$n$ 是输入区间的大小，它的范围是 $[0,n-1]$ 。 **整个区间的范围是必须知道的** ，因为我们要从输入区间开始不断划分左右区间，因此要传入 $n$ 。 $m$ 是 $tree$ 的大小，因为在这个实现中 $tree[]$ 是 $Node$ 数组，初始化它必须要给出数组大小。在堆式线段树中，这个大小是 $4*n$ ，但前面已经说过 $n$ 特别大，且由于「强制在线」而无法离散化，因此这个大小需要 **「估计」** ，估计方法后述。

接着看区间修改的驱动方法和具体的区间修改方法，它们与我们前面给出的堆式线段树的写法几乎相同，区别只在于多了一行 `addNode(i)` 。 $add$ 运行到此处时，之后会划分当前区间为左右子区间，然后带着区间信息和左右子结点的信息递归调用 $add$ (递进到左右子结点中) 。但是我们 **尚未创建左右子结点，甚至当前结点也可能尚未创建** ，因此必须执行 `addNode(i)` ，根据方法中的判断结果来决定是否要创建当前结点 $tree[i]$ 、左子结点 $tree[tree[i].lIdx]$  或右子结点 $tree[tree[i].rIdx]$ 。我们注意到结点编号是从 1 开始递增的，因此判断是否存在子结点时， 可以不必像判断当前结点是否存在那样执行 `tree[tree[i].lIdx] == null` 而是通过 `tree[i].lIdx == 0` 来判断即可。



同样地，对于其他查询或修改方法，与堆式线段树的实现的区别都只是是在方法中多了 `addNode(i)` 这一行「开点」语句，如此就实现了 **只在查询或修改时按需动态地创建结点** 这一目标。 完整的类实现我们放在稍后的「类的实现代码」中。如下 ①~⑨ 是在区间为 $[0,14]$ 的输入序列上修改区间 $[1,3]$ 时依次动态创建的结点，注意结点标号是从 1 开始递增的。

![image.png](https://pic.leetcode-cn.com/1658817308-RgfxZv-image.png)

<br />

##### 预估结点数

$tree[]$ 的大小 $m$ 需要预估。从上图过程中我们看到，每次查询或修改操作的「开点」次数与树高有关，我们知道树高 $h$ 与叶子结点数 $n$ (即我们必须知道的区间大小) 的关系，因此只要能够提前知道操作总次数 (查询和修改) ，并假设查询或修改的区间 **不太大**，我们就能估计出 $m$ 的大小。 如下：

1. 整棵线段树的结点数不会超过 $4*n$ 。
2. 每次查询从根结点往下，在假设查询或修改的区间只有一个值，则开点次数为树高 $h = \lceil log_{2}(4*n) \rceil -1=log_{2}(4*n)$  (根结点高 0)，每次开两个点，于是一次查询最多新建 $2*h$ 个结点。但平均而言操作的区间当然不会只有一个值，因此这里我们要适当放大倍数，根据经验可放大到 $6*h$ 。
3. 假设有 $k$ 次操作，则有估计 $m=6*k*log_{2}(4*n)$ ，省略 $6*k*2$ 后得到 $m = 6*k*logn$  。



现在，在参考「类的实现代码」中「结点数组法」版本的代码以及 [题解](https://leetcode.cn/problems/range-module/solution/yukiyama-by-yukiyama-lyg5/) 的基础上，应当很容易写出「结点数组法动态线段树」解决  [715. Range 模块](https://leetcode.cn/problems/range-module/) 。



应用结点数组法动态线段树解决 715题 时，我们会感到  **$m$ 的预估相对麻烦** ，估计偏小时还可能出现数组越界的错误。让我们考虑更严格的情况。假设操作次数也未知，那么我们将无法估计 $m$ ，也就无法很好地使用结点上数组法来实现动态线段树，除非像 $ArrayList$ 内部动态扩展数组那样，当空间不够时再将当前 $tree[]$ 拷贝到新申请的更大的 $Node$ 数组中，但如此一来单次查询或修改的的时间复杂度就不保证是 $O(logn)$ 了。

避免数组大小预估的思考引出下面的 **「结点指针 (引用)」法动态线段树」** 。

<br />

#### 结点指针 (引用) 法

避免数组大小预估的办法很简单。我们不再通过数组来保存结点信息，而是在 $Node$ 中持有同样是 $Node$ 类型的左子结点 $lChild$ 和右子结点 $rChild$ 。如此一来，在处理到代表区间 $[l,r]$ 的当前结点 $cur$  时，我们总是能够将左右子区间分别与 $cur.lChild$ 或 $cur.rChild$ 「绑定」起来。其实只要读者熟悉二叉树的一些操作，该方法反而比结点数组法要更容易想到。

结点指针法实现的动态线段树是简单的。我们直接给出如下包含了构造器和区间修改 (增量式) 的代码，对比「结点数组」法的代码，主要区别为：

- 指针法的查询或修改方法，直接传入当前结点 `Node cur` 。
- 指针法的线段树类维护根结点 $root$ 。
- 动态开点方法 $addNode$ 不同。

```java
class DynamicSegmentTreePointerAdd{
    private class Node{
        int lazy, val;
        Node lChild, rChild;
    }
    int n;
    Node root;
    public DynamicSegmentTreePointerAdd(int n){
        this.n = n;
        this.root = new Node();
    }
    public void add(int l, int r, int x){ // 区间修改(驱动): 增量式 [l,r] 区间所有元素加上x
        add(l, r, x, 0, n - 1, root);
    }
    // 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。
    private void add(int idx, int x, int s, int t, Node cur){ 
        if(s == t) {
            cur.val += x; // 增量更新
            return;
        }
        addNode(cur); // 动态开点
        int c = s + (t - s) / 2;
        if(cur.lazy != 0) pushDown(s, c, t, cur); // 当前结点懒惰标记不为0，推送标记
        if(idx <= c) add(idx, x, s, c, cur.lChild);
        else add(idx, x, c + 1, t, cur.rChild);
        pushUp(cur); // 后序动作，自底向上更新结点区间和 tree[i]
    }
    // 动态开点
    private void addNode(Node node){ 
        if(node.lChild == null) node.lChild = new Node();
        if(node.rChild == null) node.rChild = new Node();
    }
}
```

完整实现请参考「类的实现代码」。

从前面一步步看到这里，我们明显感到动态开点的线段树并不复杂，相比静态线段树，实现上的区别不过是引入了一个 $addNode$ 方法，并在查询和修改方法的适当位置调用该方法动态地创建结点而已。



现在，在参考「类的实现代码」中「结点指针 (引用) 法」版本的代码以及 [题解](https://leetcode.cn/problems/range-module/solution/yukiyama-by-yukiyama-lyg5/) 的基础上，应当很容易写出「结点指针 (引用) 法动态线段树」解决  [715. Range 模块](https://leetcode.cn/problems/range-module/) 。

<br />

#### 类的实现代码

##### 结点数组法

###### 增量式区间修改版

```java
/**
 * 动态开点线段树数组版 (带懒标记，覆盖式区间修改)
 * 支持：单点修改 / 单点查询 / 区间求和 / 覆盖式区间修改
 */
class DynamicSegmentTreeArrayAdd{
    private class Node{
        int lIdx, rIdx, lazy, val;
    }
    Node[] tree;
    int n, count;
    public DynamicSegmentTreeArrayAdd(int n, int m){
        this.n = n;
        this.count = 1;
        this.tree = new Node[m];
    }
    public void add(int i, int x){ // 单点修改(驱动): 增量式 nums[i] += x
        add(i, x, 0, n - 1, 1);
    }
    public void update(int i, int x){ // 单点修改(驱动): 覆盖式 nums[i] = x
        update(i, x, 0, n - 1, 1);
    }
    public int query(int i){ // 单点查询 (驱动): 查询 nums[i]
        return query(i, 0, n - 1, 1);
    }
    public void add(int l, int r, int x){ // 区间修改(驱动): 增量式 [l,r] 区间所有元素加上x
        add(l, r, x, 0, n - 1, 1);
    }
    public int sum(int l, int r){ // 区间查询(驱动): nums[l]~nums[r]之和
        return sum(l, r, 0, n - 1, 1);
    }
    public int min(int l, int r){ // 区间查询 (驱动): 查询[l,r]中的最小值
        return min(l, r, 0, n - 1, 1);
    }
    public int max(int l, int r){ // 区间查询 (驱动): 查询[l,r]中的最小值
        return max(l, r, 0, n - 1, 1);
    }
    // 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。
    private void add(int idx, int x, int s, int t, int i){
        if(s == t) {
            tree[i].val += x; // 增量更新
            return;
        }
        addNode(i); // 动态开点
        int c = s + (t - s) / 2;
        if(tree[i].lazy != 0) pushDown(s, c, t, i); // 是否推送标记
        if(idx <= c) add(idx, x, s, c, tree[i].lIdx);
        else add(idx, x, c + 1, t, tree[i].rIdx);
        pushUp(i); // 后序动作，自底向上更新结点区间和 tree[i]
    }
    // 单点修改: 覆盖式 令nums[idx] = x。修改叶子结点，无关标记。
    private void update(int idx, int x, int s, int t, int i){
        if(s == t) {
            tree[i].val = x; // 覆盖更新
            return;
        }
        addNode(i); // 动态开点
        int c = s + (t - s) / 2;
        if(tree[i].lazy != 0) pushDown(s, c, t, i); // 是否推送标记
        if(idx <= c) update(idx, x, s, c, tree[i].lIdx);
        else update(idx, x, c + 1, t, tree[i].rIdx);
        pushUp(i);  // 后序动作，自底向上更新结点值
    }
    // 单点查询 (具体): 查询 nums[i]，尾递归
    private int query(int idx, int s, int t, int i){
        if(s == t) return tree[i].val;
        addNode(i); // 动态开点
        int c = s + (t - s) / 2;
        if(tree[i].lazy != 0) pushDown(s, c, t, i); // 是否推送标记
        if(idx <= c) return query(idx, s, c, tree[i].lIdx);
        else return query(idx, c + 1, t, tree[i].rIdx);
    }
    // 区间修改: 增量式 [l,r] 区间所有元素加上x
    private void add(int l, int r, int x, int s, int t, int i){
        if(l <= s && t <= r){ // 当前结点代表的区间在所求区间之内
            tree[i].val += (t - s + 1) * x; // 结点i的区间和加上t-s+1个x
            if(s != t) tree[i].lazy += x; // 结点i不是叶子结点，懒标记值加上x
            return;
        }
        addNode(i); // 动态开点
        int c = s + (t - s) / 2;
        if(tree[i].lazy != 0) pushDown(s, c, t, i); // 是否推送标记
        if(l <= c) add(l, r, x, s, c, tree[i].lIdx);
        if(r > c) add(l, r, x, c + 1, t, tree[i].rIdx);
        pushUp(i); // 后序动作，自底向上更新结点区间和 tree[i]
    }
    // 区间查询: 求 nums[l]~nums[r]之和
    private int sum(int l, int r, int s, int t, int i){
        if(l <= s && t <= r) return tree[i].val; // 当前结点代表的区间在所求区间之内
        addNode(i); // 动态开点
        int c = s + (t - s) / 2, sum = 0;
        if(tree[i].lazy != 0) pushDown(s, c, t, i); // 是否推送标记
        if(l <= c) sum += sum(l, r, s, c, tree[i].lIdx);
        if(r > c) sum += sum(l, r, c + 1, t, tree[i].rIdx);
        return sum;
    }
    // 区间查询: 查询[l,r]中的最小值
    private int min(int l, int r, int s, int t, int i){
        if(s == t) return tree[i].val; // 叶子结点
        addNode(i); // 动态开点
        int c = s + (t - s) / 2, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;
        if(tree[i].lazy != 0) pushDown(s, c, t, i); // 是否推送标记
        if(l <= c) lmin = min(l, r, s, c, tree[i].lIdx);
        if(r > c) rmin = min(l, r, c + 1, t, tree[i].rIdx);
        return Math.min(lmin, rmin);
    }
    // 区间查询: 查询[l,r]中的最大值
    private int max(int l, int r, int s, int t, int i){
        if(s == t) return tree[i].val;
        addNode(i); // 动态开点
        int c = s + (t - s) / 2, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;
        if(tree[i].lazy != 0) pushDown(s, c, t, i);
        if(l <= c) lmax = max(l, r, s, c, tree[i].lIdx);
        if(r > c) rmax = max(l, r, c + 1, t, tree[i].rIdx);
        return Math.max(lmax, rmax);
    }
    // pushup: 更新 cur.val
    private void pushUp(int i){
        Node cur = tree[i], lChild = tree[cur.lIdx], rChild = tree[cur.rIdx];
        cur.val = lChild.val + rChild.val;
    }
    // pushdown: 更新当前结点及其左右子结点的懒标记
    private void pushDown(int s, int c, int t, int i){
        Node cur = tree[i], lChild = tree[cur.lIdx], rChild = tree[cur.rIdx];
        lChild.val += (c - s + 1) * cur.lazy; // 更新其左子结点的区间和
        lChild.lazy += cur.lazy; // 传递懒标记
        rChild.val += (t - c) * cur.lazy;
        rChild.lazy += cur.lazy;
        cur.lazy = 0;
    }
    // 动态开点
    private void addNode(int i){
        if(tree[i] == null) tree[i] = new Node(); // 当前结点未建，创建之
        if(tree[i].lIdx == 0) { // 若 tree[i] 结点无左孩子，添加之
            tree[i].lIdx = ++count; // 赋予结点标号
            tree[tree[i].lIdx] = new Node(); // 开辟实例
        }
        if(tree[i].rIdx == 0) { // 若 tree[i] 结点无右孩子，添加之
            tree[i].rIdx = ++count;
            tree[tree[i].rIdx] = new Node();
        }
    }
}
```

<br />

###### 覆盖式区间修改版

```java
/**
 * 动态开点线段树数组版 (带懒标记，覆盖式区间修改为)
 * 支持：单点修改 / 单点查询 / 区间求和 / 覆盖式区间修改
 */
class DynamicSegmentTreeArrayUpdate{
    private class Node{
        int lIdx, rIdx, lazy, val;
        boolean updated;
    }
    Node[] tree;
    int n, count;
    public DynamicSegmentTreeArrayUpdate(int n, int m){
        this.n = n;
        this.count = 1;
        this.tree = new Node[m];
    }
    public void add(int i, int x){ // 单点修改(驱动): 增量式 nums[i] += x
        add(i, x, 0, n - 1, 1);
    }
    public void update(int i, int x){ // 单点修改(驱动): 覆盖式 nums[i] = x
        update(i, x, 0, n - 1, 1);
    }
    public int query(int i){ // 单点查询 (驱动): 查询 nums[i]
        return query(i, 0, n - 1, 1);
    }
    public void update(int l, int r, int x){ // 区间修改(驱动): 覆盖式 [l,r] 区间所有元素改为x
        update(l, r, x, 0, n - 1, 1);
    }
    public int sum(int l, int r){ // 区间查询(驱动): nums[l]~nums[r]之和
        return sum(l, r, 0, n - 1, 1);
    }
    public int min(int l, int r){ // 区间查询 (驱动): 查询[l,r]中的最小值
        return min(l, r, 0, n - 1, 1);
    }
    public int max(int l, int r){ // 区间查询 (驱动): 查询[l,r]中的最大值
        return max(l, r, 0, n - 1, 1);
    }
    // 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。
    private void add(int idx, int x, int s, int t, int i){
        if(s == t) {
            tree[i].val += x; // 增量更新
            return;
        }
        addNode(i); // 动态开点
        int c = s + (t - s) / 2;
        if(tree[i].updated) pushDown(s, c, t, i); // 是否推送标记
        if(idx <= c) add(idx, x, s, c, tree[i].lIdx);
        else add(idx, x, c + 1, t, tree[i].rIdx);
        pushUp(i); // 后序动作，自底向上更新结点区间和 tree[i]
    }
    // 单点修改: 覆盖式 令nums[idx] = x。修改叶子结点，无关标记。
    private void update(int idx, int x, int s, int t, int i){
        if(s == t) {
            tree[i].val = x; // 覆盖更新
            return;
        }
        addNode(i); // 动态开点
        int c = s + (t - s) / 2;
        if(tree[i].updated) pushDown(s, c, t, i); // 是否推送标记
        if(idx <= c) update(idx, x, s, c, tree[i].lIdx);
        else update(idx, x, c + 1, t, tree[i].rIdx);
        pushUp(i);  // 后序动作，自底向上更新结点区间和 tree[i]
    }
    // 单点查询 (具体): 查询 nums[i]，尾递归
    private int query(int idx, int s, int t, int i){
        if(s == t) return tree[i].val;
        addNode(i); // 动态开点
        int c = s + (t - s) / 2;
        if(tree[i].updated) pushDown(s, c, t, i); // 是否推送标记
        if(idx <= c) return query(idx, s, c, tree[i].lIdx);
        else return query(idx, c + 1, t, tree[i].rIdx);
    }
    // 区间修改: 覆盖式 [l,r] 区间所有元素改为x
    private void update(int l, int r, int x, int s, int t, int i){
        if(l <= s && t <= r){ // 当前结点代表的区间在所求区间之内
            tree[i].val = (t - s + 1) * x; // 结点i的区间和等于t-s+1个x
            if(s != t) {
                tree[i].lazy = x; // 更新懒标记
                tree[i].updated = true; // 更新updated
            }
            return;
        }
        addNode(i); // 动态开点
        int c = s + (t - s) / 2;
        if(tree[i].updated) pushDown(s, c, t, i); // 是否推送标记
        if(l <= c) update(l, r, x, s, c, tree[i].lIdx);
        if(r > c) update(l, r, x, c + 1, t, tree[i].rIdx);
        pushUp(i); // 后序动作，自底向上更新结点值
    }
    // 区间查询: 求 nums[l]~nums[r]之和
    private int sum(int l, int r, int s, int t, int i){
        if(l <= s && t <= r) return tree[i].val; // 当前结点代表的区间在所求区间之内
        addNode(i); // 动态开点
        int c = s + (t - s) / 2, sum = 0;
        if(tree[i].updated) pushDown(s, c, t, i); // 是否推送标记
        if(l <= c) sum += sum(l, r, s, c, tree[i].lIdx);
        if(r > c) sum += sum(l, r, c + 1, t, tree[i].rIdx);
        return sum;
    }
    // 区间查询: 查询[l,r]中的最小值
    private int min(int l, int r, int s, int t, int i){
        if(s == t) return tree[i].val; // 叶子结点
        addNode(i); // 动态开点
        int c = s + (t - s) / 2, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;
        if(tree[i].updated) pushDown(s, c, t, i); // 是否推送标记
        if(l <= c) lmin = min(l, r, s, c, tree[i].lIdx);
        if(r > c) rmin = min(l, r, c + 1, t, tree[i].rIdx);
        return Math.min(lmin, rmin);
    }
    // 区间查询: 查询[l,r]中的最大值
    private int max(int l, int r, int s, int t, int i){
        if(s == t) return tree[i].val;
        addNode(i); // 动态开点
        int c = s + (t - s) / 2, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;
        if(tree[i].updated) pushDown(s, c, t, i); // 是否推送标记
        if(l <= c) lmax = max(l, r, s, c, tree[i].lIdx);
        if(r > c) rmax = max(l, r, c + 1, t, tree[i].rIdx);
        return Math.max(lmax, rmax);
    }
    // 更新 cur.val
    private void pushUp(int i){
        Node cur = tree[i], lChild = tree[cur.lIdx], rChild = tree[cur.rIdx];
        cur.val = lChild.val + rChild.val;
    }
    // pushdown: 更新当前结点及其左右子结点的懒标记和updated
    private void pushDown(int s, int c, int t, int i){
        Node cur = tree[i], lChild = tree[cur.lIdx], rChild = tree[cur.rIdx];
        lChild.val = (c - s + 1) * cur.lazy; // 更新左子结点的区间和
        lChild.lazy = cur.lazy; // 传递懒标记(增量标记)到左子结点中
        lChild.updated = true; // 更新左子结点updated
        rChild.val = (t - c) * cur.lazy;
        rChild.lazy = cur.lazy;
        rChild.updated = true;
        cur.lazy = 0; // 重置当前结点懒惰标记值
        cur.updated = false; // 更新updated
    }
    // 动态开点
    private void addNode(int i){
        if(tree[i] == null) tree[i] = new Node();
        if(tree[i].lIdx == 0) { // 若 tree[i] 结点无左孩子，添加之
            tree[i].lIdx = ++count; // 赋予结点标号
            tree[tree[i].lIdx] = new Node(); // 开辟实例
        }
        if(tree[i].rIdx == 0) { // 若 tree[i] 结点无右孩子，添加之
            tree[i].rIdx = ++count;
            tree[tree[i].rIdx] = new Node();
        }
    }
}
```

<br />

##### 结点指针 (引用) 法

###### 增量式区间修改版

```java
/**
 * 动态开点线段树指针版 (带懒标记，增量式区间修改)
 * 支持：单点修改 / 单点查询 / 区间求和 / 增量式区间修改
 */
class DynamicSegmentTreePointerAdd{
    private class Node{
        int lazy, val;
        Node lChild, rChild;
    }
    int n;
    Node root;
    public DynamicSegmentTreePointerAdd(int n){
        this.n = n;
        this.root = new Node();
    }
    public void add(int i, int x){ // 单点修改(驱动): 增量式 nums[i] += x
        add(i, x, 0, n - 1, root);
    }
    public void update(int i, int x){ // 单点修改(驱动): 覆盖式 nums[i] = x
        update(i, x, 0, n - 1, root);
    }
    public int query(int i){ // 单点查询 (驱动): 查询 nums[i]
        return query(i, 0, n - 1, root);
    }
    public void add(int l, int r, int x){ // 区间修改(驱动): 增量式 [l,r] 区间所有元素加上x
        add(l, r, x, 0, n - 1, root);
    }
    public int sum(int l, int r){ // 区间查询(驱动): nums[l]~nums[r]之和
        return sum(l, r, 0, n - 1, root);
    }
    public int min(int l, int r){ // 区间查询 (驱动): 查询[l,r]中的最小值
        return min(l, r, 0, n - 1, root);
    }
    public int max(int l, int r){ // 区间查询 (驱动): 查询[l,r]中的最大值
        return max(l, r, 0, n - 1, root);
    }
    // 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。
    private void add(int idx, int x, int s, int t, Node cur){
        if(s == t) {
            cur.val += x; // 增量更新
            return;
        }
        addNode(cur); // 动态开点
        int c = s + (t - s) / 2;
        if(cur.lazy != 0) pushDown(s, c, t, cur); // 是否推送标记
        if(idx <= c) add(idx, x, s, c, cur.lChild);
        else add(idx, x, c + 1, t, cur.rChild);
        pushUp(cur); // 后序动作，自底向上更新结点区间和 tree[i]
    }
    // 单点修改: 覆盖式 令nums[idx] = x。修改叶子结点，无关标记。
    private void update(int idx, int x, int s, int t, Node cur){
        if(s == t) {
            cur.val = x; // 覆盖更新
            return;
        }
        addNode(cur); // 动态开点
        int c = s + (t - s) / 2;
        if(cur.lazy != 0) pushDown(s, c, t, cur); // 是否推送标记
        if(idx <= c) update(idx, x, s, c, cur.lChild);
        else update(idx, x, c + 1, t, cur.rChild);
        pushUp(cur);  // 后序动作，自底向上更新结点区间和 tree[i]
    }
    // 单点查询: 查询 nums[i]，尾递归
    private int query(int i, int s, int t, Node cur){
        if(s == t) return cur.val;
        addNode(cur); // 动态开点
        int c = s + (t - s) / 2;
        if(cur.lazy != 0) pushDown(s, c, t, cur); // 是否推送标记
        if(i <= c) return query(i, s, c, cur.lChild);
        else return query(i, c + 1, t, cur.rChild);
    }
    // 区间修改: 增量式 [l,r] 区间所有元素加上x
    private void add(int l, int r, int x, int s, int t, Node cur){
        if(l <= s && t <= r){ // 当前结点代表的区间在所求区间之内
            cur.val += (t - s + 1) * x; // 结点i的区间和加上t-s+1个x
            if(s != t) cur.lazy += x; // 结点i不是叶子结点，懒标记值加上x
            return;
        }
        addNode(cur); // 动态开点
        int c = s + (t - s) / 2;
        if(cur.lazy != 0) pushDown(s, c, t, cur); // 是否推送标记
        if(l <= c) add(l, r, x, s, c, cur.lChild);
        if(r > c) add(l, r, x, c + 1, t, cur.rChild);
        pushUp(cur); // 后序动作，自底向上更新结点区间和 tree[i]
    }
    // 区间查询: 求 nums[l]~nums[r]之和
    private int sum(int l, int r, int s, int t, Node cur){
        if(l <= s && t <= r) return cur.val; // 当前结点代表的区间在所求区间之内
        addNode(cur); // 动态开点
        int c = s + (t - s) / 2, sum = 0;
        if(cur.lazy != 0) pushDown(s, c, t, cur); // 是否推送标记
        if(l <= c) sum += sum(l, r, s, c, cur.lChild);
        if(r > c) sum += sum(l, r, c + 1, t, cur.rChild);
        return sum;
    }
    // 区间查询: 查询[l,r]中的最小值
    private int min(int l, int r, int s, int t, Node cur){
        if(s == t) return cur.val; // 叶子结点
        addNode(cur); // 动态开点
        int c = s + (t - s) / 2, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;
        if(cur.lazy != 0) pushDown(s, c, t, cur); // 是否推送标记
        if(l <= c) lmin = min(l, r, s, c, cur.lChild);
        if(r > c) rmin = min(l, r, c + 1, t, cur.rChild);
        return Math.min(lmin, rmin);
    }
    // 区间查询: 查询[l,r]中的最大值
    private int max(int l, int r, int s, int t, Node cur){
        if(s == t) return cur.val;
        addNode(cur);
        int c = s + (t - s) / 2, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;
        if(cur.lazy != 0) pushDown(s, c, t, cur);
        if(l <= c) lmax = max(l, r, s, c, cur.lChild);
        if(r > c) rmax = max(l, r, c + 1, t, cur.rChild);
        return Math.max(lmax, rmax);
    }
    // pushup: 更新 cur.val
    private void pushUp(Node cur){
        Node lChild = cur.lChild, rChild = cur.rChild;
        cur.val = lChild.val + rChild.val;
    }
    // pushdown: 更新当前结点及其左右子结点的懒标记
    private void pushDown(int s, int c, int t, Node cur){
        Node lChild = cur.lChild, rChild = cur.rChild;
        lChild.val += (c - s + 1) * cur.lazy; // 更新其左子结点的区间和
        lChild.lazy += cur.lazy; // 传递懒标记
        rChild.val += (t - c) * cur.lazy;
        rChild.lazy += cur.lazy;
        cur.lazy = 0; // 重置当前结点懒惰标记值
    }
    // 动态开点
    private void addNode(Node node){
        if(node.lChild == null) node.lChild = new Node();
        if(node.rChild == null) node.rChild = new Node();
    }
}
```

<br />

###### 覆盖式区间修改版

```java
/**
 * 动态开点线段树指针版 (带懒标记，覆盖式区间修改)
 * 支持：单点修改 / 单点查询 / 区间查询 / 覆盖式区间修改
 */
class DynamicSegmentTreePointerUpdate{
    private class Node{
        int lazy, val;
        boolean updated;
        Node lChild, rChild;
    }
    int n;
    Node root;
    public DynamicSegmentTreePointerUpdate(int n){
        this.n = n;
        this.root = new Node();
    }
    public void add(int i, int x){ // 单点修改(驱动): 增量式 nums[i] += x
        add(i, x, 0, n - 1, root);
    }
    public void update(int i, int x){ // 单点修改(驱动): 覆盖式 nums[i] = x
        update(i, x, 0, n - 1, root);
    }
    public int query(int i){ // 单点查询(驱动): 查询 nums[i]
        return query(i, 0, n - 1, root);
    }
    public void update(int l, int r, int x){ // 区间修改(驱动): 增量式 [l,r] 区间所有元素加上x
        update(l, r, x, 0, n - 1, root);
    }
    public int sum(int l, int r){ // 区间查询(驱动): nums[l]~nums[r]之和
        return sum(l, r, 0, n - 1, root);
    }
    public int min(int l, int r){ // 区间查询(驱动): 查询[l,r]中的最小值
        return min(l, r, 0, n - 1, root);
    }
    public int max(int l, int r){ // 区间查询(驱动): 查询[l,r]中的最小值
        return max(l, r, 0, n - 1, root);
    }
    // 单点修改: 增量式 令nums[idx] += x。修改叶子结点，无关标记。
    private void add(int idx, int x, int s, int t, Node cur){
        if(s == t) {
            cur.val += x; // 增量更新
            return;
        }
        addNode(cur); // 动态开点
        int c = s + (t - s) / 2;
        if(cur.updated) pushDown(s, c, t, cur); // 是否推送标记
        if(idx <= c) add(idx, x, s, c, cur.lChild);
        else add(idx, x, c + 1, t, cur.rChild);
        pushUp(cur); // 后序动作，自底向上更新结点区间和 tree[i]
    }
    // 单点修改: 覆盖式 令nums[idx] = x。修改叶子结点，无关标记。
    private void update(int idx, int x, int s, int t, Node cur){
        if(s == t) {
            cur.val = x; // 覆盖更新
            return;
        }
        addNode(cur); // 动态开点
        int c = s + (t - s) / 2;
        if(cur.updated) pushDown(s, c, t, cur); // 是否推送标记
        if(idx <= c) update(idx, x, s, c, cur.lChild);
        else update(idx, x, c + 1, t, cur.rChild);
        pushUp(cur);  // 后序动作，自底向上更新结点区间和 tree[i]
    }
    // 单点查询: 查询 nums[i]，尾递归
    private int query(int i, int s, int t, Node cur){
        if(s == t) return cur.val;
        addNode(cur); // 动态开点
        int c = s + (t - s) / 2;
        if(cur.updated) pushDown(s, c, t, cur); // 是否推送标记
        if(i <= c) return query(i, s, c, cur.lChild);
        else return query(i, c + 1, t, cur.rChild);
    }
    // 区间修改: 覆盖式 [l,r] 区间所有元素改为x
    private void update(int l, int r, int x, int s, int t, Node cur){
        if(l <= s && t <= r){ // 当前结点代表的区间在所求区间之内
            cur.val = (t - s + 1) * x; // 结点i的区间和等于t-s+1个x
            if(s != t) { // 结点i不是叶子结点
                cur.lazy = x; // 更新懒标记
                cur.updated = true; // 更新updated
            }
            return;
        }
        addNode(cur); // 动态开点
        int c = s + (t - s) / 2;
        if(cur.updated) pushDown(s, c, t, cur); // 是否推送标记
        if(l <= c) update(l, r, x, s, c, cur.lChild);
        if(r > c) update(l, r, x, c + 1, t, cur.rChild);
        pushUp(cur); // 后序动作，自底向上更新结点区间和 tree[i]
    }
    // 区间查询: 求 nums[l]~nums[r]之和
    private int sum(int l, int r, int s, int t, Node cur){
        if(l <= s && t <= r) return cur.val; // 当前结点代表的区间在所求区间之内
        addNode(cur); // 动态开点
        int c = s + (t - s) / 2, sum = 0;
        if(cur.updated) pushDown(s, c, t, cur); // 是否推送标记
        if(l <= c) sum += sum(l, r, s, c, cur.lChild);
        if(r > c) sum += sum(l, r, c + 1, t, cur.rChild);
        return sum;
    }
    // 区间查询: 查询[l,r]中的最小值
    private int min(int l, int r, int s, int t, Node cur){
        if(s == t) return cur.val; // 叶子结点
        addNode(cur); // 动态开点
        int c = s + (t - s) / 2, lmin = Integer.MAX_VALUE, rmin = Integer.MAX_VALUE;
        if(cur.updated) pushDown(s, c, t, cur); // 是否推送标记
        if(l <= c) lmin = min(l, r, s, c, cur.lChild);
        if(r > c) rmin = min(l, r, c + 1, t, cur.rChild);
        return Math.min(lmin, rmin);
    }
    // 区间查询: 查询[l,r]中的最大值
    private int max(int l, int r, int s, int t, Node cur){
        if(s == t) return cur.val;
        addNode(cur);
        int c = s + (t - s) / 2, lmax = Integer.MIN_VALUE, rmax = Integer.MIN_VALUE;
        if(cur.updated) pushDown(s, c, t, cur);
        if(l <= c) lmax = max(l, r, s, c, cur.lChild);
        if(r > c) rmax = max(l, r, c + 1, t, cur.rChild);
        return Math.max(lmax, rmax);
    }
    // pushup: 更新 cur.val
    private void pushUp(Node cur){
        Node lChild = cur.lChild, rChild = cur.rChild;
        cur.val = lChild.val + rChild.val;
    }
    // pushdown: 更新当前结点及其左右子结点的懒标记和updated
    private void pushDown(int s, int c, int t, Node cur){
        Node lChild = cur.lChild, rChild = cur.rChild;
        lChild.val = (c - s + 1) * cur.lazy; // 更新其左子结点的区间和
        lChild.lazy = cur.lazy; // 传递懒标记(增量标记)
        lChild.updated = true;
        rChild.val = (t - c) * cur.lazy;
        rChild.lazy = cur.lazy;
        rChild.updated = true;
        cur.lazy = 0; // 重置当前结点懒惰标记值（增量标记置0）
        cur.updated = false;
    }
    // 动态开点
    private void addNode(Node node){
        if(node.lChild == null) node.lChild = new Node();
        if(node.rChild == null) node.rChild = new Node();
    }
}
```

<br />

### 小结

本文从基本的静态线段树到动态线段树，介绍了如下内容。

- 通过 **「完全二叉树下标性质」** 和 **「分治算法」** 来理解基本线段树的工作原理。
- 首先实现了支持「单点修改」和「区间查询」的基本线段树，可解决 [307. 区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/) 。
- 引入**「懒惰标记」** 和 **「延迟修改」** 的概念，用以实现 「区间修改」。
- 为解决  [699. 掉落的方块](https://leetcode.cn/problems/falling-squares/) ，再次引出在「树状数组」中介绍过的 **「离散化」** 方法。
- 接着尝试解决  [715. Range 模块](https://leetcode.cn/problems/range-module/) ，并发现该题具有「[强制在线](https://en.wikipedia.org/wiki/Online_algorithm)」的特点，由于无法离散化，迫使我们思考能否实现 **「动态开点」**  (动态创建结点) 的线段树。
- 若能提前估计树的大小，可以  **「结点数组法」** 实现动态开点线段树。
- 通过 **「结点指针 (引用) 法」** 实现的动态开点线段树，无需预估树的大小。

文中我们依次给出了如下八种线段树的完整的类代码。

| 线段树类                             | 描述                                                         |      |
| ------------------------------------ | ------------------------------------------------------------ | ---- |
| 1. $SegmentTreeBasic1$               | 基本静态线段树，不带懒惰标记，只支持单点修改和区间查询，实时维护 $nums$ |      |
| 2. $SegmentTreeBasic2$               | 基本静态线段树，不带懒惰标记，只支持单点修改和区间查询，不维护 $nums$ |      |
| 3. $SegmentTreeAdd$                  | 静态线段树，带懒惰标记，支持单点修改/单点查询/增量式区间修改/区间查询 |      |
| 4. $SegmentTreeUpdate$               | 静态线段树，带懒惰标记，支持单点修改/单点查询/覆盖式区间修改/区间查询 |      |
| 5. $DynamicSegmentTreeArrayAdd$      | 结点数组法动态线段树，带懒惰标记，支持单点修改/单点查询/增量式区间修改/区间查询 |      |
| 6. $DynamicSegmentTreeArrayUpdate$   | 结点数组法动态线段树，带懒惰标记，支持单点修改/单点查询/覆盖式区间修改/区间查询 |      |
| 7. $DynamicSegmentTreePointerAdd$    | 结点指针法动态线段树，带懒惰标记，支持单点修改/单点查询/增量式区间修改/区间查询 |      |
| 8. $DynamicSegmentTreePointerUpdate$ | 结点指针法动态线段树，带懒惰标记，支持单点修改/单点查询/覆盖式区间修改/区间查询 |      |



线段树的应用是十分灵活而强大的，本文只讲解了作者所知的最基本的一些内容，更多的应用已然超出了作者的水平。好在这些内容已基本足够求解力扣上的线段树题目。

<br />

### 实战应用

| 题目                                                         | 难度 | 题解                                                         |
| ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |
| [307. 区域和检索 - 数组可修改](https://leetcode.cn/problems/range-sum-query-mutable/) | 中等 | [题解](https://leetcode.cn/problems/range-sum-query-mutable/solution/yukiyama-by-yukiyama-euo5/) |
| [699. 掉落的方块](https://leetcode.cn/problems/falling-squares/) | 困难 | [题解](https://leetcode.cn/problems/falling-squares/solution/-by-yukiyama-lxtu/) |
| [715. Range 模块](https://leetcode.cn/problems/range-module/) | 困难 | [题解](https://leetcode.cn/problems/range-module/solution/yukiyama-by-yukiyama-lyg5/) |
| ==== 更多题目连夜追加中 ====                                 |      |                                                              |

<br />

## k-d树

k-d树

<br />

## 哈夫曼树

Huffman树

<br />

## 前缀树



<br />

### 后缀树

<br />

## 线索树



<br />

## 实战应用

<br />
