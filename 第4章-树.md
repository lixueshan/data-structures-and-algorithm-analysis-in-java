

# 第4章 - 树

## 基本概念

| 概念     | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 树       | N个节点，N-1条边，除根节点外，其余节点都有且只有一条边指向其父节点。 |
| 根       | 无父亲的节点。                                               |
| 树叶     | 无儿子的节点。                                               |
| 兄弟     | 有相同父亲的节点。                                           |
| 祖父     | 父节点的父节点。                                             |
| 孙子     | 儿子节点的儿子节点。                                         |
| 路径     | 从n1节点到nk节点的节点序列。                                 |
| 路径的长 | n1节点到nk节点路径的边的条数，即路径上节点数减1，k-1。       |
| 深度     | nk节点的深度为根到nk节点的唯一路径的长，根的深度为0，树的深度等于深度最大的树叶的深度，等于该树的高度。<br />x节点的深度：from root to x<br />树的深度：from root to deepest leaf |
| 高度     | nk节点的高度为nk节点到树叶的最长路径的长，所有树叶的高度为0，树的高度等于根的高度。<br />x节点的高度：from deepest leaf to x<br />树的高度：from deepest leaf to root |
| 层       | 根为第1层，树的层数等于树的高度(深度)加1。                   |
| 祖先     | n1到nk 存在路径，n1为nk的祖先，k不等于1时n1为nk的真祖先。    |
| 后裔     | n1到nk 存在路径，nk为n1的后裔，k不等于1时nk为n1的真后裔。    |
| 度       | 节点的度为其子节点个数。<br />叶子节点度为0，二叉树的节点的度不超过2，N个节点的树的度等于N-1，也即边的总数，<br />因为除根节点外每个节点都有且只有一条边连接其父节点。 |
| 树的遍历 | 主要有以下四种遍历方式<br />前序遍历(Pre-order Traversal): 按 根>左>右 的顺序遍历。<br />中序遍历(In-order Traversal): 按 左>根>右 的顺序遍历。<br />后序遍历(Post-order Traversal): 按 左>右>根 的顺序遍。<br />层序遍历(Lever-order Traversal): 按层遍历。 |



## 二叉树

节点至多有两个子节点的树称作二叉树。二叉树是一种简单而应用广泛的数据结构，后续介绍二叉树的各项性质和应用。



### 二叉树的基本概念

| 概念                             | 描述                                                         |
| -------------------------------- | ------------------------------------------------------------ |
| 二叉树(binary tree)              | 每个节点最多只能有两个节点的树。                             |
| 满二叉树(full binary tree)       | 每个节点要么为无儿子的叶子节点，要么拥有两个儿子节点(度为0或2) |
| 完全二叉树(complete binary tree) | 第一种描述：所有位置节点的编号都与完美二叉树对应位置的编号相同的二叉树。<br />第二种描述：去掉最后一层后的树为完美二叉树，且最后一层从左到右有连续的节点。<br />完全二叉树特点：<br />若从上到下从左到右编号所有节点，当根节点编号为1时，编号为i的节点的左儿子编号为2i，右儿子编号为2i+1<br />或者根节点编号为0时，编号为i的节点的左儿子编号为2i+1，右儿子编号为2i+2。 |
| 完美二叉树(perfect binary tree)  | 除最后一层叶子节点外所有层上的节点都有两个儿子节点（度为2）。 |

```
说明：
中文语境下有时满二叉树也被定义为完美二叉树，产生歧义时以英文名称备注说明更好。
根据根节点为0层或1层，深度/高度为0或1的不同设定，树的层数，高度，深度也有歧义：
根为第0层。树的层数为k时（只有根节点的树层数为1），树的高度(深度)为k-1。
根为第1层。树的层数为k时（只有根节点的树层数为1），树的高度(深度)为k。
在具体语境中判断，不必纠结歧义。

N个节点的最大二叉树深度：
树为链状时深度最大，为N-1（根的深度为0）。
```



### 二叉树的性质

| 目标                                                         | 关系表达式                         |
| ------------------------------------------------------------ | ---------------------------------- |
| **1. k层(深度/高度为k-1)完美二叉树节(perfect binary tree)点数为N** |                                    |
| 1-1. k                                                       | k = log(N+1)                       |
| 1-2. N                                                       | N = 2^k - 1                        |
| 1-3. 至k-1层的树的节点数P                                    | P = 2^(k-1) - 1<br />P = (N-1) / 2 |
| 1-4. 第k层节点数Q                                            | Q = 2^(k-1)<br />Q = (N+1) / 2     |
| 1-5. P和Q                                                    | Q = P + 1                          |
| 1-6. P和N                                                    | N = P + Q = 2P + 1                 |
| 1-7. Q和N                                                    | N = P + Q = 2Q - 1                 |
| **2. k层(深度/高度为k-1)完全二叉树(complete binary tree)节点数为N** |                                    |
| 2-1. k                                                       | k = ⌊logN⌋ + 1                     |
| 2-2. N                                                       | 2^(k-1) <= N <= 2^k - 1            |
| 2-3. 上到下左到右从1开始编号，下标为i的节点的左右子节点的下标 | left = 2i  right = 2i + 1          |
| 2-4. 上到下左到右从0开始编号，下标为i的节点的左右子节点的下标 | left = 2i + 1 right = 2i + 2       |
| **3. k层任意二叉树**                                         |                                    |
| 3-1. 第k层最大节点数                                         | 完美二叉树时最大，为2^(k-1)        |
| 3-2. 最大节点总数                                            | 完美二叉树时最大，为2^k - 1        |
| 3-3. 节点度的关系(0度节点个数为n0，1度节点个数为n1，2度节点个数为n2) | n0 = n2 + 1                        |
| 3-4. null链数(节点度为0时null链为2，节点度为1时null链为1，即2n0+n1) | N + 1                              |

```
2-1说明：
  不能表示为⌈logN⌉ 
  因为最后一层只有一个节点时，logN = ⌈logN⌉  = k - 1 (不等于层数k)
  
2-3证明(从1开始编号)：
  设i节点左子节点下标为n，i所在层i之后的节点数为k，将此完全二叉树扩展为完美二叉树后，n所在层n之后的节点数为p
  由完美二叉树性质1-6，有 n + p = 2*(i + k) + 1
  又由完美二叉树定义p - 1为n所在层去掉i的右子节点后的节点数，为上一层k的两倍(k的每一个节点都有两个子节点) p - 1 = 2k
  联立上述两个式子：
  n + p = 2*(i + k) + 1
  p - 1 = 2k
  得 n = 2i
  
3-3证明：
  N = n0 + n1 + n2
  边数为E = 2n2 + n1
  除了根以外所有节点往上有一条边连接父节点，故N与E的关系: N = E + 1，即
    n0 + n1 + n2 = 2n2 + n1 + 1
    n0 = n2 + 1
    
3-4证明：
  方法1: 
  N个节点的二叉树，每个节点均有左右两个链（考虑null链），共2N条链。除根节点外，所有节点都有一个来自其父节点的链指向它，所以一共使用了N-1条链(边)，于是剩下的2N-(N-1)=N+1即为null链的数量。
  
  方法2:
  null链个数为度0节点乘2加度1节点数
  2*n0+n1，由3-3得
  2*n0+n1 = n0+n2+1+n1 = N +1
```



### 表达式树

叶子节点为操作数，其他节点为操作符。

<div align=center>
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1guv1w4aan9j60ea08iaae02.jpg" alt="image-20210927130033275" width="300" />
</div>

对上述表达式树执行中序遍历即可得到日常使用的中缀表达式。

执行后序遍历(左右根)则得到后缀表达式，得到后缀表达式后可利用栈计算表达式的值。

执行前序遍历(根左右)则得到前缀表达式。

例如对`(a+b*c)+((d*e+f)*g)` 执行后序遍历得到后缀表达式`abc*+de*f+g*+`，执行前序遍历得到前缀表达式`++a*bc*+*defg` (不常用)。

后缀表达式在1920年代由波兰数学家引入，因此也称其为[逆波兰表达式](https://zh.wikipedia.org/wiki/%E9%80%86%E6%B3%A2%E5%85%B0%E8%A1%A8%E7%A4%BA%E6%B3%95)(Reverse Polish Notation)。

将一个后缀表达式转变为表达式树：

- 从左到右读取后缀表达式。

- 若遇到数字则将其作为单节点树压入存储树的栈中。

- 若遇到符号则先后弹出树T1和树T2，以该符号为根合并T1和T2成为一棵新树。

- 重复上述操作直到读取结束。

计算前缀表达式（不常用）：

- 从右往左读取前缀表达式。

- 遇到数字压入栈中。

- 遇到运算符号则取出栈顶两个数字(x1, x2)运算后再压回栈中。(除法时为x1/x2，减法时为x1-x2，x1比x2先出栈。)
- 重复上述操作直到读取结束。



## 二叉查找树

对于一棵二叉树，每个节点代表一个数据项，规定节点x的左子树中所有数据项不大于x，而x的右子树中所有的数据项小于x，这样的二叉树即为二叉查找树。对于有n个元素的二叉树，假设树高较平衡，则因其高度为logn的性质，我们将能够通过这样的数据结构实现O(logn)平均时间复杂度的插入，查找和删除等操作。



### 类架构

以下是二叉树查找树类BinarySearchTree的架构。

| 类成员/方法                                            | 描述                                                         |
| ------------------------------------------------------ | ------------------------------------------------------------ |
| **private** BinaryNode<E> root                         | 本类的唯一字段，根节点                                       |
| **public** BinarySearchTree()                          | 无参构造器，将root初始化为null                               |
| **public** **void** makeEmpty()                        | 树置空                                                       |
| **public** **boolean** isEmpty()                       | 判断树是否为空                                               |
| **public** **void** insert(E e)                        | 插入节点驱动方法                                             |
| **public** **void** remove(E e)                        | 删除节点驱动方法                                             |
| **public** E findMin()                                 | 查找最小节点驱动方法                                         |
| **public** E findMax()                                 | 查找最大节点驱动方法                                         |
| **public** **boolean** contains(E e)                   | 判断是否包含指定元素驱动方法                                 |
| **public** **void** printTree()                        | 中序遍历打印树的驱动方法                                     |
| **public** **int** size()                              | 求树的节点个数驱动方法                                       |
| **private** BinaryNode<E> insert(E e, BinaryNode<E> t) | 插入节点<br />递归地比较待插入元素e和当前节点t的element的大小。<br />总能在某个叶子节点插入e(以左子节点或右子节点的角色)。<br />最终总是返回root(空树时返回null) |
| **private** BinaryNode<E> remove(E e, BinaryNode<E> t) | 删除节点(懒惰删除)<br />最终总是返回root(空树时返回null)     |
| **private** BinaryNode<E> findMin(BinaryNode<E> t)     | 返回树的最小节点(递归方式)                                   |
| **private** BinaryNode<E> findMax(BinaryNode<E> t)     | 返回树的最大节点(循环方式)                                   |
| **private** **boolean** contains(E e, BinaryNode<E> t) | 判断树中是否有指定元素的节点                                 |
| **private** **void** printTree(BinaryNode<E> t)        | 中序遍历打印树                                               |
| **private** **int** height(BinaryNode<E> t)            | 返回以t为根节点的树的高度                                    |
| **private** **int** size(BinaryNode<E> t)              | 递归地遍历树的所有节点，返回节点总数                         |

以下是二叉树节点嵌套类BinaryNode的架构。

| 类成员/方法                                                  | 描述                   |
| ------------------------------------------------------------ | ---------------------- |
| **public** E element                                         | 字段，本节点数据       |
| **public** BinaryNode<E> left                                | 字段，本节点的左子节点 |
| **public** BinaryNode<E> right                               | 字段，本节点的右子节点 |
| **public** BinaryNode(E element)                             | 构造器                 |
| **public** BinaryNode(E element, BinaryNode<E> left, BinaryNode<E> right) | 构造器                 |



### 主要方法

#### insert

插入节点操作由插入驱动方法`public void insert(E e)`和具体插入方法`private BinaryNode<E> insert(E e, BinaryNode<E> t)`完成，将element为e的节点插入到当前二叉树中并使得插入后仍保持查找树性质。

递归地比较待插入元素e和当前节点t的element的大小，最后e总能作为某个叶子节点被插入到满足查找树性质的位置。

对于具体插入方法，当原树为null时返回`BinaryNode<>(e,null, null)`给root，即数据为e的节点作为根节点插入。当原树不为null时，在插入后返回原根。

```java
public void insert(E e) {
    // 传入root，从e.compareTo(root.element)比较开始
    root = insert(e, root);
}
private BinaryNode<E> insert(E e, BinaryNode<E> t){
    // 原树是空树时(即一开始root == null)，返回给root，即root等于该插入节点
    // 不空时，总能递进到一个t.left == null 或 t.right == null，e返回为该t的左or右子节点，
    // 然后递归地返回，最终返回到root，使得驱动方法中的root = root（原根不变）。
    if(t == null) {
        return new BinaryNode<>(e,null, null);
    }
    int compareRes = e.compareTo(t.element);
    if(compareRes < 0) {
        t.left = insert(e, t.left); // 递进直到t.left == null
    }
    else if(compareRes > 0){
        t.right = insert(e, t.right); // 递进直到t.right == null
    }
    // 等于时不插入(以该树只能存放不同的元素为前提)
  
    return t;
}
```



#### findMin/findMax

查找具有最小/最大数据的节点的操作由驱动方法`public E findMin() / public E findMax()`和具体方法`private BinaryNode<E> findMin(BinaryNode<E> t) / private BinaryNode<E> findMax(BinaryNode<E> t)`实现。

根据二叉查找树的性质一直向左/向右寻找即可找到最小/最大值。以下以递归方式实现findMin，以迭代方式实现findMax。

```java
public E findMin() {
    if(isEmpty()) {
        throw new NoSuchElementException();
    }
    return findMin(root).element;
}
/**
 * 返回树的最小节点(递归方式)
 */
private BinaryNode<E> findMin(BinaryNode<E> t){
    if(t == null) {
        return null;
    }
    else if(t.left == null) {
        return t;
    }
    return findMin(t.left);
}

public E findMax(){
    if(isEmpty()) {
        throw new NoSuchElementException();
    }
    return findMax(root).element;
}
/**
 * 返回树的最大节点(循环方式)
 */
private BinaryNode<E> findMax(BinaryNode<E> t){
    if(t == null) {
        return null;
    }
    while(t.right != null) {
        t = t.right;
    }
    return t;
}
```



#### remove

删除节点操作由删除驱动方法`public void remove(E e)`和具体删除方法`private BinaryNode<E> remove(E e, BinaryNode<E> t)`完成，将element为e的节点删除并使得删除后仍保持查找树性质。

递归地寻找element为e的节点t，对其执行懒惰删除。找到时节点t有两种情形：

1. t有左右两个子节点
2. t有一个或没有子节点

情形1时，找到t的右子树中最小节点min，令t.element = min.element，对右子树执行删除min的操作（由于是最小值，故此删除必属于情形2）。

情形2时，根据是否有左子节点，执行此语句`t = (t.left != null) ? t.left : t.right`。有左子节点时`t = t.left`，即用这个做子节点取代t。没有左子节点时`t = t.right`，表示以右子节点取代t（包含右子节点也为空的情形，则此时`t = null`）。

对于具体删除方法，当原树为null时返回t(即root)给root。当原树不为null时，在删除后返回递归地返回到当前根给root（例如当树只有根节点，且删除的就是该根时，root = null）。

```java
public void remove(E e) {
    root = remove(e, root);
}
private BinaryNode<E> remove(E e, BinaryNode<E> t){
    // 直到最底部叶子节点也找不到目标e，递归地返回t直到返回root
    if(t == null) {
        return t;
    }
    int compareRes = e.compareTo(t.element);
    // 如果e小于t.element，则递归地往左子节点寻找
    if(compareRes < 0) {
        t.left = remove(e, t.left);
    }
    // 如果e大于t.element，则递归地往右子节点寻找
    else if(compareRes > 0) {
        t.right = remove(e, t.right);
    }
    // 如果e等于t.element，分两种情况讨论
    // 1： 该t的左右子节点均不为null
    else if(t.left != null && t.right != null) {
        // 1.1 那么先找到t的右子树中最小的节点min，将其值赋予t
        t.element = findMin(t.right).element;
        // 1.2 上述1.1之后min已经被转移到了原t的位置，接着删除原min节点，
        // 从t.right开始寻找并删除min(min即为此时的t.element)
        // 找到的最小节点一定是2.2或2.3情形
        // 此语句实际上就是remove驱动方法中的 root = remove(e, root)，执行对象是右子树
        t.right = remove(t.element, t.right);
    }
    // 2: t有一个子节点不为null或两个都为null
    // 2.1 左子节点不为null，右子节点为null
    // 2.2 左子节点为null，右子节点不为null
    // 2.3 左右子节点均为null
    else {
        // t.left != null为真时即2.1，结果是t = t.left，代表
        // 将t的左子节点取代t，也即删除了原t，其左子节点上移到原t的位置。
        // t.left != null为假时包含2.2和2.3，如果是2.2，则代表将t的右子节点取代t，
        // 也即删除了原t，其右子节点上一到原t的位置。如果是2.3则代表用一个null取代t，
        // 因为这时t.right = null，因此可以写成如下。
        t = (t.left != null) ? t.left : t.right;
    }
    return t;
}
```



#### contains

寻找树中是否包含element为e的节点的操作由驱动方法`public boolean contains(E e)`和具体方法`private boolean contains(E e, BinaryNode<E> t)`实现。根据二叉查找树的性质以递归方式一直向左/向右寻找。找到返回true，否则返回false。

```java
public boolean contains(E e) {
    return contains(e, root);
}
private boolean contains(E e, BinaryNode<E> t) {
    if(t == null) {
        return false;
    }
    int compareRes = e.compareTo(t.element);
    if(compareRes < 0) {
        return contains(e, t.left);
    }
    else if(compareRes > 0) {
        return contains(e, t.right);
    }
    else {
        return true;
    }
}
```



#### 复杂度

二叉查找树的平均深度为O(logn)，因此上述介绍的主要方法平均时间复杂度均为O(logn)。当方法总是在一开始的位置就能完成时，时间复杂度最佳，为O(1)，当树为链状时，退化为链表形式，达到最坏时间复杂度O(n)。若方法以递归实现，则空间复杂度取决于递归深度O(logn)，若以迭代方式实现则空间复杂度为O(1)。

| 方法            | 最好时间 | 平均时间 | 最坏时间 | 空间             | 备注                       |
| --------------- | -------- | -------- | -------- | ---------------- | -------------------------- |
| insert          | O(1)     | O(logn)  | O(n)     | O(logn)          | 空间消耗为递归深度         |
| findMin/findMax | O(1)     | O(logn)  | O(n)     | O(logn)  or O(1) | 空间消耗为取决于递归或迭代 |
| remove          | O(1)     | O(logn)  | O(n)     | O(logn)          | 空间消耗为递归深度         |
| contains        | O(1)     | O(logn)  | O(n)     | O(logn)          | 空间消耗为递归深度         |



### 类的完整代码

```java
/**
 * 二叉查找树类 BinarySerchTree
 */
class BinarySearchTree<E extends Comparable<? super E>>{
    // 唯一的字段，根节点
    private BinaryNode<E> root;
    
    /**
     * 无参构造器，root初始化为null
     */
    public BinarySearchTree() {
        root = null;
    }
    /**
     * 树置空
     */
    public void makeEmpty() {
        root = null;
    }
    /**
     * 判断树是否为空
     */
    public boolean isEmpty() {
        return root == null;
    }
    /**
     * 插入节点驱动方法
     */
    public void insert(E e) {
     // 传入root，从e.compareTo(root.element)比较开始
        root = insert(e, root);
    }
    /**
     * 删除节点驱动方法
     */
    public void remove(E e) {
        root = remove(e, root);
    }
    /**
     * 查找最小节点驱动方法
     */
    public E findMin() {
        if(isEmpty()) {
            throw new NoSuchElementException();
        }
        return findMin(root).element;
    }
    /**
     * 查找最大节点驱动方法
     */
    public E findMax(){
        if(isEmpty()) {
            throw new NoSuchElementException();
        }
        return findMax(root).element;
    }
    /**
     * 判断是否包含指定元素驱动方法
     */
    public boolean contains(E e) {
        return contains(e, root);
    }
    /**
     * 中序遍历打印树的驱动方法
     */
    public void printTree(){
        if(isEmpty()) {
            System.out.println("Emtpy tree");
        }
        else {
            printTree(root);
        }
    }
    /**
     * 求树的节点个数驱动方法
     */
    public int size() {
        return size(root);
    }
    
    /**
     * 求树的高度的驱动方法
     */
    public int height() {
        return height(root);
    }
    /**
     * 插入节点
     * 递归地比较待插入元素e和当前节点t的element的大小。
     * 总能在某个叶子节点插入e(以左子节点或右子节点的角色)。
     * 最终总是返回root(空树时返回null)
     */
    private BinaryNode<E> insert(E e, BinaryNode<E> t){
        // 原树是空树时(即一开始root == null)，返回给root，即root等于该插入节点
        // 不空时，总能递进到一个t.left == null 或 t.right == null，e返回为该t的左or右子节点，
        // 然后递归地返回，最终返回到root，使得驱动方法中的root = root（原根不变）。
        if(t == null) {
            return new BinaryNode<>(e,null, null);
        }
        int compareRes = e.compareTo(t.element);
        if(compareRes < 0) {
            t.left = insert(e, t.left); // 递进直到t.left == null
        }
        else if(compareRes > 0){
            t.right = insert(e, t.right); // 递进直到t.right == null
        }
        // 等于时不插入(以该树只能存放不同的元素为前提)
      
        return t;
    }
    /**
     * 删除节点(懒惰删除)
     * 最终总是返回root(空树时返回null)
     */
    private BinaryNode<E> remove(E e, BinaryNode<E> t){
        // 直到最底部叶子节点也找不到目标e，递归地返回t直到返回root
        if(t == null) {
            return t;
        }
        int compareRes = e.compareTo(t.element);
        // 如果e小于t.element，则递归地往左子节点寻找
        if(compareRes < 0) {
            t.left = remove(e, t.left);
        }
        // 如果e大于t.element，则递归地往右子节点寻找
        else if(compareRes > 0) {
            t.right = remove(e, t.right);
        }
        // 如果e等于t.element，分两种情况讨论
        // 1： 该t的左右子节点均不为null
        else if(t.left != null && t.right != null) {
            // 1.1 那么先找到t的右子树中最小的节点min，将其值赋予t
            t.element = findMin(t.right).element;
            // 1.2 上述1.1之后min已经被转移到了原t的位置，接着删除原min节点，
            // 从t.right开始寻找并删除min(min即为此时的t.element)
            // 找到的最小节点一定是2.2或2.3情形
            t.right = remove(t.element, t.right); // 此语句实际上就是remove驱动方法中的 root = remove(e, root)，执行对象是右子树
        }
        // 2: t有一个子节点不为null或两个都为null
        // 2.1 左子节点不为null，右子节点为null
        // 2.2 左子节点为null，右子节点不为null
        // 2.3 左右子节点均为null
        else {
            // t.left != null为真时即2.1，结果是t = t.left，代表
            // 将t的左子节点取代t，也即删除了原t，其左子节点上移到原t的位置。
            // t.left != null为假时包含2.2和2.3，如果是2.2，则代表将t的右子节点取代t，
            // 也即删除了原t，其右子节点上一到原t的位置。如果是2.3则代表用一个null取代t，
            // 因为这时t.right = null，因此可以写成如下。
            t = (t.left != null) ? t.left : t.right;
        }
        return t;
    }
    /**
     * 返回树的最小节点(递归方式)
     */
    private BinaryNode<E> findMin(BinaryNode<E> t){
        if(t == null) {
            return null;
        }
        else if(t.left == null) {
            return t;
        }
        return findMin(t.left);
    }
    /**
     * 返回树的最大节点(循环方式)
     */
    private BinaryNode<E> findMax(BinaryNode<E> t){
        if(t == null) {
            return null;
        }
        while(t.right != null) {
            t = t.right;
        }
        return t;
    }
    /**
     * 判断树中是否有指定元素的节点
     */
    private boolean contains(E e, BinaryNode<E> t) {
        if(t == null) {
            return false;
        }
        int compareRes = e.compareTo(t.element);
        if(compareRes < 0) {
            return contains(e, t.left);
        }
        else if(compareRes > 0) {
            return contains(e, t.right);
        }
        else {
            return true;
        }
    }
    /**
     * 中序遍历打印树
     */
    private void printTree(BinaryNode<E> t) {
        if(t != null) {
            printTree(t.left);
            System.out.println(t.element);
            printTree(t.right);
        }
    }
    /**
     * 返回以t为根节点的树的高度
     */
    private int height(BinaryNode<E> t) {
        if(t == null) {
            return -1;
        }
        else {
            return 1 + Math.max(height(t.left), height(t.right));
        }
    }
    /**
     * 递归地遍历树的所有节点，返回节点总数
     */
    private int size(BinaryNode<E> t) {
        if(t != null) {
            if(t.left != null && t.right != null) {
                return 1 + size(t.left) + size(t.right);
            }
            else {
                return t.left != null ? 1 + size(t.left) : 1 + size(t.right);
            }
        }
        return 0;
    }
    /**
     * 二叉树节点嵌套类
     */
    private static class BinaryNode<E>{
        public E element;
        public BinaryNode<E> left;
        public BinaryNode<E> right;
        
        @SuppressWarnings("unused")
        public BinaryNode(E element){
            this(element, null, null);
        }
        public BinaryNode(E element, BinaryNode<E> left, BinaryNode<E> right){
            this.element = element;
            this.left = left;
            this.right = right;
        }
    }
}
```



## AVL树

对于二叉查找树插入/删除/查找等操作，保持O(logn)复杂度的前提是保持树的平衡，即保持树的深度为logn。在前述二叉查找树的删除操作中，我们总是将目标节点右子树中的最小节点删除，多次删除操作后将使树呈现左高右低的倾向。对这种非平衡的树的操作将无法达到O(logn)的复杂度，因此需要想办法保持在对树进行操作后总使其保持平衡。由此引出平衡查找树，即要求任何节点的深度不能过大。AVL树即是一种自平衡二叉查找树。

AVL(Adelson-Velsky and Landis Tree)树，作为最早的自平衡二叉查找树，由G.M. Adelson-Velsky 和E.M. Landis于1962年的[论文](https://zhjwpku.com/assets/pdf/AED2-10-avl-paper.pdf)中首次介绍。AVL树以“旋转(rotation)”调整保证任意节点的左右子树高度差不超过1，使得树的深度总保持为O(logn)。

![image-20220216132615391](/Users/lixueshan/Library/Application%20Support/typora-user-images/image-20220216132615391.png)



### 类架构

以下是AVL查找树类AvlTree的架构。

| 类成员/方法                                                  | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| **private** AvlNode<E> root                                  | 字段，AVL树的根节点                                          |
| **private** **static** **final** **int** *ALLOWED_IMBALANCE* = 1 | 常量字段，树(或者说节点)的失衡判定值，大于此值则失衡         |
| **public** AvlTree()                                         | 无参构造器，root初始化为null                                 |
| **public** **void** makeEmpty()                              | 树置空                                                       |
| **public** **boolean** isEmpty()                             | 判断树是否为空                                               |
| **public** **void** insert(E e)                              | 插入节点驱动方法                                             |
| **public** **void** remove(E e)                              | 删除节点驱动方法                                             |
| **public** E findMin()                                       | 查找最小节点驱动方法                                         |
| **public** E findMax()                                       | 查找最大节点驱动方法                                         |
| **public** **boolean** contains(E e)                         | 判断是否包含指定元素驱动方法                                 |
| **public** **void** printTree()                              | 按中序遍历打印树的驱动方法                                   |
| **public** **int** size()                                    | 求树的节点个数驱动方法                                       |
| **public** **void** checkBalance()                           | 树平衡检查驱动方法                                           |
| **private** AvlNode<E> balance(AvlNode<E> t)                 | 调整t节点处的平衡，并返回t。<br />如果t失去平衡，根据其失衡的情况，执行如下四种情形之一的旋转调整。<br />左外情形，对t执行左单旋转 rotateWithLeftChild<br />左内情形，对t执行左双旋转 doubleRotateWithLeftChild<br />右外情形，对t执行右单旋转 rotateWithRightChild<br />右内情形，对t执行右双旋转 doubleRotateWithRightChild |
| **private** AvlNode<E> insert(E e, AvlNode<E> t)             | 插入节点<br />递归地比较待插入元素e和当前节点t的element的大小。<br />总能在某个叶子节点插入e(以左子节点或右子节点的角色)。<br />最终总是返回root(空树时返回null)。<br />返回时调用balance(t)，调整插入t后t处的平衡后，返回t。 |
| **private** AvlNode<E> remove(E e, AvlNode<E> t)             | 删除节点(懒惰删除)<br />返回时调用balance(t)，调整删除t后t处的平衡后，返回t(新t)。 |
| **private** AvlNode<E> findMin(AvlNode<E> t)                 | 返回树的最小节点                                             |
| **private** AvlNode<E> findMax(AvlNode<E> t)                 | 返回树的最大节点                                             |
| **private** **boolean** contains(E e, AvlNode<E> t)          | 判断树中是否有指定元素的节点                                 |
| **private** **void** printTree(AvlNode<E> t)                 | 中序遍历打印树                                               |
| **private** **int** height(AvlNode<E> t)                     | 返回以t为根节点的树的高度                                    |
| **private** **int** size(AvlNode<E> t)                       | 递归地遍历所有节点，返回节点总数                             |
| **private** **int** checkBalance(AvlNode<E> t)               | 检查树是否平衡，不平衡打印“imbalance”，并返回树高度          |
| **private** AvlNode<E> rotateWithLeftChild(AvlNode<E> k2)    | 左外单旋转                                                   |
| **private** AvlNode<E> rotateWithRightChild(AvlNode<E> k1)   | 右外单旋转                                                   |
| **private** AvlNode<E> doubleRotateWithLeftChild(AvlNode<E> k3) | 左内双旋转                                                   |
| **private** AvlNode<E> doubleRotateWithRightChild(AvlNode<E> k1) | 右内双旋转                                                   |

以下为AVL树节点嵌套类AvlNode的架构。

| 类成员/方法                                                  | 描述                   |
| ------------------------------------------------------------ | ---------------------- |
| **public** E element                                         | 字段，本节点元素       |
| **public** AvlNode<E> left                                   | 字段，本节点的左子节点 |
| **public** AvlNode<E> right                                  | 字段，本节点的右子节点 |
| **public** **int** height                                    | 字段，该节点的高度     |
| **public** AvlNode(E theElement)                             | 构造器                 |
| **public** AvlNode(E element, AvlNode<E> left, AvlNode<E> right) | 构造器                 |



### 主要方法



### 类的完整代码

```java
class AvlTree<E extends Comparable<? super E>>{
    private AvlNode<E> root;
    private static final int ALLOWED_IMBALANCE = 1;
    
    /**
     * 无参构造器，root初始化为null
     */
    public AvlTree() {
        root = null;
    }
    /**
     * 树置空
     */
    public void makeEmpty() {
        root = null;
    }
    /**
     * 判断树是否为空
     */
    public boolean isEmpty() {
        return root == null;
    }
    /**
     * 插入节点驱动方法
     */
    public void insert(E e) {
     // 传入root，从e.compareTo(root.element)比较开始
        root = insert(e, root);
    }
    /**
     * 删除节点驱动方法
     */
    public void remove(E e) {
        root = remove(e, root);
    }
    /**
     * 查找最小节点驱动方法
     */
    public E findMin() {
        if(isEmpty()) {
            throw new NoSuchElementException();
        }
        return findMin(root).element;
    }
    /**
     * 查找最大节点驱动方法
     */
    public E findMax(){
        if(isEmpty()) {
            throw new NoSuchElementException();
        }
        return findMax(root).element;
    }
    /**
     * 判断是否包含指定元素驱动方法
     */
    public boolean contains(E e) {
        return contains(e, root);
    }
    /**
     * 按中序遍历打印树的驱动方法
     */
    public void printTree(){
        if(isEmpty()) {
            System.out.println("Emtpy tree");
        }
        else {
            printTree(root);
        }
    }
    /**
     * 按树状图形打印树的驱动方法
     * TODO
     */
    public void printTreeGraph(){
        // TODO
    }
    /**
     * 求树的节点个数驱动方法
     */
    public int size() {
        return size(root);
    }
    /**
     * 树平衡检查驱动方法
     */
    public void checkBalance() {
        checkBalance(root);
    }
    
    /**
     * 调整t节点处的平衡，并返回t
     * 如果t失去平衡，根据其失衡的情况，执行如下四种情形之一的旋转调整
     * 左外情形，对t执行左单旋转 rotateWithLeftChild
     * 左内情形，对t执行左双旋转 doubleRotateWithLeftChild
     * 右外情形，对t执行右单旋转 rotateWithRightChild
     * 右内情形，对t执行右双旋转 doubleRotateWithRightChild
     */
    private AvlNode<E> balance(AvlNode<E> t){
        if(t == null) {
            return t;
        }
        // 如果t节点的左子树高于右子树且高差超过设置的失衡值，则对t执行左旋转操作
        if(height(t.left) - height(t.right) > ALLOWED_IMBALANCE) {
            // 如果该左子树的左子树高于或等于其右子树，属于左外情形，对t执行一次左单旋转
            if(height(t.left.left) >= height(t.left.right)){
                t = rotateWithLeftChild(t);
            }
            // 否则属于左内情形，对t执行一次左双旋转
            else {
                t = doubleRotateWithLeftChild(t);
            }
        } 
        // 如果t节点的右子树高于左子树且高差超过设置的失衡值，则对t执行右旋转操作
        else if(height(t.right) - height(t.left) > ALLOWED_IMBALANCE){
            // 如果该右子树的右子树高于或等于其左子树，属于右外情形，对t执行一次右单旋转
            if(height(t.right.right) >= height(t.right.left)) {
                t = rotateWithRightChild(t);
            }
            // 否则属于右内情形，对t执行一次右双旋转
            else {
                t = doubleRotateWithRightChild(t);
            }
        }
        // 更新t为根节点的树的高度
        t.height = Math.max( height( t.left ), height( t.right ) ) + 1;
        return t;
    }
    
    /**
     * 插入节点
     * 递归地比较待插入元素e和当前节点t的element的大小。
     * 总能在某个叶子节点插入e(以左子节点或右子节点的角色)。
     * 最终总是返回root(空树时返回null)
     * 返回时调用balance(t)，调整插入t后t处的平衡后，返回t
     */
    private AvlNode<E> insert(E e, AvlNode<E> t){
        // 最终一定在插入位置上插入一个element为e的BinaryNode
        // 原树是空树时(即一开始root == null)，返回给root
        // 原空时，总能递进到一个叶子节点，e返回为该叶子节点的左or右子节点，
        // 然后递归地返回给父节点，最终返回到root
        if(t == null) {
            return new AvlNode<>(e,null, null);
        }
        int compareRes = e.compareTo(t.element);
        if(compareRes < 0) {
            t.left = insert(e, t.left);
        }
        else if(compareRes > 0){
            t.right = insert(e, t.right);
        }
        // 等于时不插入(以该树只能存放不同的元素为前提)
        else 
            ;
        return balance(t);
    }
    /**
     * 删除节点(懒惰删除)
     * 返回时调用balance(t)，调整删除t后t处的平衡后，返回t(新t)
     */
    private AvlNode<E> remove(E e, AvlNode<E> t){
        // 直到最底部叶子节点也找不到目标e，递归地返回t直到返回root
        if(t == null) {
            return t;
        }
        int compareRes = e.compareTo(t.element);
        // 如果e小于t.element，则递归地往左子节点寻找
        if(compareRes < 0) {
            t.left = remove(e, t.left);
        }
        // 如果e大于t.element，则递归地往右子节点寻找
        else if(compareRes > 0) {
            t.right = remove(e, t.right);
        }
        // 如果e等于t.element，分两种情况讨论
        // 1： 该t的左右子节点均不为null
        else if(t.left != null && t.right != null) {
            // 1.1 那么先找到t的右子树中最小的节点min，将其值赋予t
            t.element = findMin(t.right).element;
            // 1.2 上述1.1之后min已经被转移到了原t的位置，所以删除原min节点，
            // 从t.right开始寻找并删除min(min即为此时的t.element)，可以写成如下
            t.right = remove(t.element, t.right);
        }
        // 2: 该t有一个子节点不为null或两个都为null
        // 2.1 左子节点不为null，右子节点为null
        // 2.2 左子节点为null，右子节点不为null
        // 2.3 左右子节点均为null
        else {
            // t.left != null为真时即2.1，结果是t = t.left，代表
            // 将t的左子节点取代t，也即删除了原t，其左子节点上移到原t的位置。
            // t.left != null为假时包含2.2和2.3，如果是2.2，则代表将t的右子节点取代t，
            // 也即删除了原t，其右子节点上一到原t的位置。如果是2.3则代表用一个null取代t，
            // 也即删除了原t。
            t = (t.left != null) ? t.left : t.right;
        }
        return balance(t);
    }
    /**
     * 返回树的最小节点(递归方式)
     */
    private AvlNode<E> findMin(AvlNode<E> t){
        if(t == null) {
            return null;
        }
        else if(t.left == null) {
            return t;
        }
        return findMin(t.left);
    }
    /**
     * 返回树的最大节点(循环方式)
     */
    private AvlNode<E> findMax(AvlNode<E> t){
        if(t == null) {
            return null;
        }
        while(t.right != null) {
            t = t.right;
        }
        return t;
    }
    /**
     * 判断树中是否有指定元素的节点
     */
    private boolean contains(E e, AvlNode<E> t) {
        if(t == null) {
            return false;
        }
        int compareRes = e.compareTo(t.element);
        if(compareRes < 0) {
            return contains(e, t.left);
        }
        else if(compareRes > 0) {
            return contains(e, t.right);
        }
        else {
            return true;
        }
    }
    /**
     * 中序遍历打印树
     */
    private void printTree(AvlNode<E> t) {
        if(t != null) {
            printTree(t.left);
            System.out.println(t.element);
            printTree(t.right);
        }
    }
    /**
     * 按树状图形打印树
     * TODO
     */
    private void printTreeGraph(AvlNode<E> t, int space) {
        // TODO
    }
    /**
     * 返回以t为根节点的树的高度
     */
    private int height(AvlNode<E> t) {
        // 与BinaryNode的height方法不同，在AvlTree中，每次执行remove或者insert，
        // 都通过balance(t)更新了以t为根节点的树的高度，因此此处只需要t.height即可。
        return t == null ? -1 : t.height;
    }
    /**
     * 递归地遍历所有节点，返回节点总数
     */
    private int size(AvlNode<E> t) {
        if(t != null) {
            if(t.left != null && t.right != null) {
                return 1 + size(t.left) + size(t.right);
            }
            else {
                return t.left != null ? 1 + size(t.left) : 1 + size(t.right);
            }
        }
        return 0;
    }
    /**
     * 检查树是否平衡，不平衡打印“imbalance”，并返回树高度
     */
    private int checkBalance(AvlNode<E> t) {
        if(t == null) {
            return -1;
        }
        int lh = checkBalance(t.left);
        int rh = checkBalance(t.right);
        if(Math.abs(height(t.left) - height(t.right)) > 1
                || height(t.left) != lh || height(t.right) != rh) {
            System.out.println("imbalance");
        }
        return height(t);
    }
    /**
     * 左外单旋转
     * 因k2的左子节点的外侧子树，即k2的左子节点的左子树导致k2失衡。
     * 以Y或者Z的高度为1，则k2的左子树比其右子树高2。
     * 
     *           k2        k1 = k2.left                k1        
     *         /    \      k2.left = k1.right        /     \
     *        k1     /\　  k1.right = k2            /\       k2
     *       /  \   /__\   ============>           /  \     /  \
     *     /\    /\   Z                           /    \   /\   /\
     *    /  \  /__\                             /______\ /__\ /__\
     *   /    \   Y                                 X       Y    Z
     *  /______\
     *      X
     */    
    private AvlNode<E> rotateWithLeftChild(AvlNode<E> k2){
        AvlNode<E> k1 = k2.left;
        k2.left = k1.right;
        k1.right = k2;
        // 调整平衡后更新k1，k2的高度
        k2.height = Math.max(height(k2.left), height(k2.right));
        k1.height = Math.max(height(k1.left), height(k1.right));
        return k1;
    }
    
    /**
     * 右外单旋转
     * 因k1的右子节点的外侧子树，即k1的右子节点的右子树导致k1失衡。
     * 以X或者Y的高度为1，则k1的右子树比其左子树高2。
     * 
     *           k1        k2 = k1.right                k2        
     *         /    \      k1.right = k2.left        /     \
     *       /\      k2　  k2.left = k1             k1      /\ 
     *      /__\    /  \   ============>          /  \     /  \ 
     *       X    /\    /\                      /\   /\   /    \   
     *           /__\  /  \                    /__\ /__\ /______\
     *            Y   /    \                    X     Y      Z
     *               /______\
     *                  Z
     */
    private AvlNode<E> rotateWithRightChild(AvlNode<E> k1){
        AvlNode<E> k2 = k1.right;
        k1.right = k2.left;
        k2.left = k1;
        // 调整平衡后更新k1，k2的高度
        k1.height = Math.max(height(k1.left), height(k1.right));
        k2.height = Math.max(height(k2.left), height(k2.right));
        return k2;
    }
    
    /**
     * 左内双旋转
     * 因k2的左子节点的内侧子树，即k2的左子节点的右子树导致k2失衡。
     * 对k2执行一次左单旋转后仍然在k1处(新根)失衡，因此考虑展开一开始导致失衡的k1右子树，
     * 做如下转换(总是以中序遍历的顺序标注节点，注意k1,k2,k3位置变化)。
     * 因为不知道是B或C中的哪一棵导致失衡(比D深2层)，所以将B，C画成比D深1.5。
     * 依次执行如下两次单旋转后可恢复原失衡处的平衡。
     * 1. 对k1(k3.left)执行右单旋转。
     * 2. 对k3执行左单旋转。
     * 
     *           k2                        k3      
     *         /    \                    /     \    
     *        k1     /\　  转换为        k1      /\ 
     *       /  \   /__\   ====>      /   \    /__\ 
     *     /\    /\   Z             /\     k2    D   
     *    /__\  /  \               /__\   /  \        
     *     X   /    \               A   /\    /\  
     *        /______\                 /  \  /  \ 
     *           Y                    /____\/____\　
     *                                  B      C
     *                         k3                                k2
     *                       /     \                         /        \
     *  对k1执行             k2      /\    对k3执行           K1          K3
     *  一次右单旋转         /    \  /__\   一次左单旋转      /    \       /  \
     *    =====>         k1      /\  D    ====>          /\    /\     /\   /\
     *                 /   \    /  \                    /__\  /　\   / 　\ /__\
     *                /\    /\ /____\                    A   /____\ /____\  D
     *               /__\  /  \  C                             B      C     
     *　　　　         A   /____\　
     *                      B            
     */
    private AvlNode<E> doubleRotateWithLeftChild(AvlNode<E> k3){
        k3.left = rotateWithRightChild(k3.left);
        return rotateWithLeftChild(k3);
    }
    
    /**
     * 右内双旋转          
     */
    private AvlNode<E> doubleRotateWithRightChild(AvlNode<E> k1){
        k1.right = rotateWithLeftChild(k1.right);
        return rotateWithRightChild(k1);
    }
    
    /**
     * AVL树节点嵌套类
     */
    private static class AvlNode<E>{
        public E element;
        public AvlNode<E> left;
        public AvlNode<E> right;
        // 比BinaryNode多维护一个height字段
        // 每次insert或remove一个节点时通过balance方法更新
        public int height;
        
        @SuppressWarnings("unused")
        public AvlNode(E theElement){
            this(theElement, null, null);
        }
        public AvlNode(E element, AvlNode<E> left, AvlNode<E> right){
            this.element = element;
            this.left = left;
            this.right = right;
            this.height = 0;
        }
    }
}
```



## 伸展树

伸展树

## Huffman树

Huffman树

## B树

B树
