# 第6章-优先队列(堆)

以现实中的打印任务引入优先队列的概念。

在打印任务的队列中，总是希望能够优先处理优先级高或耗时较短的任务，之后再处理优先级低或耗时较长的任务。以优先级为例，这需要系统能够知道所有任务的优先级，总是处理当前剩余任务中优先级最高者。将任务以优先队列(也称作"堆")这一数据结构进行安排，可以实现上述场景。

<br />

## 简单的实现

我们要介绍的优先队列以二叉堆(binary heap)实现，但在正式介绍这种优先队列之前，有必要简单探讨一下可以已我们已知的何种数据结构实现优先队列，以便了解为何要以二叉堆来实现它。

优先队列的要求是简单而清晰的，即总是在要处理的对象数据中找到最小者(以最小者优先为例)。考虑最常用的插入操作(insert)和删除最小者操作(deleteMin)，可以使用简单链表和二叉查找树来实现优先队列。

| 实现方式                           | insert复杂度 | deleteMin复杂度 |
| ---------------------------------- | ------------ | --------------- |
| 简单链表<br />* 表头插入，遍历删除 | O(1)         | O(n)            |
| 简单链表<br />* 表头删除，排序插入 | O(n)         | O(1)            |
| 二叉查找树                         | O(logn)      | O(logn)         |

如上表所示，简单链表实现时，若总是在表头插入，通过遍历链表来删除指定元素的话，插入复杂度为O(1)，删除最小元复杂度为O(n)。若在插入时总是保持链表的排序状态，就可以通过删除表头来实现删除最小元操作，此情况下插入复杂度为O(n)，删除最小元复杂度为(n)。另一方面，使用二叉查找树来实现优先队列时，由其树高性质(假设使用平衡的二叉查找树)，可知插入和删除最小元的操作，复杂度均为O(logn)。

为了平衡插入和删除操作的复杂度，二叉查找树是个不错的选择。但二叉查找树能够实现的操作超过了优先队列的需求，例如旋转平衡等操作，我们可以“减弱”对二叉查找树性质的要求，利用所谓满足“堆序”性质的二叉树来实现优先队列，其插入和删除最小元的复杂度同样是O(logn)。

<br />

## 二叉堆

如前述，以弱于二叉查找树的性质的二叉树来实现优先队列，该二叉树满足“堆序”，即每个节点都是以其为根节点的树中最小的节点，与二叉查找树相比，对其左右儿子的相对大小无要求。对于二叉树，我们知道完全二叉树的节点编号满足如下性质。

> 从上到下从左到右编号所有节点，当根节点编号为1时，编号为i的节点的左儿子编号为2i，右儿子编号为2i+1。
>
> 或者根节点编号为0时，编号为i的节点的左儿子编号为2i+1，右儿子编号为2i+2。

完全二叉树从根节点到最后一个节点在编号上是连续的，因此我们可以使用一个数组表示一个二叉堆。因其为完全二叉树，以树的形状表示时像一个“堆”，这也是“堆(heap)”这一名称的由来。

至此，我们得到了以二叉堆实现的优先队列的两个性质。

| 二叉堆(优先队列)性质 | 性质内容                                                     |
| -------------------- | ------------------------------------------------------------ |
| 结构性质             | 二叉堆是一棵完全二叉树，以数组表示。<br />当根节点下标为0时：下标为i的节点，其左儿子下标为2i+1，右儿子下标为2i+2。<br />当根节点下标为1时：下标为i的节点，其左儿子下标为2i，右儿子下标为2i+1。 |
| 堆序性质             | 小顶堆：每个节点都是以其为根节点的树中最小的节点。<br />大顶堆：每个节点都是以其为根节点的树中最大的节点。 |

<br />

### 类架构

以下是二叉堆(优先队列)类的架构。

| 类成员/方法                                        | 描述                                                 |
| -------------------------------------------------- | ---------------------------------------------------- |
| **private** **int** currentSize                    | 字段，当前堆大小                                     |
| **private** E[] array                              | 字段，保存堆元素的数组                               |
| **private static final int DEFAULT_CAPACITY** = 10 | 字段，以无参构造器new对象时的array大小               |
| **public** BinaryHeap()                            | 无参构造器，执行this(DEFAULT_CAPACITY)               |
| **public** BinaryHeap(**int** capacity)            | 有参构造器                                           |
| **public** BinaryHeap(E[] items)                   | 有参构造器                                           |
| **public** **void** clear()                        | 堆置空                                               |
| **public** **int** size()                          | 返回堆大小                                           |
| **public** E[] getHeap()                           | 以数组形式返回堆                                     |
| **public** E element()                             | 返回堆顶元素，堆空时抛出异常                         |
| **public** E peak()                                | 返回堆顶元素，堆空时返回null                         |
| **public** **boolean** contains(E e)               | 堆中包含e时返回true，否则返回false                   |
| **public** **void** add(E e)                       | 插入元素e                                            |
| **public** E remove()                              | 删除堆顶元素并返回它，堆空时抛出异常                 |
| **public** E poll()                                | 删除堆顶元素并返回它，堆空时返回null                 |
| **private** **void** heapify()                     | 将当前array构建成一个堆                              |
| **private** **void** siftUp(**int** hole)          | 上滤操作，用于插入时，将hole位置的插入对象元素上滤   |
| **private** **void** siftDown(**int** hole)        | 下滤操作，用于堆化和删除操作时，将hole位置的元素下滤 |
| **private** **void** grow(**int** newSize)         | 将array大小扩大至newSize                             |

<br />

### 主要方法

#### add

<br />

#### remove

<br />

#### heapify

<br />

#### siftUp

<br />

#### siftDown

<br />

### 类的完整代码

```java

```

<br />

### 测试代码

```java

```

<br />

## d-堆

<br />

## 左式堆

<br />

## 斜堆

<br />

## 二项队列



\## 优先队列的应用



选择问题



\## d-堆



二叉堆的推广，每个节点都有d个儿子节点

d-堆比二叉堆浅，将insert操作的复杂度降低到O(logdN) (d为底)

** 上滤操作，只需要跟父节点对比

但对于deleteMin操作，操作复杂度将会提高到O(dlongdN) (d为底)

** 下滤操作，d个子节点间比较找最小

d-堆在寻找父节点(插入上滤)或子节点(删除最小下滤)时，由于因子d，若d不是2的幂，运行时间将会增加

** 因为无法通过移动1个二进制位来实现乘除

当队列太大无法完全装入主存时，d-堆与B树发挥同样的作用

堆的两个较大的缺点

 无法简单实现find(堆序是一种比较松的限制)

 merge困难

  引入三种支持merge的堆结构 左式堆/斜堆/二项队列



\## 左式堆



零路径长(null path length): 从X到一个不具有两个儿子的节点(包括自身)的最短路径长

npl(null) = -1

则有npl(p) = min(npl(p的左儿子), npl(p的右儿子)) + 1

** 当无儿子节点时，看作是null节点，npl(null) = -1

左式堆(leftist heap): 对于堆中的每一个节点，左儿子的零路径长不小于右儿子的零路径长

![Pasted Graphic_2.png](/blob:file:/40059c0c-e908-41a4-b311-db3af4bac178)

二叉堆(完全二叉树)是一种特殊的左式堆