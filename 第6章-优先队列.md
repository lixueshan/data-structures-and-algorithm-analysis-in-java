# 第6章-优先队列(堆)

以现实中的打印任务引入优先队列的概念。

在打印任务的队列中，总是希望能够优先处理优先级高或耗时较短的任务，之后再处理优先级低或耗时较长的任务。以优先级为例，这需要系统能够知道所有任务的优先级，总是处理当前剩余任务中优先级最高者。将任务以优先队列(也称作"堆")这一数据结构进行安排，可以实现上述场景。

<br />

## 简单的实现

我们要介绍的优先队列以二叉堆(binary heap)实现，但在正式介绍这种优先队列之前，有必要简单探讨一下可以已我们已知的何种数据结构实现优先队列，以便了解为何要以二叉堆来实现它。

优先队列的要求是简单而清晰的，即总是在要处理的对象数据中找到最小者(以最小者优先为例)。考虑最常用的插入操作(insert)和删除最小者操作(deleteMin)，可以使用简单链表和二叉查找树来实现优先队列。

| 实现方式                           | insert复杂度 | deleteMin复杂度 |
| ---------------------------------- | ------------ | --------------- |
| 简单链表<br />* 表头插入，遍历删除 | O(1)         | O(n)            |
| 简单链表<br />* 表头删除，排序插入 | O(n)         | O(1)            |
| 二叉查找树                         | O(logn)      | O(logn)         |

如上表所示，简单链表实现时，若总是在表头插入，通过遍历链表来删除指定元素的话，插入复杂度为O(1)，删除最小元复杂度为O(n)。若在插入时总是保持链表的排序状态，就可以通过删除表头来实现删除最小元操作，此情况下插入复杂度为O(n)，删除最小元复杂度为(n)。另一方面，使用二叉查找树来实现优先队列时，由其树高性质(假设使用平衡的二叉查找树)，可知插入和删除最小元的操作，复杂度均为O(logn)。

为了平衡插入和删除操作的复杂度，二叉查找树是个不错的选择。但二叉查找树能够实现的操作超过了优先队列的需求，例如旋转平衡等操作，我们可以“减弱”对二叉查找树性质的要求，利用所谓满足“堆序”性质的二叉树来实现优先队列，其插入和删除最小元的复杂度同样是O(logn)。

<br />

## 二叉堆

如前述，以弱于二叉查找树的性质的二叉树来实现优先队列，该二叉树满足“堆序”，即每个节点都是以其为根节点的树中最小的节点，与二叉查找树相比，对其左右儿子的相对大小无要求。对于二叉树，我们知道完全二叉树的节点编号满足如下性质。

> 从上到下从左到右编号所有节点，当根节点编号为1时，编号为i的节点的左儿子编号为2i，右儿子编号为2i+1。
>
> 或者根节点编号为0时，编号为i的节点的左儿子编号为2i+1，右儿子编号为2i+2。

完全二叉树从根节点到最后一个节点在编号上是连续的，因此我们可以使用一个数组表示一个二叉堆。因其为完全二叉树，以树的形状表示时像一个“堆”，这也是“堆(heap)”这一名称的由来。

至此，我们得到了以二叉堆实现的优先队列的两个性质。

| 二叉堆(优先队列)性质 | 性质内容                                                     |
| -------------------- | ------------------------------------------------------------ |
| 结构性质             | 二叉堆是一棵完全二叉树，以数组表示。<br />当根节点下标为0时：下标为i的节点，其左儿子下标为2i+1，右儿子下标为2i+2。<br />当根节点下标为1时：下标为i的节点，其左儿子下标为2i，右儿子下标为2i+1。 |
| 堆序性质             | 小顶堆：每个节点都是以其为根节点的树中最小的节点。<br />大顶堆：每个节点都是以其为根节点的树中最大的节点。 |

<br />

### 类架构

以下是二叉堆(优先队列)类的架构。

| 类成员/方法                                        | 描述                                                 |
| -------------------------------------------------- | ---------------------------------------------------- |
| **private** **int** currentSize                    | 字段，当前堆大小                                     |
| **private** E[] array                              | 字段，保存堆元素的数组                               |
| **private static final int DEFAULT_CAPACITY** = 10 | 字段，以无参构造器new对象时的array大小               |
| **public** BinaryHeap()                            | 无参构造器，执行this(DEFAULT_CAPACITY)               |
| **public** BinaryHeap(**int** capacity)            | 有参构造器                                           |
| **public** BinaryHeap(E[] items)                   | 有参构造器                                           |
| **public** **void** clear()                        | 堆置空                                               |
| **public** **int** size()                          | 返回堆大小                                           |
| **public** E[] getHeap()                           | 以数组形式返回堆                                     |
| **public** E element()                             | 返回堆顶元素，堆空时抛出异常                         |
| **public** E peak()                                | 返回堆顶元素，堆空时返回null                         |
| **public** **boolean** contains(E e)               | 堆中包含e时返回true，否则返回false                   |
| **public** **void** add(E e)                       | 插入元素e                                            |
| **public** E remove()                              | 删除堆顶元素并返回它，堆空时抛出异常                 |
| **public** E poll()                                | 删除堆顶元素并返回它，堆空时返回null                 |
| **private** **void** heapify()                     | 将当前array构建成一个堆                              |
| **private** **void** siftUp(**int** hole)          | 上滤操作，用于插入时，将hole位置的插入对象元素上滤   |
| **private** **void** siftDown(**int** hole)        | 下滤操作，用于堆化和删除操作时，将hole位置的元素下滤 |
| **private** **void** grow(**int** newSize)         | 将array大小扩大至newSize                             |

<br />

### 主要方法

#### element

返回堆顶元素的方法。

另有一返回堆顶元素方法peak，二者的区别是，当操作对象堆为空堆时，element将抛出异常，而peak则返回null。

```java
public E element() {
    if(isEmpty()) {
        throw new NoSuchElementException();
    }
    return array[0];
}
```

<br />

#### add

向堆中插入元素e的方法。插入前检查当前节点数量，如果等于array的长度，则调用grow方法将array长度扩大到当前长度的两倍再加1。堆的当前大小currentSize自增1，然后将自增后最后一位作为空穴，将e放入空穴，然后通过上滤的方式将e上滤到满足堆序的位置。上滤方法siftUp在后文中介绍。

```java
public void add(E e) {
    // 每次插入前检查当前节点数，如果等于array.length，
    // 则array扩大一倍再加1
    if(currentSize == array.length) {
        grow(array.length * 2 + 1);
    }
    currentSize++; // 插入的元素导致堆大小+1
    int hole = currentSize - 1; // 空穴下标
    array[hole] = e;
    // 比较e和空穴父节点，每次比较后空穴上滤到父节点处
    siftUp(hole);
}
```

<br />

#### remove

该方法删除堆顶元素并返回该堆顶元素。堆顶删除后堆大小减1，于是可将当前最后一个元素作为堆顶元素，此时只有堆顶不满足堆序，对其执行下滤恢复堆序即可。下滤方法siftDown在后文中介绍。

如下[动图](https://tva1.sinaimg.cn/large/008i3skNgy1gyosplo6zzg30i603nwga.gif)展示了删除大顶堆{9, 8, 5, 6, 7, 2, 4, 1, 3}堆顶元素9的过程（动图中出现的100表示堆顶，值为9）。

<div align=center>
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyosplo6zzg30i603nwga.gif" alt="Kapture 2022-01-23 at 18.46.27" width="500" />
</div>

```java
public E remove() {
    if(isEmpty()) {
        throw new NoSuchElementException();
    }
    E minItem = element();
    // 将此时堆顶用当前最后一个元素代替，并对其执行下滤操作
    array[0] = array[currentSize];
    currentSize--; // 在下滤之前大小要及时更新，自减1，下滤中此值是关键
    siftDown(0); // 此时只有堆顶导致堆失序，下滤后整个堆恢复到堆序

    return minItem;
}
```

另有一删除堆顶元素的方法poll，两者的区别是，使用remove时，若操作对象堆为空，则抛出异常，若使用poll则返回null。

<br />

#### heapify

堆化方法。对最后一个非叶子节点到根节点，依次执行下滤操作(siftDown)。

从最后非一个叶子开始下滤的原因是此节点之后的节点均为叶子节点，叶子节点无子节点，故其本身已满足堆序性质，也就无下滤的必要（无法下滤）。每一次下滤使得该节点及其之后的节点都满足堆序性质，直到根节点。

※ 最后一个非叶子节点（也即最后一个元素的父节点）坐标为currentSize / 2 - 1。

如下[动图](https://tva1.sinaimg.cn/large/008i3skNgy1gyopuk6qs7g30i603ntby.gif)是将输入数组{4, 6, 2, 1, 7, 9, 5, 8, 3}堆化成大顶堆{9, 8, 5, 6, 7, 2, 4, 1, 3}的过程。

<div align=center>
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyopuk6qs7g30i603ntby.gif" alt="Kapture 2022-01-23 at 18.46.27" width="500" />
</div>

```java
private void heapify() {
    for(int i = currentSize / 2 - 1; i >= 0; i--) {
        siftDown(i);
    }
}
```

<br />

#### siftUp

上滤操作，在插入元素操作中，将下标为hole的元素（待插入元素）向上调整，以满足插入后的堆序。hole > 0且hole处元素小于其父节点时才上滤，此时令hole处等于其父节点，然后hole更新为其父节点下标。while结束后hole即为插入位置，令array[hole] = e。

```java
private void siftUp(int hole) {
    E e = array[hole];
    // hole大于0且小于其父节点时才上滤，因为是短路判断，
    // hole > 0才会判断第二个条件，因此第二个条件不会造成数组越界
    while(hole > 0 && e.compareTo(array[(hole - 1) / 2]) < 0) {
        array[hole] = array[(hole - 1) / 2]; // 将父节点向下移入hole
        hole = (hole - 1) / 2; // 更新hole下标（空穴上滤）
    }
    array[hole] = e; // 上滤结束后空穴位置就是插入位置
}
```

<br />

#### siftDown

下滤操作。将hole处的元素下滤到恢复堆序的位置。当array[hole]的较小儿子小于array[hole]时，将该儿子放入hole处，hole更新为该儿子的下标，也即hole下滤到该处。下滤界为堆界，退出while循环时的hole即为下滤目标位置。细节请参考代码注释。

```java
private void siftDown(int hole) {
    int child = hole * 2 + 1; // left child
    E target = array[hole]; // 下滤目标
    while(child < currentSize) { // 下滤界为堆界
        // 满足第一个条件child < currentSize表示hole有右儿子（完全二叉树性质），不满足则hole无右儿子，跳过
        // 第二个条件表示右儿子小于左儿子，两个条件均满足时令child++，使得child为较小的右儿子
        // 短路判断，如果第一个条件不满足，不会执行第二个判断，因此不会溢出
        if(child < currentSize - 1 && array[child + 1].compareTo(array[child]) < 0) {
            child++; // 如果hole有right且比left小，则child++
        }
        // 比较此时较小的儿子child与原hole中的值，若child小，则写入原hole的位置
        if(array[child].compareTo(target) < 0) {
            array[hole] = array[child];
            hole = child;
            child = hole * 2 + 1; // 当然也可以写成child = child * 2
        }
        // 若hole的较小的儿子不小于hole，说明hole已经满足堆序，退出while，下滤结束
        else {
            break;
        }
    }
    array[hole] = target; // 将此时hole处填上原hole的值
}
```

<br />

### 类的完整代码

```java
class BinaryHeap<E extends Comparable<? super E>>{
    private int currentSize; // 当前堆大小（array中的堆元素部分）
    private E[] array;
    private static final int DEFAULT_CAPACITY = 10;
    
    public BinaryHeap() {
        this(DEFAULT_CAPACITY);
    }
    
    /**
     * 构造方法（入参为堆的大小）
     */
    @SuppressWarnings("unchecked")
    public BinaryHeap(int capacity) {
        currentSize = 0;
        array = (E[]) new Comparable[capacity];
    }
    
    /**
     * 构造方法（入参为一非堆化数组）
     * array真实大小设置为 currentSize + 10
     */
    @SuppressWarnings("unchecked")
    public BinaryHeap(E[] items) {
        currentSize = items.length;
        array = (E[]) new Comparable[(currentSize + 2) * 11 / 10];
        for(int i = 0; i < items.length; i++) {
            array[i] = items[i];
        }
        heapify();
    }
    
    /**
     * 堆判空
     */
    public boolean isEmpty() {
        return currentSize == 0;
    }
    
    /**
     * 清空堆
     * 并非真的清空，而是将其大小设置为0 (懒惰方式)
     */
    public void clear() {
        currentSize = 0;
        // array = null; // 加入此条，即真清空
    }
    
    public int size() {
        return currentSize;
    }
    
    public E[] getHeap() {
        return Arrays.copyOf(array, currentSize);
    }
    
    /**
     * 返回堆顶
     * 堆空时抛出异常
     */
    public E element() {
        if(isEmpty()) {
            throw new NoSuchElementException();
        }
        return array[0];
    }
    
    /**
     * 返回堆顶
     * 堆空时返回null
     */
    public E peak() {
        if(isEmpty()) {
            return null;
        }
        return array[0];
    }
    
    /**
     * 判断堆中是否包含e
     */
    public boolean contains(E e) {
        // 短路判断，在空堆情况下不会执行第二个条件，因此不会越界
        if(isEmpty() || array[0].compareTo(e) > 0) {
            return false;
        }
        for (int i = 0; i < currentSize; i++) {
            if(array[i].compareTo(e) == 0) {
                return true;
            }
        }
        return false;
    }
    
    /**
     * 插入节点
     * 以上滤方式插入节点，currentSize先自增1，令hole = currentSize - 1，然后从其父节点处考虑
     * 是否可以将e插入，可以则跟空穴交换，然后更新hole，继续向上比较
     */
    public void add(E e) {
        // 每次插入前检查当前节点数，如果等于array.length，
        // 则array扩大一倍再加1
        if(currentSize == array.length) {
            grow(array.length * 2 + 1);
        }
        currentSize++; // 插入的元素导致堆大小+1
        int hole = currentSize - 1; // 空穴下标
        array[hole] = e;
        // 比较e和空穴父节点，每次比较后空穴上滤到父节点处
        siftUp(hole);
    }
    
    /**
     * 删除堆顶节点并返回它
     * 堆空时抛出异常
     */
    public E remove() {
        if(isEmpty()) {
            throw new NoSuchElementException();
        }
        E minItem = element();
        // 将此时堆顶用当前最后一个元素代替，并对其执行下滤操作
        array[0] = array[currentSize - 1];
        currentSize--; // 在下滤之前大小要及时更新，自减1，下滤中此值是关键
        siftDown(0); // 此时只有堆顶导致堆失序，下滤后整个堆恢复到堆序
        
        return minItem;
    }
    
    /**
     * 删除堆顶节点并返回它
     * 堆空时返回null
     */
    public E poll() {
        if(isEmpty()) {
            return null;
        }
        E minItem = element();
        // 将此时堆顶用当前最后一个元素代替，并对其执行下滤操作
        array[0] = array[currentSize];
        currentSize--; // 在下滤之前大小要及时更新，自减1，下滤中此值是关键
        siftDown(0); // 此时只有堆顶导致堆失序，下滤后整个堆恢复到堆序
        
        return minItem;
    }
    
    /**
     * 将array数组构建为小顶堆
     * 从 currentSize / 2 - 1 开始从倒数第二层倒着调整每一层的堆序，
     * 每完成一层节点的下滤，则该层和以下所有层的堆序是正确的
     */
    private void heapify() {
        for(int i = currentSize / 2 - 1; i >= 0; i--) {
            siftDown(i);
        }
    }
    
    /**
     * 上滤操作
     * 用于插入时，将hole位置的插入对象元素上滤
     */
    private void siftUp(int hole) {
        E e = array[hole];
        while(hole > 0 && e.compareTo(array[(hole - 1) / 2]) < 0) {
            array[hole] = array[(hole - 1) / 2]; // 将父节点向下移入hole
            hole = (hole - 1) / 2; // 更新hole下标（空穴上滤）
        }
        array[hole] = e; // 上滤结束后空穴位置就是插入位置
    }
    
    /**
     * 下滤操作
     * 用于heapify和删除操作时，将hole位置的元素下滤
     */
    private void siftDown(int hole) {
        int child = hole * 2 + 1; // left child
        E target = array[hole]; // 下滤目标
        while(child < currentSize) { // 下滤界为堆界
            // 满足第一个条件child < currentSize表示hole有右儿子（完全二叉树性质），不满足则hole无右儿子，跳过
            // 第二个条件表示右儿子小于左儿子，两个条件均满足时令child++，使得child为较小的右儿子
            // 短路判断，如果第一个条件不满足，不会执行第二个判断，因此不会溢出
            if(child < currentSize - 1 && array[child + 1].compareTo(array[child]) < 0) {
                child++; // 如果hole有right且比left小，则child++
            }
            // 比较此时较小的儿子child与原hole中的值，若child小，则写入原hole的位置
            if(array[child].compareTo(target) < 0) {
                array[hole] = array[child];
                hole = child;
                child = hole * 2 + 1; // 当然也可以写成child = child * 2
            }
            // 若hole的较小的儿子不小于hole，说明hole已经满足堆序，退出while，下滤结束
            else {
                break;
            }
        }
        array[hole] = target; // 将此时hole处填上原hole的值
    }
    
    /**
     * 扩大array
     */
    @SuppressWarnings("unchecked")
    private void grow(int newSize) {
        E[] old = array;
        array = (E[]) new Comparable[newSize];
        for(int i = 0; i < old.length; i++) {
            array[i] = old[i];
        }
    }
    
}
```

<br />

### 测试代码

```java
package com.yukiyama.datastructures;

import java.util.Arrays;
import java.util.NoSuchElementException;
import java.util.PriorityQueue;

public class BinaryHeapDemo {

    public static void main(String[] args) {
        PriorityQueue<Integer> pq = new PriorityQueue<>();
        pq.add(12);pq.add(4);pq.add(6);pq.add(13);pq.add(10);pq.add(7);pq.add(5);
        System.out.println(pq.size());
        System.out.println(Arrays.toString(pq.toArray()));
        System.out.println(pq.element());
        System.out.println(pq.contains(6));
        System.out.println(pq.isEmpty());
        pq.remove();
        System.out.println(Arrays.toString(pq.toArray()));
        
        Integer[] arr = {12, 4, 6, 13, 10, 7, 5};
        BinaryHeap<Integer> heap = new BinaryHeap<>(arr);
        // heap.add(12);heap.add(4);heap.add(6);heap.add(13);heap.add(10);heap.add(7);heap.add(5);
        // 输出7
        System.out.println(heap.size());
        // 输出[4, 10, 5, 13, 12, 7, 6]
        // 有效堆元素从下标0开始到下标currentSize
        System.out.println(Arrays.toString(heap.getHeap()));
        // 输出4
        System.out.println(heap.element());
        // 输出true
        System.out.println(heap.contains(5));
        heap.remove();
        // 输出[5, 10, 6, 13, 12, 7]
        System.out.println(Arrays.toString(heap.getHeap()));
    }

}
```

<br />

## d-堆

<br />

## 左式堆

<br />

## 斜堆

<br />

## 二项队列



\## 优先队列的应用



选择问题



\## d-堆



二叉堆的推广，每个节点都有d个儿子节点

d-堆比二叉堆浅，将insert操作的复杂度降低到O(logdN) (d为底)

** 上滤操作，只需要跟父节点对比

但对于deleteMin操作，操作复杂度将会提高到O(dlongdN) (d为底)

** 下滤操作，d个子节点间比较找最小

d-堆在寻找父节点(插入上滤)或子节点(删除最小下滤)时，由于因子d，若d不是2的幂，运行时间将会增加

** 因为无法通过移动1个二进制位来实现乘除

当队列太大无法完全装入主存时，d-堆与B树发挥同样的作用

堆的两个较大的缺点

 无法简单实现find(堆序是一种比较松的限制)

 merge困难

  引入三种支持merge的堆结构 左式堆/斜堆/二项队列



\## 左式堆



零路径长(null path length): 从X到一个不具有两个儿子的节点(包括自身)的最短路径长

npl(null) = -1

则有npl(p) = min(npl(p的左儿子), npl(p的右儿子)) + 1

** 当无儿子节点时，看作是null节点，npl(null) = -1

左式堆(leftist heap): 对于堆中的每一个节点，左儿子的零路径长不小于右儿子的零路径长

![Pasted Graphic_2.png](/blob:file:/40059c0c-e908-41a4-b311-db3af4bac178)

二叉堆(完全二叉树)是一种特殊的左式堆