# 第7章 - 排序

## 排序分类

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gzd22dpm44j310u0r0tbc.jpg" alt="image-20220214150804185" width="600" />



## 复杂度和稳定性一览

| 十大排序     | 平均                                                   | 最好                               | 最坏                   | 空间     | 稳定性 | 备注                                                         |
| ------------ | ------------------------------------------------------ | ---------------------------------- | ---------------------- | -------- | ------ | ------------------------------------------------------------ |
| 冒泡(bubble) | O(n^2)                                                 | O(n)                               | O(n^2)                 | O(1)     | 稳定   | 输入数组已排序时最好                                         |
| 选择(select) | O(n^2)                                                 | O(n^2)                             | O(n^2)                 | O(1)     | 不稳定 |                                                              |
| 插入(insert) | O(n^2)                                                 | O(n)                               | O(n^2)                 | O(1)     | 稳定   | 输入数组已排序时最好                                         |
| 希尔(shell)  | O(nlogn) ~ O(n^2)<br />O(nlog<sub>3</sub>n) ~ O(n^3/2) | O(nlogn)<br />O(nlog<sub>3</sub>n) | O(n^2)<br />O(n^3/2)   | O(1)     | 不稳定 | 复杂度取决于增量序列<br />上为希尔增量，下为Knuth增量<br />输入数组已排序时最好 |
| 归并(merge)  | O(nlogn)                                               | O(nlogn)                           | O(nlogn)               | O(n)     | 稳定   | 所列复杂度为自顶向下非原地版本<br />自顶向下/自底向上，非原地/原地<br />的时间空间复杂度见详细说明 |
| 快速(quick)  | O(nlogn)                                               | O(nlogn)                           | O(n^2)                 | O(logn)  | 不稳定 | 当输入数组有序，且总是选取<br />第一个元素为主轴时为O(n^2)   |
| 堆(heap)     | O(nlogn)                                               | O(nlogn)                           | O(nlogn)               | O(1)     | 不稳定 | 原地堆排序空间复杂度为O(1)<br />若输入数组所有数字相等，<br />则时间复杂度为O(n) |
| 计数(count)  | O(n + k)                                               | O(n + k)                           | O(n + k)               | O(n + k) | 稳定   | k是计数数组大小<br />应用稳定性优化则稳定，<br />否则不稳定<br />朴素版本空间复杂度为O(k)，<br />稳定性优化版本空间复杂度为O(n + k) |
| 基数(radix)  | O(d(n + k))<br />*k为常数，可写为O(dn)                 | O(d(n + k))<br />*同前             | O(d(n + k))<br />*同前 | O(n + k) | 稳定   | d是最大数位数，k是计数数组大小<br />处理负数时k=19<br />采用稳定的计数排序则稳定，<br />否则不稳定 |
| 桶(bucket)   | O(n)                                                   | O(n)                               | O(n^2) / O(nlogn)      | O(n)     | 稳定   | 稳定性取决于桶内排序是否稳定<br />空间取决于桶使用数组还是容器，<br />若采用数组为O(kn)，容器为O(n)<br />所有元素放入同一个桶时复杂度最大 |



## 三种交换方法

对于冒泡、选择、插入等采用比较和交换元素的排序方法，由于经常执行交换操作，通常将交换动作写为swap方法，需要交换时再调用。最常见swap写法是利用一个临时数tmp来交换arr[i]，arr[j]。也可以通过arr[i]和和arr[j]的加减运算避免临时数tmp的开销，但由于涉及到加减法可能导致数字越界。第三种方法利用位运算中的异或运算，能够避免tmp的开销且不会导致数字越界。

```java
// 方法一: 利用临时数tmp
private void swapWithTmp(int[] arr, int i, int j) {
    int tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}
// 方法二: 利用加减运算
private void swapByCal(int[] arr, int i, int j) {
    arr[i] = arr[i] + arr[j]; // a = a + b
    arr[j] = arr[i] - arr[j]; // b = a - b
    arr[i] = arr[i] - arr[j]; // a = a - b
}
// 方法三: 利用异或运算
private void swapXOR(int[] arr, int i, int j) {
    arr[i] = arr[i] ^ arr[j]; // a = a ^ b，也可写成 arr[i] ^= arr[j];
    arr[j] = arr[i] ^ arr[j]; // b = (a ^ b) ^ b = a ^ (b ^ b) = a ^ 0 = a， 也可写成 arr[j] ^= arr[i];
    arr[i] = arr[i] ^ arr[j]; // a = (a ^ b) ^ a = (a ^ a) ^ b = 0 ^ b = b， 也可写成 arr[i] ^= arr[j];
}
```



## 冒泡排序

### 算法描述

对于要排序的数组，从第一位开始从前往后比较相邻两个数字，若前者大，则交换两数字位置，然后比较位向右移动一位。也就是比较arr[0]和arr[1]，若arr[0] > arr[1]，交换arr[0]和arr[1]。接着比较位移动一位，比较arr[1]和arr[2]，直到比较到arr[M-1]和arr[M] (M = arr.length - 1)。第1轮从前到后的比较将使得最大的数字“冒泡”到最后，此时可以说一个数字已经被排序。每一轮的比较将使得当前未排序数字中的最大者被排序，未排序数字总数减1。第arr.length - 1轮结束后排序完成。

**稳定性：稳定。**

只存在相邻交换，且大小相等时不交换，故大小相等的数字相对位置不变。



### 优化

**提前结束优化**

当某一轮比较均未发生交换，说明排序已完成，可设置一个布尔值记录一轮排序是否有发生交换，若无则提前退出循环结束程序。

**冒泡界优化**

记录前一轮交换的最终位置，说明该位置之后的元素为已排序状态，下一轮的交换只需执行到该处。



### 复杂度分析

时间复杂度：两层for循环，第1轮比较n - 1次(n = arr.length)，最后一轮比较1次。总比较次数为n*(n - 1) / 2次，时间复杂度为O(n^2)。

空间复杂度：算法中只有常数项变量，O(1)。



### 代码

#### 提前结束优化

```java
public int[] bubbleSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // N-1轮次执行，当前N-1个元素排好后，最后一个元素无需执行，故i < arr.length - 1
    for (int i = 0; i < arr.length - 1; i++) {
        // 本轮执行是否有交换的标志，若无则false，若有则true
        boolean swapped = false;
        // 每轮循环，通过依次向右比较两个数，将本轮循环中最大的数放到最右
        for (int j = 1; j < arr.length - i; j++) {
            // 若左大于右则交换，并将swapped置为true
            if (arr[j - 1] > arr[j]) {
                swap(arr, j - 1, j);
                swapped = true;
            }
        }
        // 若无交换，表示当前数组已完全排序，退出大循环
        if (!swapped) {
            break;
        } 
    }
    return arr;
}
```



#### 提前结束+冒泡界优化

```java
public int[] bubbleSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    boolean swapped = true;
    int lastSwappedIdx = arr.length - 1 ;
    int swappedIdx = -1;
    // lastSwappedIdx表示前一轮交换的最终位置，即下标为lastSwappedIdx是未排序部分中的最后一个数的下标，
    // 因此for中的界是i < lastSwappedIdx而不需要写成i <= lastSwappedIdx
    while (swapped) { // 当swapped = false时，排序完成
        // 本轮执行是否有交换的标志，若无则true，若有则false
        swapped = false;
        // 每轮循环，通过依次向右比较两个数，将本轮循环中最大的数放到最右
        for (int i = 0; i < lastSwappedIdx; i++) {
            // 若左大于右则交换，并将swapped置为true
            if (arr[i] > arr[i + 1]) {
                swap(arr, i, i + 1);
                swapped = true;
                swappedIdx = i;
            }
        }
        lastSwappedIdx = swappedIdx;
    }
    return arr;
}
```



## 选择排序

### 算法描述

对于要排序的数组，设置一个minIdx记录最小数字下标。先假设第1个数字最小，此时minIdx = 0，将arr[minIdx]与后续数字逐一比较，当遇到更小的数字时，使minIdx等于该数字下标，第1轮比较将找出此时数组中最小的数字。找到后将minIdx下标的数字与第1个数字交换，此时可以说一个数字已被排序。然后开始第2轮比较，令minIdx = 1，重复上述过程。每一轮的比较将使得当前未排序数字中的最小者被排序，未排序数字总数减1。第arr.length - 1轮结束后排序完成。

在交换前判断下minIdx是否有变化，若无变化则无需交换。当数组大致有序时，能够减少无效交换带来的开销。

**稳定性：不稳定。**

存在跨越交换。找到本轮次最小值之后，将其与本轮起始数字交换，此时若中间有与起始元素同值的元素，将打破稳定性。

例:　7 7 2 。第一轮交换第一个7和2，则两个7位置关系改变。



### 双元选择优化

在遍历寻找最小值下标minIdx时，可以同时寻找最大值下标maxIdx，这样就可以一轮遍历确定两个元素的位置，遍历次数减少一半，但每轮次的操作变多，因此该优化只能少量提升选择排序的速度（复杂度介于单元选择排序复杂度及其一半之间）。



### 复杂度分析

时间复杂度：两层for循环，第1轮比较N - 1次(N = arr.length)，最后一轮比较1次。总比较次数为N*(N - 1) / 2次，时间复杂度为O(N^2)。 双元选择优化版本也是O(N^2)。

冒泡排序和选择排序的比较次数均为O(N^2)，但选择排序的交换次数是O(N)，而冒泡排序的平均交换次数仍然是二次的。

空间复杂度：算法中只有常数项变量，O(1)。



### 代码

#### 单元选择排序

```java
public int[] selectSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // N-1轮次执行,当前N-1个元素排好后，最后一个元素无需执行，故i < arr.length - 1
    for (int i = 0; i < arr.length - 1; i++) {
        int minIdx = i;
        // 找到本轮执行中最小的元素，将最小值下标赋值给min
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIdx])
                minIdx = j;
        }
        // 若本轮第一个数字不是最小值，则交换位置（将最小值与本轮第一个数字交换位置）
        if (minIdx != i) {
            swap(arr, i, minIdx);
        }
    }
    return arr;
}
```



#### 双元选择排序

```java
public int[] selectSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // 每轮确定两个数字，因此界也会动态变化
    for (int i = 0; i < arr.length - 1 - i; i++) {
        int minIdx = i;
        int maxIdx = i;
        // 找到本轮执行中最小和最大的元素
        for (int j = i + 1; j < arr.length - i; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
            if(arr[j] > arr[maxIdx]) {
                maxIdx = j;
            }
        }
        // 若本轮最大值等于最小值，说明未排序部分所有元素相等，无需再排序
        if(minIdx == maxIdx) {
            break;
        }
        // 若本轮第一个数字不是最小值，则交换位置（将最小值与本轮第一个数字交换位置）
        if (minIdx != i) {
            swap(arr, i, minIdx);
        }
        // 在交换i和minIdx时，有可能出现i即maxIdx的情况，此时需要修改maxIdx为minIdx
        if(maxIdx == i) {
            maxIdx = minIdx;
        }
        // 若本轮第一个数字不是最大值，则交换位置（将最大值与本轮最后一个数字交换位置）
        if (maxIdx != i) {
            swap(arr, arr.length - 1 - i, maxIdx);
        }
    }
    return arr;
}
```



## 插入排序

### 算法描述

对于待排序数组，从第2个数字开始，将其称作插入对象数字，将其与之前的元素(称作比较对象)比较，当插入对象小于比较对象时，继续往前比较，直到不小于(≥)比较对象，此时将插入对象插入到该次比较对象之后。重复这个插入过程直到最后一个元素作为插入对象元素完成插入操作。

**稳定性：简单插入和折半插入排序是稳定的。**

对于大小相同的两个数字，简单插入和折半插入均使得后来的数字靠右放置，因此不会改变其相对位置。



### 折半插入优化

注意到插入排序的每一轮向前插入都使得该元素在完成插入后，从第一个元素到该元素是排序状态（指这部分的相对排序状态，他们中间后续可能还会插入其他数字），利用这一点，对一个新的插入对象向前执行折半插入，能够显著减少比较的次数。另一种优化是增量递减插入排序，也叫希尔排序，将在希尔排序章节中介绍。

折半插入的关键在于找到插入位置，折半过程代码如下。while的每一次执行都将使得high/low的位置相比当前center位置左移/右移一位，不难分析出最后一次无法进入while时的high和low的关系一定是high = low - 1。反推上一次能够进入while的情形：

如果上一次进入while后是target < arr[center]，high被更新，high = center - 1，已知当前high = low - 1，说明当前low = center，由于target < arr[center]，插入位置是center（即low），也就是center（low）这个坐标的元素及其右边元素(直到i的左一位)，都要向右移动一位。

如果上一次进入while后是target ≥ arr[center]，low被更新，low = center + 1，已知当前high = low - 1，说明当前high = center，由于target ≥ arr[center]，插入位置是center+1（即low），也就是center+1（low）这个坐标的元素及其右边元素(直到i的左一位)，都要向右移动一位。

以上结果均使得插入位置为当前的low (或当前的high + 1)。

```java
while (low <= high) {
    center = (low + high) / 2;
    if (target < arr[center]) {
        high = center - 1;
    }
    else {
        low = center + 1;
    }
}
```

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz88mmw8qkj30bs07gglu.jpg" alt="image-20220122144208547" width="200" />





### 复杂度分析

时间复杂度：两层for循环，外层总轮次为n - 1轮(n = arr.length)，当原数组逆序时，移动次数为n*(n - 1) / 2次，最坏时间复杂度为O(n^2)，平均时间复杂度同。

当原数组已基本有序时，接近线性复杂度O(n)。例如原数组已完全排序，则算法只需比较n - 1次。

※ 折半插入总的查找(比较)次数为O(nlogn)，但平均移动(每轮移动一半的数字)次数仍是O(n^2)。

空间复杂度：算法中只有常数项变量，O(1)。



### 代码

#### 简单插入排序

```java
public int[] insertSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // N-1轮次执行
    for (int i = 1; i < arr.length; i++) {
        int target = arr[i];
        int j = i - 1;
        for (; j >= 0; j--) {
            if(target < arr[j]) {
                arr[j + 1] = arr[j];
            }
            else {
                break;
            }
        }
        if (j != i - 1) { // j变动表示发生了移动
            arr[j + 1] = target; // 此时的插入对象数字≥j位置的数字，故插入位置为j + 1
        }
    }
    return arr;
}
```



#### 折半插入排序

```java
public int[] insertSortBinary(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // N-1轮次执行
    for (int i = 1; i < arr.length; i++) {
        // 若当前插入对象大于等于前一个对象，无需插入
        if (arr[i - 1] <= arr[i]) {
            continue;
        }
        // 拷贝插入对象元素
        int target = arr[i];
        // 折半查找
        int low = 0;
        int high = i - 1;
        int center = 0;
        // 经过while之后，target要插入的位置为low
        while (low <= high) {
            center = (low + high) / 2;
            if (target < arr[center]) {
                high = center - 1;
            }
            else {
                low = center + 1;
            }
        }
        // 移动
        for (int j = i; j > low; j--) {
            arr[j] = arr[j - 1];
        }
        // 插入
        arr[low] = target;
    }
    return arr;
}
```



## 希尔排序

### 算法描述

希尔排序是简单插入排序的改进，它基于以下事实。

1. 简单插入排序对排序程度较高的序列有较高的效率。假设初始序列已完全排序，则每一轮均只需比较一次，将得到O(n)的线性复杂度，冒泡排序和选择排序做不到这一点，均仍需O(n^2)次比较(冒泡排序在应用提前结束优化后可以做到)。
2. 简单插入排序每次比较最多将数字移动一位，效率较低。

Donald Shell在1959年发表的[论文](http://penguin.ewu.edu/cscd300/Topic/AdvSorting/p30-shell.pdf)中，针对第二点，提出如下方法。对原待排序列中相隔gap的数字执行简单插入排序，然后缩小gap，对新的gap间隔的数字再次执行简单插入排序。以一种规则减少gap的大小，当gap为1时即简单插入排序，因此希尔排序也称作增量递减排序。希尔在论文中提出的增量序列为{1, 2, 4, 8,...}，即2^k，k = 1, 2, 3, ...，在讨论希尔排序时，可将其称为希尔增量。

程序开始时gap较大，待排元素较少，因此排序速度较快。当gap较小时，基于第一点，此时待排序列已大致有序，排序效率接近线性复杂度。因此能够期待希尔排序复杂度将优于O(n^2)。详细见「复杂度分析」。

**稳定性：不稳定。**

gap > 1时，跨越gap的插入可能会改变两个相同值元素的位置关系。例如{0, 1, 4, 3, 3, 5, 6}，当gap = 2时，对{0, 4, 3, 6}简单插入排序后得到{0, 1, 3, 3, 4, 5, 6}，原数组中的两个3的位置互换了。



### 复杂度分析

时间复杂度：希尔排序的时间复杂度与增量序列的选择有关。最优复杂度增量序列尚未明确。

Shell增量(Shell, 1959): {1, 2, 4, 8,...}，即2^k，k = 1, 2, 3, ...，最坏时间复杂度Θ(n^2)。

Hibbard增量(Hibbard, 1963)：{1, 3, 7, 15,...}，即2^k - 1，k = 1, 2, 3, ...，最坏时间复杂度Θ(n^(3/2))。

Knuth增量(Knuth, 1971)：{1, 4, 13, 40,...}，即(3^k - 1) / 2，k = 1, 2, 3, ...，最坏时间复杂度Θ(n^(3/2))。

Sedgewick增量(Sedgewick, 1982): {1, 8, 23, 77, 281}，即4^k + 3*2^(k-1) + 1 (最小增量1直接给出)，k = 1, 2, 3, ...，最坏时间复杂度Θ(n^(4/3))。

复杂度的证明需要借助数论和组合数学，略。

空间复杂度：算法中只有常数项变量，O(1)。



### **逆序数**

希尔排序是较早出现的突破二次复杂度的排序算法，下面从逆序数的角度来直观地说明为何希尔排序能够突破二次复杂度。

在一个排列中，如果任意一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序，一个排列中逆序的总数就称为这个排列的**逆序数**。排序的过程就是不断减少逆序数直到逆序数为0的过程。

回顾冒泡排序和简单插入排序，算法的每一次交换，都只交换相邻元素（简单插入排序中元素每次右移也看作交换），因此每次交换只能减少一个逆序。冒泡排序和简单插入排序的元素平均交换次数均为O(n^2)， 也即逆序数(或逆序数减少次数)为O(n^2)。 如果能跨越多个数字进行交换，则可能一次减少多个逆序。在选择排序中，每轮选到最小元素后的交换即是跨越多个元素的，交换次数(减少逆序数的操作)为O(n)，要少于冒泡和简单插入排序，只是因为比较次数仍是O(n^2)， 所以整体复杂度为O(n^2)。

现在来分析跨越多个元素的交换如何减少逆序数，假设arr[i] > arr[j], i < j。对于任意的arr[k] (i < k < j)：

1. 若arr[k] < arr[j]，交换arr[i]和arr[j]后，三者的逆序数从2变为1
2. 若arr[k] > arr[i]，交换arr[i]和arr[j]后，三者的逆序数从2变为1
3. 若arr[i] > arr[k] > arr[j]，交换arr[i]和arr[j]后，三者的逆序数从3变为0

arr[k] = arr[i]或arr[k] = arr[j]的情况一样，都使得三者逆序数从2变为1，下图省略。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gymsg7ks3hj30no0cy0tu.jpg" alt="image-20220122180949935" width="300" />

对arr[i]和arr[j]的逆序消除，使得逆序至少减少一次，并有机会减少大于一次的逆序(情况3)，因此能够以比n^2低阶的次数消除所有逆序。

实际上归并排序，快速排序，堆排序均实现了长距离交换元素，使得复杂度优于O(n^2)。



### 代码

```java
public int[] shellSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // 初始化gap
    int gap = 1;
    while (gap < arr.length / 3) { // Knuth增量序列
        gap = gap * 3 + 1;
    }
    // 不断缩小gap直到1，对每一个gap值执行一次插入排序
    while (gap > 0) {
        // 注意步长增量是gap
        for (int i = gap; i < arr.length; i += gap) {
            int target = arr[i];
            int j = i - gap;

            for (; j >= 0; j -= gap) { 
                 if (target < arr[j]) {
                     arr[j + gap] = arr[j];
                 } else {
                    break; 
                 }
            }

            if (j != i - gap) {
                arr[j + gap] = target;
            }
        }
        // 缩小gap值
        gap /= 3;
    }
    return arr;
}
```



## 归并排序

### 算法描述

归并排序是一种分治思想的应用，即将原待排数组递归地分为左右两半，直到数组长度为1(递归的基准情形)，然后对从基准情形返回的左右数组进行合并(merge)，在合并中排序。详细过程需结合代码理解，如下动图展示了{4,6,2,1,7,9,5,8,3}的归并排序过程，其中，合并过程采用非原地合并方法，即依次比较两部分已排序数组，将比较结果依次写入新空间中。后续会介绍一种称作原地(in-place)归并排序的改进，使得空间复杂度达到常数级(O(1))。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gymsfclus3g309w0aq1b4.gif" alt="image-20220122180949935" width="250" />

如下树状图中的橙色线表示递归的轨迹。

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gynosiaalbj30ny0qkadk.jpg" alt="image-20220123162943016" width="300" />



**稳定性：稳定。**

合并时的此判断中的等号`if(left[l_next] <= right[r_next])`，保证了出现相等元素时，居左的元素总会被放在左侧，稳定性不受影响。



### 自顶向下和自底向上

可以通过自顶向下(top-down)和自底向上(bottom-up)的方式实现归并排序。

自顶向下(top-down)：从输入数组出发，不断二分该数组，直到数组长度为1，再执行合并。适合用递归实现。

自底向上(bottom-up)：从输入数组的单个元素出发，一一合并，二二合并，四四合并直到数组有序。适合用迭代实现。

后续给出 自顶向下原地 / 自顶向下非原地 / 自底向上原地 / 自底向上非原地 四种代码实现。



### 原地归并

前述归并排序，每一次合并都是将两部分待合并数组的比较结果写入一个与arr等大小的临时数组tmpArr中，写入后再将tmpArr中的合并结果写回到arr中。于是tmpArr的空间开销即为该实现的空间复杂度，为O(n)。实际上，通过一种原地旋转交换的方法（俗称手摇算法/内存反转算法/三重反转算法），则之需要O(1)的辅助空间（由于递归空间为O(logn)，其空间复杂度仍为O(logn)）。以下介绍旋转交换的实现方法。

以b4b5b6a1a2a3序列为例，欲将b4b5b6和a1a2a3交换位置转换为a1a2a3b4b5b6，只需要执行三次旋转即可：

1. 旋转b4b5b6，得到b6b5b4
2. 旋转a1a2a3，得到a3a2a1
3. 旋转b6b5b4a3a2a1得到a1a2a3b4b5b6。

以{1, 2, 4, 6, 7}与{3, 5, 8, 9}的合并为例，观察借助手摇算法实现原地归并的过程。

1. 在{1, 2, 4, 6, 7}中找到第一个大于3的数4，其下标为2，i = 2。index = j = 5。在{3, 5, 8, 9}中找到第一个大于arr[i] = arr[2] = 4的数5，其下标为6，j = 6。
2. 如上操作使得[0, i - 1]必是最小序列，[index, j - 1]必小于arr[i]。因此交换[i, index - 1]和[index, j - 1]（采用三次旋转完成交换）能够使得原右边数组中某一段序列插入到左边数组中，使得这部分序列在整个数组中有序。
3. 交换后，继续执行上述过程，直到不满足该条件(i < j && j <= rightEnd)。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz9ly4o0fxj30dk0kqmyf.jpg" alt="image-20220211153338668" width="200;" />

### 复杂度分析

时间复杂度: O(nlogn)。

自顶向下非原地：

每次减半后的左右两半对应元素的对比(`if(left[l_next] <= right[r_next])`)和赋值(`resArr[res_next++] = `)总是必须的，也即在每一层递归中，比较和赋值的时间复杂度都是O(n)，数组规模减半次数为logn，即递归深度为logn，也即总共需要logn次O(n)的比较和赋值，时间复杂度为O(nlogn)。

也可以这样证明。当n=1时，排序只需常数时间，可以记为1。n个元素的归并排序时间由n/2个元素的归并排序的两倍，再加上将两个n/2大小的已排序数比较及合并的耗时得到。得到如下两个式子。

T(1) = 1

T(n) = 2T(n/2) + n (n是合并的时间)

对第二个式子，左右两边除以n，得到

T(n) / n = T(n/2) / (n/2) + 1

可以不断地将括号内的n除以2，从T(n) / n写到T(1)，得到

T(n) / n = T(n/2) / (n/2) + 1

T(n/2) / (n/2) = T(n/4) / (n/4) + 1

T(n/4) / (n/4) = T(n/8) / (n/8) + 1

...

T(2) / 2 = T(1) / 1 + 1

将上述所有式子相加后，化简得到，T(n) / n =   T(1) / 1 + logn ，即T(n) = n + nlogn，于是复杂度为O(nlogn)。

自顶向下原地：



自底向上非原地：

同自顶向下非原地分析类似，内层for的merge操作总是需要O(n)时间的对比和赋值，外层for的次数为O(logn)，因此时间复杂度为O(nlogn)。

自底向上原地：

对于原地归并排序，~~同样从递归层的角度看，每一层递归深度的所有分区之和为整个数组，对于这些两两合并的分区，整体来看，为了确定i，index和j的位置的比较次数不会超过O(n)，旋转次数至多为O(n/2) +  O(n/2) + O(n) = O(2n)。即左半边全部旋转，右半边全部旋转，然后左右整体再旋转一次。一共logn层递归深度，故时间复杂度为O(nlogn)。~~

根据上述分析，原地归并排序相比非原地版本空间消耗仅为常数级，但其O(nlogn)复杂度的系数相比非原地版本要大，可看作是一种以时间换空间的优化方法。

排序的性能与输入数组的特点无关(例如一个几乎已排序的数组)，最好，最坏，平均时间复杂度均为O(nlogn)。



空间复杂度：

自顶向下非原地归并：递归深度为logn，递归过程中需要一个长度为n的临时数组保存中间结果，空间复杂度为O(n)。

自顶向下原地归并：递归深度为logn，手摇算法仅需O(1)的辅助空间，综合来看空间复杂度为O(logn)。

自底向上非原地归并：迭代过程中需要一个长度为n的临时数组保存中间结果，空间复杂度为O(n)。

自底向上原地归并：手摇算法仅需O(1)的辅助空间，其他空间开销均为常量级，空间复杂度为O(1)。



### 代码

#### 自顶向下非原地归并

```java
public int[] mergeSort(int[] arr) {
    // 先判断是否小于2，小于2直接返回
    if (arr.length < 2) {
        return arr;
    }
    int[] tmpArr = new int[arr.length];
    mergeSort(arr, tmpArr, 0, arr.length - 1);
    return arr;
}

private void mergeSort(int[] arr, int[] tmpArr, int left, int right) {
    if(left < right) {
        int center = (left + right) / 2;
        mergeSort(arr, tmpArr, left, center);
        mergeSort(arr, tmpArr, center + 1, right);
        merge(arr, tmpArr, left, center, right);
    }
}

// 非原地合并方法
private void merge(int[] arr, int[] tmpArr, int leftPos, int leftEnd, int rightEnd) {
    int rightPos = leftEnd + 1;
    int startIdx = leftPos;
    int tmpPos = leftPos;
    while (leftPos <= leftEnd && rightPos <= rightEnd) {
        if (arr[leftPos] <= arr[rightPos]) {
            tmpArr[tmpPos++] = arr[leftPos++];
        }
        else {
            tmpArr[tmpPos++] = arr[rightPos++];
        }
    }
    // 比较完成后若左数组还有剩余，则将其添加到tmpArr剩余空间
    while (leftPos <= leftEnd) {
        tmpArr[tmpPos++] = arr[leftPos++];
    }
    // 比较完成后若右数组还有剩余，则将其添加到tmpArr剩余空间
    while (rightPos <= rightEnd) {
        tmpArr[tmpPos++] = arr[rightPos++];
    }
    // 容易遗漏的步骤，将tmpArr拷回arr中
    // 从小区间排序到大区间排序，大区间包含原来的小区间，需要从arr再对应比较排序到tmpArr中，
    // 所以arr也需要动态更新为排序状态，即随时将tmpArr拷回到arr中
    for(int i = startIdx; i <= rightEnd; i++) {
        arr[i] = tmpArr[i];
    }
}
```



#### 自顶向下原地归并

```java
public int[] mergeSort(int[] arr) {
    // 先判断是否小于2，小于2直接返回
    if (arr.length < 2) {
        return arr;
    }
    mergeSort(arr, 0, arr.length - 1);
    return arr;
}

private void mergeSort(int[] arr, int left, int right) {
    if(left < right) {
        int center = (left + right) / 2;
        mergeSort(arr, left, center);
        mergeSort(arr, center + 1, right);
        merge(arr, left, center, right);
    }
}

/**
 * 原地排序的合并方法
 * 1. 对左右两部分已排序数组，记左数组第一个数下标为i，记右数组第一个数下标为j
 * 2. 找到左数组中第一个大于右数组第一个数字的数，记其下标为i
 * 3. 以一个index暂存右数组第一个元素的下标index = j，找到右数组中第一个大于arr[i]的数，记其下标为j
 * 4. 交换[i, index-1]和[index, j]数字，通过三次翻转实现，翻转[i, index-1]，翻转[index, j]，翻转[i, j]
 * 5. 重复上述过程直到不满足(i < j && j <= rightEnd)
 */
private void merge(int[] arr, int leftPos, int leftEnd, int rightEnd) {
    int i = leftPos;
    int j = leftEnd + 1;
    while(i < j && j <= rightEnd) {
        while(i < j && arr[i] <= arr[j]) {
            i++;
        }
        int index = j;
        while(j <= rightEnd && arr[j] < arr[i]) {
            j++;
        }
        exchange(arr, i, index - 1, j - 1);
    }
}

/**
 * 三次翻转实现交换
 */
private void exchange(int[] arr, int left, int leftEnd, int rightEnd) {
    reverse(arr, left, leftEnd);
    reverse(arr, leftEnd + 1, rightEnd);
    reverse(arr, left, rightEnd);
}

private void reverse(int[] arr, int start, int end) {
    while(start < end) {
        swap(arr, start, end);
        start++;
        end--;
    }
}
```



#### 自底向上非原地归并

```java
public int[] mergeSortBU(int[] arr) {
    // 先判断是否小于2，小于2直接返回
    if (arr.length < 2) {
        return arr;
    }
    int[] tmpArr = new int[arr.length];
    // 间隔，注意不能写成gap < arr.length / 2 + 1，此种写法只适用于元素个数为2的n次幂时
    for(int gap = 1; gap < arr.length; gap *= 2) {
        // 基本分区合并(随着间隔的成倍增长，一一合并，二二合并，四四合并...)
        for(int left = 0; left < arr.length - gap; left += 2 * gap) {
            // 调用非原地合并方法。leftEnd = left+gap-1; rightEnd = left+2*gap-1;
            merge(arr, tmpArr, left, left + gap - 1, Math.min(left + 2 * gap - 1, arr.length - 1));
        }
    }
    return arr;
}
```



#### 自底向上原地归并

```java
public int[] mergeSortBUInPlace(int[] arr) {
    // 先判断是否小于2，小于2直接返回
    if (arr.length < 2) {
        return arr;
    }
    // 间隔，注意不能写成gap < arr.length / 2 + 1，此种写法只适用于元素个数为2的n次幂时
    for(int gap = 1; gap < arr.length; gap *= 2) {
        // 基本分区合并(随着间隔的成倍增长，一一合并，二二合并，四四合并...)
        for(int left = 0; left < arr.length - gap; left += 2 * gap) {
            // 调用原地合并方法。leftEnd = left+gap-1; rightEnd = left+2*gap-1;
            merge(arr, left, left + gap - 1, Math.min(left + 2 * gap - 1, arr.length - 1));
        }
    }
    return arr;
}
```



## 快速排序

### 算法描述

与归并排序一样，快速排序也是一种利用分治思想的排序方法，确定主轴及分区操作是快速排序的核心。首先在数组中确定一个主轴元素(下标记为pivot)，然后将数组分为两部分，小于主轴的放在主轴左侧，大于等于主轴的放在主轴右侧。递归地对主轴左右两侧数组执行这个过程，每次递归都传入待排序数组arr和本次要处理的部分的左右界，只处理这个范围内的序列。当所有递归都到达基准情形时，排序完成。因为是原地交换，递归过程中arr总是在动态排序，递归过程无需返回，为尾递归形式。

详细过程需结合代码理解，如下动图展示了{4,6,2,1,7,9,5,8,3}的快速排序过程（以起始元素为主轴）。

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gynuubbcdpg306q03gdl9.gif" alt="Kapture 2022-01-23 at 18.46.27" width="300" />



**主轴的选择**

1. 主轴为起始元素(quickSortSimple)。每次选取当前数组第一个元素作为主轴。
   - 优点：实现简单。
   - 缺点：若输入是较为有序的数组，pivot总是不能均匀地分割数组。若输入数组本身有序，复杂度退化到O(n^2)。
2. 主轴为随机下标(quickSortRandom)。每次随机选取当前数组的下标，将该下标元素作为主轴。
   - 优点：避免了主轴为起始元素时对于基本有序的输入，因不能均匀分割数组导致复杂度退化的情况。
   - 缺点：随机数的选取本身消耗一定的性能。
3. 主轴为左中右三数居者(quickSortMedian3)。每次比较当前数组起始、中间和末尾三个元素的大小，大小居中者为主轴。
   - 优点：实现相对简单，且有效避免简单快排中的劣质分割。
   - 缺点：三数取中方法消耗一定性能。

快速排序也可以与其他排序相结合，例如当元素较少时使用简单插入排序能够获得更高的排序效率。



**分区方法(partition)**

快速排序中的核心方法为partition。partition方法执行后，要实现主轴左边元素均小于主轴，主轴右边元素均大等于主轴元素。

选定一个数作为主轴后（无论是上述哪种方法选取主轴元素，最后都将选定的主轴置于当前数组的起始位置），设置一个index (index = pivot + 1)动态更新最终的主轴下标。从左到右将主轴后的所有元素依次与主轴元素比较，若小于主轴则将该数字与下标为index的数字交换，index右移一位，使得index的前一位总是当前最后一个小于主轴的元素。遍历比较结束后，交换下标为pivot与index - 1的数字，并将当前主轴的下标index - 1返回。



**稳定性：不稳定。**

partition中在确定了主轴位置后，将一开始设置的主轴元素与最后一个小于主轴的元素x交换时，若中间有与x同值的元素，则稳定性被破坏。

例：7 2 4 4 8 9

partition过后交换7和第二个4，则两个4的位置关系发生变化。



### 非递归快排



### 双轴快排



### 复杂度分析

时间复杂度：平均 / 最好为O(nlogn)，最坏为O(n^2)。

 每次partition主轴均居中，则递归深度为i的partition有2^i个， 这2^i个partition需要比较的次数是 (除去2^(i - 1)个主轴元素的元素个数)n - 2^(i - 1)。给出如下复杂度估计。

Σ(n - 2^(i - 1))  ( i = [1, logn]) = nlogn - (1 - 2^logn) / (1 - logn) = nlogn - (n - 1) / (logn - 1)

可知复杂度为 O(nlogn)。

**最坏情形**

 当输入为已排序数组，第i次partition后主轴左右两部分总是left = null，right = n - i, 第i次partition需要比较n - i次，共有n次partition，总比较次数O(n^2)。类似于对已排序的数组做选择排序。



空间复杂度：递归形式的快排，取决于递归深度，为O(logn)。非递归形式的快排，保存分区信息的栈深度与递归深度相同，所以空间复杂度也是O(logn)。

不同于归并排序中需要借助一个临时数组保存每次合并的结果，快速排序以原地交换元素的形式，避免了O(n)的数组开销。



### 代码

#### 递归快排

```java
/**
 * 三数取中快排
 */
public int[] quickSortMedian3(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // 注意后两个参数是下标值
    quickSortMedian3(arr, 0, arr.length - 1);
    return arr;
}

private void quickSortMedian3(int[] arr, int left, int right) {
      if (left < right) { 
        // 执行median3将左，中，右三数中值放到left位置上
        median3(arr, left, right);
        int partitionIndex = partition(arr, left, right);
        quickSortMedian3(arr, left, partitionIndex - 1);
        quickSortMedian3(arr, partitionIndex + 1, right);
    }
}


/**
 * 三数取中方法
 * 将下标left到下标right的分区中，将left/center/right
 * 三者中的最小者放到当前分区的起始位置
 */
private void median3(int[]arr, int left, int right) {
    int center = (left + right) / 2;
    // 假设arr[left] = a, arr[center] = b, arr[right] = c，第一个if过后a,b中较小者在left位置上
    if (arr[left] > arr[center]) {
        swap(arr, left, center);
    }
    // 前两个if后a,b,c中最小值在left位置上
    if (arr[center] > arr[right]) {
        swap(arr, left, right);
    }
    // 三个if后a,b,c中居中者在center位置上
    if (arr[center] > arr[right]) {
        swap(arr, center, right);
    }
    // 将left, center, right三者的中值置于left位置上
    swap(arr, left, center);
}

/**
 * 随机主轴快排
 */
public int[] quickSortRandom(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    quickSortRandom(arr, 0, arr.length - 1);
    return arr;
}

private void quickSortRandom(int[] arr, int left, int right) {
    if (left < right) {
        // 取区间内随机下标，注意Random().nextInt(int x)方法的使用（含0不含x）
        int randomIndex = new Random().nextInt(right - left + 1) + left;
        // 交换随机取得的下标元素与当前起始元素
        swap(arr, left, randomIndex);
        int partitionIndex = partition(arr, left, right);
        quickSortRandom(arr, left, partitionIndex - 1);
        quickSortRandom(arr, partitionIndex + 1, right);
    }
}

/**
 * 朴素快排(首位为主轴)
 */
public int[] quickSortSimple(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // 注意后两个参数是下标值
    quickSortSimple(arr, 0, arr.length - 1);
    return arr;
}

private void quickSortSimple(int[] arr, int left, int right) {
    // 若left == right，表示此时arr只有一个元素，即为基准情形，完成递归(准确说是完成递进)
    // (尾递归，“回归”过程中不做任何事情）
    if (left < right) {
        int partitionIndex = partition(arr, left, right);
        quickSortSimple(arr, left, partitionIndex - 1);
        quickSortSimple(arr, partitionIndex + 1, right);
    }
}

/**
 * partition方法
 */
private int partition(int[] arr, int left, int right) {
    int pivot = left;
    int index = pivot + 1;
    // 注意此时right是坐标，要执行到最后一个元素，所以是<=
    for (int i = index; i <= right; i++) {
        if (arr[i] < arr[pivot]) {
            swap(arr, index, i);
            index++;
        }
    }
    // 最后一个小于主轴元素的元素下标是index - 1
    swap(arr, pivot, index - 1);
    return index - 1;
}
```



#### 非递归快排

```java

```



#### 双轴快排

```java

```



## 堆排序

### 算法描述

将输入数组建立为一个大顶堆，之后反复取出堆顶并对剩余元素重建大顶堆，将依次取出的堆顶逆序排列，即可将原数组从小到大排列完成排序。

一个直接的想法是在原数组之外新建一个数组保存每次取得的堆顶，这样会有O(n)的空间开销，可以用一种称作“原地堆排序”的技巧避免此开销，具体做法如下。

1. 首先将原待排序数组arr[]建立为一个大顶堆(heapify堆化方法)。
2. 交换堆顶和当前未排序部分中最末尾元素，则堆顶元素已排序（此时在数组最末尾）。
3. 剩余元素中只有当前堆顶（之前被交换的末尾元素）可能造成堆失序，因此只需对堆顶调用一次调整堆序的下滤(siftDown)操作（操作范围为未排序部分），即可恢复未排序部分的堆序。
4. 重复2，3直到所有元素已排序，返回arr[]。

上述通过交换堆顶与当前未排序部分末尾元素的做法，避免了额外的空间开销，即“原地堆排序”。程序结束后返回的arr[]为已排序状态。



**稳定性：不稳定。**

交换可能会破坏稳定性。例：输入数组 {1, 2, 2}，变灰表示已排序。可以看到红2和绿2的相对顺序相比输入已改变。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyozpzv3u0j30sw07amy3.jpg" alt="image-20220124193317369" width="450" />



**堆化方法(heapify)**

将原输入数组看作一棵二叉树。根节点下标为0，于是根据二叉树性质，任意一个节点(下标为i)的左子节点下标为2 * i + 1，右子节点下标为 2 * i + 2，父节点坐标为i / 2。堆化过程即使得整棵树满足堆序性质，也即任意一个节点大于等于其子节点（大顶堆）。堆化操作总结为一句话就是：对最后一个非叶子节点到根节点，依次执行下滤操作(siftDown)。如下是将输入数组{4, 6, 2, 1, 7, 9, 5, 8, 3}堆化成大顶堆{9, 8, 5, 6, 7, 2, 4, 1, 3}的过程。

最后一个非叶子节点（也即最后一个元素的父节点）坐标为(len - 1) / 2，len为数组长度。从最后非一个叶子开始下滤的原因是此节点之后的节点均为叶子节点，无子节点，也就无下滤的必要（无法下滤）。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyopuk6qs7g30i603ntby.gif" alt="Kapture 2022-01-23 at 18.46.27" width="500" />



**下滤方法(siftDown)**

下滤(siftDown)是堆排序的核心方法，在堆排序中用于在程序开始时创建大顶堆，以及在每次排序堆顶时用于恢复未排序部分的堆序。

该方法来源于删除堆顶元素操作，先介绍下滤在删除堆顶元素的处理过程。如下动图展示了删除大顶堆{9, 8, 5, 6, 7, 2, 4, 1, 3}堆顶元素9的过程（动图中出现的100表示堆顶，值为9）。

1. 删除堆顶，堆中元素减1，将当前最后一个元素3暂时置为堆顶。
2. 可以看到，此时影响堆序的只有该堆顶元素3，于是交换其与左右子节点中的较大者。
3. 对元素3重复操作2，直到3再无子节点，堆序恢复。

恢复堆序的过程就是将影响堆序的元素不断向下层移动（并交换）的过程，因此形象地称之为下滤(siftDown)。

※ 注意，此处沿用JDK源码中下滤操作的方法名"siftDown"，sift为过滤之意，网上许多博客文章将其讹误成shift。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyosplo6zzg30i603nwga.gif" alt="Kapture 2022-01-23 at 18.46.27" width="500" />

可以看到，对节点x的下滤操作的本质是恢复以x为根节点的树的堆序。因此在堆化操作中，只需要分别，依次地对最后一个非叶子节点到根节点执行下滤操作，即可使整棵树满足堆序。在排序过程中，每次原地交换后（交换当前堆顶与当前未排序部分最后一个元素），只有新堆顶影响堆序，对其执行一次下滤操作（范围为未排序部分）即可使未排序部分重新满足堆序。



### 复杂度分析

时间复杂度：原地堆排序的时间复杂度为O(nlogn)。

建堆时间复杂度: O(n)，证明如下。

以完全二叉树([complete binary tree](https://www.programiz.com/dsa/complete-binary-tree))为例，以根节点为第1层，共h层。第k层有2<sup>k-1</sup>个元素，该层每个元素至多下滤h - k次。于是所有元素最大下滤次数总和为：

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz8gu1e3pzj30qe09g74l.jpg" width="150" />

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz8gwr0powj31ls03qwex.jpg" width="300" />

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz8gxzkv0pj31ra03qt9a.jpg" width="330" />

下式2S减去上式S得到

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz8gysn5t4j31n403qq39.jpg" width="320" />

总元素数为n = 2<sup>h</sup>-1，因此建堆时间复杂度为O(n)。



原地交换至排序完成时间复杂度：O(nlogn)，证明如下。

当前堆顶通过交换完成排序时，其下滤次数取决于当前树高，设当前未排序元素个数为i，其下滤次数最多为层高减1（根节点为第1层），即logi。每排序一次堆顶，待排序部分元素个数减1，于是从一个大顶堆开始完成排序所需时间取决于n - 1次堆顶下滤(下滤范围分别为n, n -1, n-2,...,2)次数总和最大值。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz8gzma1wpj30a008uaa4.jpg" width="60" />

由[Stirling公式](https://en.wikipedia.org/wiki/Stirling%27s_approximation)得到

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz8h0mi430j31oc08ujsh.jpg" width="320" />

于是时间复杂度为O(nlogn)。

最好 / 平均 / 最坏时间复杂度为O(nlogn)。

若考虑数组所有元素均相等，则建堆和原地交换时下滤次数为0，时间复杂度取决于建堆和原地交换时的比较次数，为O(n)，

※ Stirling公式详细证明过程可参考：[谈Stirling公式](http://episte.math.ntu.edu.tw/articles/mm/mm_17_2_05/index.html)

空间复杂度：算法中只有常数项变量，O(1)。



### 代码

```java
public int[] heapSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // 构建大顶堆
    heapify(arr, arr.length - 1);
    // 交换堆顶和当前未排序部分最后一个元素
    // 此时除了该堆顶元素外都是保持堆序的，所以只需要对他调用一次下滤操作
    // 传入endIdx = i - 1控制下滤范围
    for (int i = arr.length - 1; i > 0; i--) { // i > 0即可，无需写成i >= 0，当N-1个元素排序时，最后一个元素也已排序
        // 此处i是下标
        swap(arr, 0, i);
        // 此处i - 1是未排序部分最后一个元素下标，传入此参数是为了确保下滤不会超过此范围
        siftDown(arr, 0, i - 1);
    }
    return arr;
}

private void heapify(int[] arr, int endIdx) {
    for (int hole = endIdx / 2; hole >= 0; hole--) {
        siftDown(arr, hole, endIdx);
    }
}

private void siftDown(int[] arr, int hole, int endIdx) {
    int target = arr[hole]; // target是要下滤的节点
    int child = hole * 2 + 1;
    while(child <= endIdx) {
        // 满足第一个条件child < len表示hole有右儿子，不满足则hole无右儿子，跳过
        // 第二个条件arr[child + 1] > arr[child]只在第一个条件成立前提下进行判断（因此不必担心arr[child + 1]越界），
        // 若满足，表示hole有右儿子且右儿子更大，令child为右儿子下标。
        // 因此此if过后使得child是hole的儿子中较大的那个
        if (child < endIdx && arr[child + 1] > arr[child]) {
            child++;
        }
        // 若child大于tmp，则child上移到当前hole，hole下滤到child位置 
        if (arr[child] > target) {
            arr[hole] = arr[child];
            hole = child;
            child = hole * 2 + 1; // 当然也可以写成child = child * 2 + 1
        } else {
            break; // 若无需交换hole与child，说明hole已经满足堆序，退出while
        }
    }
    // 将tmp填入hole中
    arr[hole] = target;
}
```



## 计数排序

### 算法描述

计数排序通常适用于整数数组，是一种利用整数特点取得线性复杂度的非比较排序方法。假设待排序数组arr为正整数数组，朴素的计数排序过程如下：

1. 创建一个计数数组countArr，其大小为arr中的最大值max再加1。
2. 遍历arr，每读取一个arr[i]，直接令countArr[i]++。
3. 从下标1开始遍历countArr，依次输出counter[i]个i，即为排序结果。

朴素做法有两个明显的缺陷，首先是无法处理负数，其次是当元素个数虽然较多，但有很多相等元素使得元素分布集中在较小范围时，max+1大小的countArr中大部分空间是多余的。改进方法很简单，即创建大小为max - min + 1的countArr，max和min分别是arr中最大和最小元素。如下动图展示了{4,6,2,1,7,9,5,8,3,1,1}的计数排序过程（不稳定版）。

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gyr7qbd8iyg307t07fe82.gif" alt="Kapture 2022-01-26 at 17.40.11" width="250" />

**稳定性：取决于是否采用稳定性优化版本。**

采用则稳定,不采用则不稳定，优化方法见后。



### **稳定性优化**

经过上述改进的计数排序仍存在一个稳定性缺陷，即通过计数来排序，当遍历到countArr[i]时，只是连续地输出countArr[i]次i + min，稳定性得不到保证。要保证稳定，必须使先记录的先输出。可以通过对countArr进行变形来满足稳定性，使得遍历到同一个数字，例如k时，能够将不同位置的k按他们在arr中出现的顺序放入到输出数组中。具体做法是在得到countArr后，遍历一次countArr，使得每一个countArr[i]的值都是从countArr[0]到countArr[i]中值不为0的项的值之和。例如对于待排序数组{5, 5, 4, 4, 1, 1}，得到大小为 5 - 1 + 1 = 5的countArr，具体为{2, 0, 0, 2, 2}，表示有两个1，0个2，0个3，2个4，2个5。按照前述方法将其变形为{2, 0, 0, 4, 6}，表示1的最大位置为第2位(下标为1)，4的最大位置为4(下标为3)，5的最大位置为6(下标为5)。在输出排序结果时，新建一个大小等于arr的sortedArr数组，于是countArr[arr[i] - min] - 1即为arr[i]这个数应当放入sortedArr的位置(下标)，即sortedArr[countArr[arr[i] - min] - 1] = arr[i]，以倒序从arr.length遍历到0，每次向sortedArr填入一个数字后，令countArr[arr[i] - min]--。遍历结束后得到的sortedArr即为arr的稳定排序结果。



### 复杂度分析

时间复杂度：朴素版为O(max)，max为原数组中最大值。改进版为O(n + k)，n为元素个数，k计数数组大小。当元素个数较少但最大最小值差值很大时，复杂度取决于k。

空间复杂度：不考虑输入数组arr，朴素版的countArr的大小为k+1，故空间复杂度为O(k)。稳定性优化版为O(n + k)，n为sortedArr的大小，等于arr的大小。



### 代码

#### 不稳定计数排序

```java
public int[] countSortUnstable(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    int min = arr[0];
    int max = arr[0];
    for (int i = 1; i < arr.length; i++) {
        min = Math.min(min, arr[i]);
        max = Math.max(max, arr[i]);
    }
    int[] countArr = new int[max - min + 1];
    for (int i = 0; i < arr.length; i++) {
        countArr[arr[i] - min]++;
    }
    int index = 0;
    for (int i = 0; i < countArr.length; i++) {
        for (int j = 0; j < countArr[i]; j++) {
            arr[index] = i + min;
            index++;
        }
    }
    return arr;
}
```



#### 稳定计数排序

```java
public int[] countSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    int min = arr[0];
    int max = arr[0];
    for (int i = 1; i < arr.length; i++) {
        min = Math.min(min, arr[i]);
        max = Math.max(max, arr[i]);
    }
    int[] countArr = new int[max - min + 1];
    for (int i = 0; i < arr.length; i++) {
        countArr[arr[i] - min]++;
    }
    // countArr变形
    int sum = 0;
    for (int i = 0; i < countArr.length; i++) {
        // 一处小改进，当输入数组取值比较稀疏时，该判断能避免大部分无意义的赋值操作
        if (countArr[i] != 0) {
            sum += countArr[i];
            countArr[i] = sum;
        }
    }
    // 根据sortedArr, nums, countArr三者关系完成sortedArr的输出
    int[] sortedArr = new int[arr.length];
    for (int i = arr.length - 1; i >= 0; i--) {
        sortedArr[countArr[arr[i] - min] - 1] = arr[i];
        countArr[arr[i] - min]--;
    }
    return sortedArr;
```



## 基数排序

### 算法描述

非比较排序，基指的是数的位，例如十进制数123，共有百十个位，共3个位。基数排序按数字的位循环，每一轮操作都是对当前位（基数）的计数排序，使得输出到arr后所有数字在截止到当前位上（即去掉未考察的位后）是排序状态，考察完最大位后完成排序。具体过程如下：

1. 遍历待排序数组arr，找到最大值，计算其位数，例如arr中最大数为123，则maxDigitLen = 3。
2. 数组的数字为n进制，就创建大小为n的计数数组countArr，也可以称为n个桶。
3. 开始位的for循环，循环次数等于maxDigitLen，每一轮对当前所有数字的当前位执行一次计数排序。
4. 每次计数排序结束后将结果写回arr。
5. for循环结束后返回排序结果arr。

如下动图演示{6674, 1560, 5884, 2977, 2922, 4127, 5390, 7870, 1193, 7163}的基数排序过程。

也可以不使用计数排序，而是创建一个二维数组（可看作19个桶）保存每次遍历的中间结果，此写法耗费的空间较大（每个桶的大小都要等于arr大小+1，空间复杂度为O(19n)），是稳定排序，不详细说明，可以参考后续给出的代码实现。

以计数排序为基础的基数排序，每一位循环时都对所有数做该位的计数排序。

不以计数排序为基础的基数排序，每一位循环时都将所有数按顺序放入相应的桶中。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gysb1jsbaog30cc07rwkq.gif" alt="Kapture 2022-01-27 at 16.17.40" width="450" />



**稳定性：取决于计数排序的稳定性。**

两个同值的元素位数相同，按位循环，若采用稳定版本的计数排序则稳定，否则不稳定。



### 优化

处理负数优化：若存在负数，可以先找到最小值(负数)，对arr中的每个数，都加上此最小值的绝对值，排序完成后再减回去。但有可能使得数字越界，一种更好的办法是计数排序时将countArr的大小扩展为19，以[0, 19]对应可能出现的[-9, 9]。因此在每轮求当前基数时，要在原基数结果上+9以对应countArr的下标。

后续代码直接给出利用计数排序的优化后的版本。



### 复杂度分析

时间复杂度：d为绝对值最大的元素位数，总共进行d轮计数排序，O(n + k)是计数排序的复杂度，其中k是位的取值范围，如果是非负数，则k = 10 (0~9)，如果包含负数，则k = 19 (-9~9)。所以总的时间复杂度为O(d(n + k))。

空间复杂度：利用计数排序的基数排序，空间复杂度与计数排序相同，为O(n + k)。



### 代码

#### 以计数排序为基础

```java
public int[] radixSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // 找到arr中绝对值最大者
    int max = Math.abs(arr[0]);
    for (int i = 1; i < arr.length; i++) {
        max = Math.max(max, Math.abs(arr[i]));
    }
    // 求最大数的位数
    int maxDigitLen = 0;
    int base = 10;
    while (max != 0) {
        maxDigitLen++;
        max /= base;
    }
    // 在接下来的for中，每一轮都对当前位(基数)执行一次计数排序
    // 为应对有负数的情况，countArr为范围为[-9, 9]
    int[] sortedArr = new int[arr.length];
    for (int i = 0; i < maxDigitLen; i++) {
        int[] countArr = new int[19];
        // 根据每一个数字当前位的数字，累计相应位置的计数
        for (int j = 0; j < arr.length; j++) {
            // 此步处理要注意，当base大于10时，例如base=100时，1234%100=34
            // 还需要再除以(base/10)，得到的3，然后再+9（考虑负数）才是本次的bucketIdx
            int bucketIdx = (arr[j] % base) / (base / 10) + 9;
            countArr[bucketIdx]++;
        }
        // countArr变形，得到每个下标所代表的arr中的数的当前位在arr中的最大位置（从1开始）
        for (int j = 1; j < countArr.length; j++) {
            countArr[j] += countArr[j - 1];
        }
        // 逆序输出保持稳定性
        for (int j = arr.length - 1; j >= 0; j--) {
            int thisBase = (arr[j] % base) / (base / 10) + 9;
            // countArr[thisBase]得到的从1开始计算的位置，转成下标要-1
            sortedArr[countArr[thisBase] - 1] = arr[j]; 
            countArr[thisBase]--;
        }
        // 完成当前位的计数排序后将排序结果拷贝回原数组
        arr = Arrays.copyOf(sortedArr, sortedArr.length);
        // base进一位，准备下一轮对下一位的计数排序
        base *= 10;
    }

    return arr;
}
```



#### 不以计数排序为基础

```java
public int[] radixSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // 找到arr中绝对值最大者
    int max = Math.abs(arr[0]);
    for (int i = 1; i < arr.length; i++) {
        max = Math.max(max, Math.abs(arr[i]));
    }
    // 求最大数的位数
    int maxDigitLen = 0;
    int base = 10;
    while (max != 0) {
        maxDigitLen++;
        max /= base;
    }
    // 考虑负数时每一位范围为[-9, 9]，设置19个桶使其能够处理负数。
    // arr.length + 1的作用是令每个桶的第0位保存该桶的元素个数。
    int[][] buckets = new int[19][arr.length + 1]; 
    // 在每一位上将数组中所有具有该位的数字装入对应桶中
    for (int i = 0; i < maxDigitLen; i++) {
        for (int j = 0; j < arr.length; j++) {
            // 此步处理要注意，当base大于10时，例如base=100时，1234%100=34
            // 还需要再除以(base/10)，得到的3才是本次的bucketIndex
            int bucketIdx = (arr[j] % base) / (base / 10) + 9; // +9使其可以处理负数
            int currentBucketQuantity = buckets[bucketIdx][0];
            buckets[bucketIdx][currentBucketQuantity + 1] = arr[j];
            buckets[bucketIdx][0]++;
        }
        // 将当前所有桶的数按桶序，桶内按低到高输出为本轮排序结果
        int arrIdx = 0;
        for (int j = 0; j < buckets.length; j++) {
            for (int k = 1; k <= buckets[j][0]; k++) {
                arr[arrIdx++] = buckets[j][k];
            }
        }
        // 每一轮过后将桶计数归零
        for (int[] bucket : buckets) {
            bucket[0] = 0;
        }
        // 调整base
        base *= 10;
    }
    return arr;
}
```



## 桶排序

### 算法描述

桶排序将原数组划分到称为桶的多个区间中，然后对每个桶单独进行排序，之后再按桶序和桶内序输出结果。适合于分布较均匀的数据，具体做法如下。

1. 根据数据规模按照一定的方法将待排序数组arr划分为多个区间，每个区间称作一个桶。
2. 每个桶可以是数组，也可以是泛型容器，用于保存arr中落在该桶范围内的数。
3. 对每一个桶都单独排序，需要以适当的排序方法支持，例如插入排序，快速排序等。
4. 所有桶完成排序后，按桶序，桶内序依次输出所有元素，得到arr的排序结果。



**稳定性：取决于桶内排序方法的稳定性。**



### 复杂度分析

时间复杂度：找最大最小值和分配桶均耗费O(n)，之后的复杂度取决于每个桶内的排序算法复杂度之和。假设有k个桶，且数据分布均匀，若采用O(n^2)的排序算法，那么总排序时间复杂度为 O(n^2/k)，若采用O(nlogn)的排序算法，总排序时间复杂度为O(nlog(n/k))。若桶内排序采用O(nlogn)算法，且k的大小适当，例如k = n/p，p是一个较小的数例如2，3等。那么整体的时间复杂度约为O(n)。虽然形式上为线性复杂度，但其n的系数较大，未必优于O(nlogn)的排序算法。

当所有元素都被分到同一个桶中，达到最大时间复杂度，为O(n^2)或O(nlogn)（取决于桶内排序采用的排序方法）。

空间复杂度：取决于桶的数据结构，若采用静态数组，由于每个桶都需要保证有n个位置，则空间复杂度为O(kn)，若采用泛型容器，则为O(n)。



### 代码

```java
public int[] bucketSort(int[] arr) {
    int min = arr[0];
    int max = arr[0];
    for (int i = 0; i < arr.length; i++) {
        min = Math.min(min, arr[i]);
        max = Math.max(max, arr[i]);
    }
    // 用泛型List存储所有桶，每个桶是一个ArrayList<Integer>，并初始化所有桶
    List<ArrayList<Integer>> buckets = new ArrayList<ArrayList<Integer>>(arr.length);
    for (int i = 0; i < arr.length; i++) {
        buckets.add(new ArrayList<Integer>());
    }
    // 遍历arr，根据元素值将所有元素装入对应值区间的桶中
    for (int i = 0; i < arr.length; i++) {
        // (arr[i] - min)/D为arr[i]元素应该装入的桶的下标，间隔D = (max-min)/(arr.length-1)
        // 虽可写成(arr[i] - min)*(arr.length-1)/(max-min)的形式，但当输入数组取值范围较大且元素较多时
        // (arr[i] - min)*(arr.length-1)可能会超过int上限，因此先做除法求出double类型的D
        // 再做一次除法求出bucketIndex，可以避免计算精度不够高带来的问题
        double interval = (double)(max - min) / (double)(arr.length - 1);
        int bucketIdx = (int) ((arr[i] - min) / interval);
        buckets.get(bucketIdx).add(arr[i]);
    }
    // 桶内排序(调用库函数，从小到大)
    for (int i = 0; i < buckets.size(); i++) {
        Collections.sort(buckets.get(i));
    }
    int index = 0;
    for (ArrayList<Integer> bucket : buckets) {
        for (int sortedItem : bucket) {
            arr[index] = sortedItem;
            index++;
        }
    }
    return arr;
}
```



## 决策树

利用决策树来理解基于比较的排序算法的复杂度的理论下界 O(nlogn)。

n个不同元素组成的序列，有n! 种可能的排列。考虑这样一棵决策树，根处存放着所有n!种可能的排序，比较其中两个元素a和b，只有两种可能a>b或者a<b（不考虑等于）。a和b的大小关系确定后，都将去除根处n!种排列中的一半。将a>b确定后的剩下的一半可能作为根的左子节点，a<b确定后剩下的另一半可能作为根的右子节点，每次确认某两个元素的大小的两种可能，都会剩下一半可能，作为左右子节点加入到决策树中，因此该决策树是一棵叶子节点总数为n!的二叉树，决策步数为到达排序状态的序列的叶子节点的深度。

对于深度为d(根节点在0深度处)的二叉树，其叶子结点数量至多为2^d，当二叉树为完美二叉树时达到最大值。于是对应地，具有n个叶子节点的二叉树，深度至少为⌈logn⌉。 于是具有n!个叶子节点的二叉树的深度至少为log(n!)，根据[Stirling公式](https://en.wikipedia.org/wiki/Stirling%27s_approximation)，通过比较来排序的算法的最坏和平均时间复杂度下界为O(nlogn)。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz8h0mi430j31oc08ujsh.jpg" width="320" />

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gz8jzwq5m4j30og0j4myg.jpg" alt="image-20220210174041284" style="zoom:50%;" />



## JDK中的排序

（TODO）

## 例题

与元素大小相关的问题基本上都可以用排序来解决，例如从数组中取出前k个大(小)，第k个大(小)数等。也有通过适当的排序过程获取某些信息的问题，例如消除逆序数。

（TODO）

