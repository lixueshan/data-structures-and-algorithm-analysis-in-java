# 第7章-排序



## 思维导图



## 总结



## 冒泡排序

### 算法描述

对于要排序的数组，从第一位开始从前往后比较相邻两个数字，若前者大，则交换两数字位置，然后比较位向右移动一位。也就是比较arr[0]和arr[1]，若arr[0] > arr[1]，交换arr[0]和arr[1]。接着比较位移动一位，比较arr[1]和arr[2]，直到比较到arr[M-1]和arr[M] (M = arr.length - 1)。第1轮从前到后的比较将使得最大的数字“冒泡”到最后，此时可以说一个数字已经被排序。每一轮的比较将使得当前未排序数字中的最大者被排序，未排序数字总数减1。第arr.length - 1轮结束后排序完成。

**稳定性：稳定。**

只存在相邻交换，且大小相等时不交换，故大小相等的数字相对位置不变。



### 优化

当某一轮比较均未发生交换，说明排序已完成，可设置一个flag记录一轮排序是否有发生交换，若无则提前退出循环结束程序。



### 复杂度分析

时间复杂度：两层for循环，第1轮比较N - 1次(N = arr.length)，最后一轮比较1次。总比较次数为N*(N - 1) / 2次，时间复杂度为O(N^2)。

空间复杂度：算法中只有常数项变量，O(1)。



### 代码

```java
public int[] bubbleSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // N-1轮次执行，当前N-1个元素排好后，最后一个元素无需执行，故i < arr.length - 1
    for (int i = 0; i < arr.length - 1; i++) {
        // 本轮执行是否有交换的标志，若无则true，若有则false
        boolean flag = true;
        // 每轮循环，通过依次向右比较两个数，将本轮循环中最大的数放到最右
        for (int j = 1; j < arr.length - i; j++) {
            // 若左大于右则交换，并将flag置为false
            if (arr[j - 1] > arr[j]) {
                swap(arr, j - 1, j);
                flag = false;
            }
        }
        // 若无交换，表示当前数组已完全排序，退出大循环
        if (flag) {
            break;
        } 
    }
    return arr;
}
```



## 选择排序

### 算法描述

对于要排序的数组，设置一个minIdx记录最小数字下标。先假设第1个数字最小，此时minIdx = 0，将arr[minIdx]与后续数字逐一比较，当遇到更小的数字时，使minIdx等于该数字下标，第1轮比较将找出此时数组中最小的数字。找到后将minIdx下标的数字与第1个数字交换，此时可以说一个数字已被排序。然后开始第2轮比较，令minIdx = 1，重复上述过程。每一轮的比较将使得当前未排序数字中的最小者被排序，未排序数字总数减1。第arr.length - 1轮结束后排序完成。

**稳定性：不稳定。**

存在跨越交换。找到本轮次最小值之后，将其与本轮起始数字交换，此时若中间有与起始元素同值的元素，将打破稳定性。

例:　7 7 2 。第一轮交换第一个7和2，则两个7位置关系改变。



### 优化

在交换前判断下minIdx是否有变化，若无变化则无需交换。当数组大致有序时，能够减少无效交换带来的开销。



### 复杂度分析

时间复杂度：两层for循环，第1轮比较N - 1次(N = arr.length)，最后一轮比较1次。总比较次数为N*(N - 1) / 2次，时间复杂度为O(N^2)。

冒泡排序和选择排序的比较次数均为O(N^2)，但选择排序的交换次数是O(N)，而冒泡排序的平均交换次数仍然是二次的。

空间复杂度：算法中只有常数项变量，O(1)。



### 代码

```java
public int[] selectSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // N-1轮次执行,当前N-1个元素排好后，最后一个元素无需执行，故i < arr.length - 1
    for (int i = 0; i < arr.length - 1; i++) {
        int minIdx = i;
        // 找到本轮执行中最小的元素，将最小值下标赋值给min
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIdx])
                minIdx = j;
        }
        // 若本轮第一个数字不是最小值，则交换位置（将最小值与本轮第一个数字交换位置）
        if (minIdx != i) {
            swap(arr, i, minIdx);
        }
    }
    return arr;
}
```



## 插入排序

### 算法描述

从第2个数字开始，将其称作插入对象数字，将其与之前的元素(称作比较对象)比较，当插入对象小于比较对象时，继续往前比较，直到不小于(≥)比较对象，此时将插入对象插入到该次比较对象之后。重复这个插入过程直到最后一个元素作为插入对象元素完成插入操作。

**稳定性：简单插入和折半插入排序是稳定的。**

对于大小相同的两个数字，简单插入和折半插入均使得后来的数字靠右放置，因此不会改变其相对位置。



### 优化(折半插入)

注意到插入排序的每一轮向前插入都使得该元素在完成插入后，从第一个元素到该元素是排序状态（指这部分的相对排序状态，他们中间后续可能还会插入其他数字），利用这一点，对一个新的插入对象向前执行折半插入，能够显著减少比较的次数。另一种优化是增量递减插入排序，也叫希尔排序，将在希尔排序章节中介绍。

折半插入的关键在于找到插入位置，折半过程代码如下。while的每一次执行都将使得high/low的位置相对于当前center左移/右移一位，不难分析出最后一次无法进入while时的high和low的关系一定是high = low - 1。反推上一次能够进入while的情形：

如果是target < arr[center]，high被更新，high = center - 1，已知当前high = low - 1，说明当前low = center，由于target < arr[center]，也就low(center)这个坐标的元素及其右边元素(直到i的左一位)，都要向右移动一位。

如果是target ≥ arr[center]，low被更新，low = center + 1，已知当前high = low - 1，说明当前high = center，由于target ≥ arr[center]，也就是high(center) + 1，即low(更新后的low)这个坐标的元素及其右边元素(直到i的左一位)，都要向右移动一位。

以上结果均使得插入位置为当前的low (或当前的high + 1)。

```java
while (low <= high) {
    center = (low + high) / 2;
    if (target < arr[center]) {
        high = center - 1;
    }
    else {
        low = center + 1;
    }
}
```

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gymg29m6voj30c0072aa8.jpg" alt="image-20220122144208547" width="250" />



### 复杂度分析

时间复杂度：两层for循环，外层总轮次为N - 1轮(N = arr.length)，当原数组逆序时，移动次数为N*(N - 1) / 2次，最坏时间复杂度为O(N^2)，平均时间复杂度同。

当原数组已基本有序时，接近线性复杂度O(N)。例如原数组已完全排序，则算法只需比较N - 1次。

※ 折半插入总的查找(比较)次数为O(NlogN)，但平均移动(每轮移动一半的数字)次数仍是O(N^2)。

空间复杂度：算法中只有常数项变量，O(1)。



### 代码

#### 简单插入排序

```java
public int[] insertSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // N-1轮次执行
    for (int i = 1; i < arr.length; i++) {
        int target = arr[i];
        int j = i - 1;
        for (; j >= 0; j--) {
            if(target < arr[j]) {
                arr[j + 1] = arr[j];
            }
            else {
                break;
            }
        }
        if (j != i - 1) { // j变动表示发生了前移
            arr[j + 1] = target; // 此时的j位置的数字≥插入对象数字，故插入位置为j + 1
        }
    }
    return arr;
}
```



#### 折半插入排序

```java
public int[] binaryInsertSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // N-1轮次执行
    for (int i = 1; i < arr.length; i++) {
        // 若当前插入对象大于等于前一个对象，无需插入
        if (arr[i - 1] <= arr[i]) {
            continue;
        }
        // 拷贝插入对象元素
        int target = arr[i];
        // 折半查找
        int low = 0;
        int high = i - 1;
        int center = 0;
        // 经过while之后，target要插入的位置为low
        while (low <= high) {
            center = (low + high) / 2;
            if (target < arr[center]) {
                high = center - 1;
            }
            else {
                low = center + 1;
            }
        }
        // 移动
        for (int j = i; j > low; j--) {
            arr[j] = arr[j - 1];
        }
        // 插入
        arr[low] = target;
    }
    return arr;
}
```



## 希尔排序

### 算法描述

希尔排序是简单插入排序的改进，它基于以下事实。Donald Shell在1959年发表的[论文](http://penguin.ewu.edu/cscd300/Topic/AdvSorting/p30-shell.pdf)中，针对第二点，提出设置一个gap值。对原待排序列中gap间隔的数字执行简单插入排序，然后缩小gap，对新的gap间隔的数字再次执行简单插入排序，以一种规则减少gap的大小直到gap为1，再执行最后一个简单插入排序，因此希尔排序也称作增量递减排序。希尔在论文中提出的增量序列为{1, 2, 4, 8,...}，即2^k，k = 1, 2, 3, ...，在讨论希尔排序时，可将其称为希尔增量。

1. 简单插入排序对已排序程度较高的序列有较高的效率。假设初始序列已完全排序，则每一轮均只需比较一次，将得到O(N)的线性复杂度，冒泡排序和选择排序做不到这一点(均仍需O(N^2))。
2. 简单插入排序每次比较最多将数字移动一位，效率较低。

程序开始时gap较大，待排元素较少，因此排序速度较快。当gap较小时，基于第一点，此时待排序列已大致有序，排序效率接近线性复杂度。因此可以期待希尔排序将有优于二次方的复杂度。详细见「复杂度分析」。

**稳定性：不稳定。**

gap > 1时，跨越gap的插入可能会改变两个相同值元素的位置关系。例如{0, 1, 4, 3, 3, 5, 6}，当gap = 2时，对{0, 4, 3, 6}简单插入排序后得到{0, 1, 3, 3, 4, 5, 6}，原数组中的两个3的位置互换了。



### 复杂度分析

时间复杂度：希尔排序的时间复杂度与增量序列的选择有关。

Shell增量(Shell, 1959): {1, 2, 4, 8,...}，即2^k，k = 1, 2, 3, ...，最坏时间复杂度Θ(N^2)。

Hibbard增量(Hibbard, 1963)：{1, 3, 7, 15,...}，即2^k - 1，k = 1, 2, 3, ...，最坏时间复杂度Θ(N^(3/2))。

Knuth增量(Knuth, 1971)：{1, 4, 13, 40,...}，即(3^k - 1) / 2，k = 1, 2, 3, ...，最坏时间复杂度Θ(N^(3/2))。

Sedgewick增量(Sedgewick, 1982): {1, 8, 23, 77, 281}，即4^k + 3*2^(k-1) + 1 (最小增量1直接给出)，k = 1, 2, 3, ...，最坏时间复杂度Θ(N^(4/3))。

复杂度的证明需要借助数论和组合数学，略。

空间复杂度：算法中只有常数项变量，O(1)。



**逆序数**

希尔排序是较早出现的突破二次复杂度的排序算法。以逆序数的角度来直观地说明为何希尔排序能够突破二次复杂度。

在一个排列中，如果任意一对数的前后位置与大小顺序相反，即前面的数大于后面的数，那么它们就称为一个逆序，一个排列中逆序的总数就称为这个排列的**逆序数**。排序的过程就是不断减少逆序数直到逆序数为0的过程。

回顾冒泡排序和简单插入排序，算法的每一次交换，都只交换相邻元素（简单插入排序中元素每次右移也看作交换），因此每次交换只能减少一个逆序。冒泡排序和简单插入排序的元素平均交换次数均为O(N^2)， 也即逆序数(或逆序数减少次数)为O(N^2)。 如果能跨越多个数字进行交换，则可能一次减少多个逆序。在选择排序中，每轮选到最小元素后的交换即是跨越多个元素的，交换次数(减少逆序数的操作)为O(N)，要少于冒泡和简单插入排序，只是因为比较次数仍是O(N^2)， 所以整体复杂度为O(N^2)。

现在来分析跨越多个元素的交换如何减少逆序数，假设arr[i] > arr[j], i < j。对于任意的arr[k] (i < k < j)：

1. 若arr[k] < arr[j]，交换arr[i]和arr[j]后，三者的逆序数从2变为1
2. 若arr[k] > arr[i]，交换arr[i]和arr[j]后，三者的逆序数从2变为1
3. 若arr[i] > arr[k] > arr[j]，交换arr[i]和arr[j]后，三者的逆序数从3变为0

arr[k] = arr[i]或arr[k] = arr[j]的情况一样，都使得三者逆序数从2变为1，下图省略。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gymsg7ks3hj30no0cy0tu.jpg" alt="image-20220122180949935" width="300" />

对arr[i]和arr[j]的逆序消除，使得逆序至少减少一次，并有机会减少大于一次的逆序(情况3)，因此能够以比N^2低阶的次数消除所有逆序。

实际上归并排序，快速排序，堆排序均实现了长距离交换元素，使得复杂度优于O(N^2)。



### 代码

```java
public int[] shellSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // 初始化gap
    int gap = 1;
    while (gap < arr.length / 3) { // Knuth增量序列
        gap = gap * 3 + 1;
    }
    // 不断缩小gap直到1，对每一个gap值执行一次插入排序
    while (gap > 0) {
        // 注意步长增量是gap
        for (int i = gap; i < arr.length; i += gap) {
            int target = arr[i];
            int j = i - gap;

            for (; j >= 0; j -= gap) { 
                 if (target < arr[j]) {
                     arr[j + gap] = arr[j];
                 } else {
                    break; 
                 }
            }

            if (j != i - gap) {
                arr[j + gap] = target;
            }
        }
        // 缩小gap值
        gap /= 3;
    }
    return arr;
}
```



## 归并排序

### 算法描述

归并排序是一种分治思想的应用，即将原待排数组递归地分为左右两半，直到数组长度为1(递归的基准情形)，然后对从基准情形返回的左右数组进行合并(merge)，在合并中排序。详细过程需结合代码理解，如下动图展示了{4,6,2,1,7,9,5,8,3}的归并排序过程。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gymsfclus3g309w0aq1b4.gif" alt="image-20220122180949935" width="300" />

如下树状图中的橙色线表示递归的轨迹。

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gynosiaalbj30ny0qkadk.jpg" alt="image-20220123162943016" width="400" />



**稳定性：稳定。**

合并时的此判断中的等号`if(left[l_next] <= right[r_next])`，保证了出现相等元素时，居左的元素总会被放在左侧，稳定性不受影响。



### 复杂度分析

时间复杂度: O(NlogN)。

每次减半后的数组对应元素的对比(`if(left[l_next] <= right[r_next])`)和赋值(`resArr[res_next++] = `)总是必须的，也即在每一层递归深度，比较和赋值导致的时间复杂度都是O(N)，数组规模减半次数为logN，即递归深度为logN。排序的性能与输入数组的特点无关(例如一个几乎已排序的数组)，最好，最坏，平均时间复杂度均为O(NlogN)。

也可以这样证明。当N=1时，排序只需常数时间，可以记为1。N个元素的归并排序时间由N/2个元素的归并排序的两倍，再加上将两个N/2大小的排序数组合并耗时N得到。得到如下两个式子。

T(1) = 1

T(N) = 2T(N/2) + N (N是合并动作的时间)

对第二个式子，左右两边除以N，得到

T(N) / N = T(N/2) / (N/2) + 1

可以不断地将括号内的N除以2，得到

T(N/2) / (N/2) = T(N/4) / (N/4) + 1

T(N/4) / (N/4) = T(N/8) / (N/8) + 1

...

T(2) / 2 = T(1) / 1 + 1

将上述所有式子相加后，化简得到，T(N) = N + NlogN ，于是求出复杂度为O(NlogN)。

空间复杂度：递归深度为logN，递归过程中创建的数组



### 代码

```java
public int[] mergeSort(int[] arr) {
    // 先判断是否小于2，小于2直接返回
    if (arr.length < 2) {
        return arr;
    }
    int[] tmpArr = new int[arr.length];
    mergeSort(arr, tmpArr, 0, arr.length - 1);
    return tmpArr;
}

private void mergeSort(int[] arr, int[] tmpArr, int left, int right) {
    if(left < right) {
        int center = (left + right) / 2;
        mergeSort(arr, tmpArr, left, center);
        mergeSort(arr, tmpArr, center + 1, right);
        merge(arr, tmpArr, left, center, right);
    }
}

private void merge(int[] arr, int[] tmpArr, int leftPos, int leftEnd, int rightEnd) {
    int rightPos = leftEnd + 1;
    int startIdx = leftPos;
    int tmpPos = leftPos;
    while (leftPos <= leftEnd && rightPos <= rightEnd) {
        if (arr[leftPos] <= arr[rightPos]) {
            tmpArr[tmpPos++] = arr[leftPos++];
        }
        else {
            tmpArr[tmpPos++] = arr[rightPos++];
        }
    }
    // 比较完成后若左数组还有剩余，则将其添加到tmpArr剩余空间
    while (leftPos <= leftEnd) {
        tmpArr[tmpPos++] = arr[leftPos++];
    }
    // 比较完成后若右数组还有剩余，则将其添加到tmpArr剩余空间
    while (rightPos <= rightEnd) {
        tmpArr[tmpPos++] = arr[rightPos++];
    }
    // 容易遗漏的步骤，将tmpArr拷回arr中
    for(int i = startIdx; i <= rightEnd; i++) {
        arr[i] = tmpArr[i];
    }
}
```



## 快速排序

### 算法描述

与归并排序一样，快速排序也是一种利用了分治思想的排序方法。确定主轴及分区操作是快速排序的核心。首先在数组中确定一个主轴元素(下标pivot)，然后将数组分为两部分，小于主轴的放在主轴左侧，大于等于主轴的放在主轴右侧。递归地对主轴左右两侧数组执行这个过程，每次递归都传入待排序数组arr和本次要处理的部分的左右界，只处理这个范围内的序列。当所有递归都到达基准情形时，排序完成。因为是原地交换，递归过程中arr总是在动态排序，递归过程无需返回，为尾递归形式。

详细过程需结合代码理解，如下动图展示了{4,6,2,1,7,9,5,8,3}的快速排序过程（以起始元素为主轴）。

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gynuubbcdpg306q03gdl9.gif" alt="Kapture 2022-01-23 at 18.46.27" width="300" />



**主轴的选择**

1. 主轴为起始元素(quickSortSimple)。每次选取当前数组第一个元素作为主轴。
   - 优点：实现简单。
   - 缺点：若输入是较为有序的数组，pivot总是不能均匀地分割数组。若输入数组本身有序，复杂度退化到O(N^2)。
2. 主轴为随机下标(quickSortRandom)。每次随机选取当前数组的下标，将该下标元素作为主轴。
   - 优点：避免了主轴为起始元素时对于基本有序的输入，因不能均匀分割数组导致复杂度退化的情况。
   - 缺点：随机数的选取本身消耗一定的性能。
3. 主轴为左中右三数居者(quickSortMedian3)。每次比较当前数组起始、中间和末尾三个元素的大小，大小居中者为主轴。
   - 优点：实现相对简单，且有效避免简单快排中的劣质分割。
   - 缺点：三数取中方法消耗一定性能。

快速排序也可以与其他排序相结合，例如当元素较少时使用简单插入排序能够获得更高的排序效率。



**分区方法(partition)**

快速排序中的核心方法为partition。partition方法执行后，要实现主轴左边元素均小于主轴，主轴右边元素均大等于主轴元素。

选定一个数作为主轴后（无论是上述哪种方法选取主轴元素，最后都将选定的主轴置于当前数组的起始位置），设置一个index (index = pivot + 1)动态更新最终的主轴下标。从左到右将主轴后的所有元素依次与主轴元素比较，若小于主轴则将该数字与下标为index的数字交换，index右移一位，使得index的前一位总是当前最后一个小于主轴的元素。遍历比较结束后，交换下标为pivot与index - 1的数字，并将当前主轴的下标index - 1返回。



**稳定性：不稳定。**

partition中在确定了主轴位置后，将一开始设置的主轴元素与最后一个小于主轴的元素x交换时，若中间有与x同值的元素，则稳定性被破坏。

例：7 2 4 4 8 9

partition过后交换7和第二个4，则两个4的位置关系发生变化。



### 非递归快排



### 双轴快排



### 复杂度分析

时间复杂度：平均 / 最好，O(NlogN)。最坏，O(N^2)。

 每次partition主轴均居中，则递归深度为i的的partition有2^i个， 这2^i个partition需要比较的次数是 (除去2^(i - 1)个主轴元素的元素个数)N - 2^(i - 1)。给出如下复杂度估计。

Σ(N - 2^(i - 1))  ( i = [1, logN])

计算可知复杂度为

 O(NlogN)。

**最坏情形**

 当输入为已排序数组，第i次partition后主轴左右两部分总是left = null，right = N - i, 第i次partition需要比较N - i次，共有N次partition，总比较次数O(N^2)。类似于对已排序的数组做选择排序。



空间复杂度：递归形式的快排，取决于递归深度，为O(logN)。非递归形式的快排，保存分区信息的栈深度与递归深度相同，所以空间复杂度也是O(logN)。

不同于归并排序中需要借助一个临时数组保存每次合并的结果，快速排序以原地交换元素的形式，避免了O(N)的数组开销。



### 代码

```java
/**
 * 三数取中快排
 */
public int[] quickSortMedian3(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // 注意后两个参数是下标值
    quickSortMedian3(arr, 0, arr.length - 1);
    return arr;
}

private void quickSortMedian3(int[] arr, int left, int right) {
      if (left < right) { 
        // 执行median3将左，中，右三数中值放到left位置上
        median3(arr, left, right);
        int partitionIndex = partition(arr, left, right);
        quickSortMedian3(arr, left, partitionIndex - 1);
        quickSortMedian3(arr, partitionIndex + 1, right);
    }
}


/**
 * 三数取中方法
 * 将下标left到下标right的分区中，将left/center/right
 * 三者中的最小者放到当前分区的起始位置
 */
private void median3(int[]arr, int left, int right) {
    int center = (left + right) / 2;
    // 假设arr[left] = a, arr[center] = b, arr[right] = c，第一个if过后a,b中较小者在left位置上
    if (arr[left] > arr[center]) {
        swap(arr, left, center);
    }
    // 前两个if后a,b,c中最小值在left位置上
    if (arr[center] > arr[right]) {
        swap(arr, left, right);
    }
    // 三个if后a,b,c中居中者在center位置上
    if (arr[center] > arr[right]) {
        swap(arr, center, right);
    }
    // 将left, center, right三者的中值置于left位置上
    swap(arr, left, center);
}

/**
 * 随机主轴快排
 */
public int[] quickSortRandom(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    quickSortRandom(arr, 0, arr.length - 1);
    return arr;
}

private void quickSortRandom(int[] arr, int left, int right) {
    if (left < right) {
        // 取区间内随机下标，注意Random().nextInt(int x)方法的使用（含0不含x）
        int randomIndex = new Random().nextInt(right - left + 1) + left;
        // 交换随机取得的下标元素与当前起始元素
        swap(arr, left, randomIndex);
        int partitionIndex = partition(arr, left, right);
        quickSortRandom(arr, left, partitionIndex - 1);
        quickSortRandom(arr, partitionIndex + 1, right);
    }
}

/**
 * 朴素快排(首位为主轴)
 */
public int[] quickSortSimple(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // 注意后两个参数是下标值
    quickSortSimple(arr, 0, arr.length - 1);
    return arr;
}

private void quickSortSimple(int[] arr, int left, int right) {
    // 若left == right，表示此时arr只有一个元素，即为基准情形，完成递归
    // (尾递归，“回归”过程中不做任何事情）
    if (left < right) {
        int partitionIndex = partition(arr, left, right);
        quickSortSimple(arr, left, partitionIndex - 1);
        quickSortSimple(arr, partitionIndex + 1, right);
    }
}

/**
 * partition方法
 */
private int partition(int[] arr, int left, int right) {
    int pivot = left;
    int index = pivot + 1;
    // 注意此时right是坐标，要执行到最后一个元素，所以是<=
    for (int i = index; i <= right; i++) {
        if (arr[i] < arr[pivot]) {
            swap(arr, index, i);
            index++;
        }
    }
    // 最后一个小于主轴元素的元素下标是index - 1
    swap(arr, pivot, index - 1);
    return index - 1;
}
```



## 堆排序

### 算法描述

将输入数组建立为一个大顶堆，之后反复取出堆顶并对剩余元素重建大顶堆，将依次取出的堆顶逆序排列，即可将原数组从小到大排列完成排序。

一个直接的想法是在原数组之外新建一个数组保存每次取得的堆顶，可以用一种称作“原地堆排序”的技巧避免新建数组的开销，具体做法如下。

1. 首先将原待排序数组arr[]建立为一个大顶堆(heapify堆化方法)。
2. 交换堆顶和当前未排序部分中最末尾元素，则堆顶元素已排序。
3. 剩余元素中只有当前堆顶（之前被交换的末尾元素）可能造成堆失序，因此只需对堆顶调用一次调整堆序的下滤(siftDown)操作，即可恢复未排序部分的堆序。
4. 重复2，3直到所有元素已排序，返回arr[]。

上述通过交换堆顶与当前未排序部分末尾元素的做法，避免了额外的空间开销，这就是“原地堆排序”。程序结束后返回的arr[]为已排序状态。



**稳定性：不稳定。**

交换可能会破坏稳定性。例：输入数组 {1, 2, 2}，变灰表示已排序。可以看到红2和绿2的相对顺序相比输入已改变。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyozpzv3u0j30sw07amy3.jpg" alt="image-20220124193317369" width="450" />



**堆化方法(heapify)**

将原输入数组看作一棵二叉树。根节点下标为0，于是根据二叉树性质有，任意一个节点(下标为i)的左子节点下标为2 * i + 1，右子节点下标为 2 * i + 2，父节点坐标为i / 2。堆化过程即使得整棵树满足堆序性质，也即任意一个节点大于等于其子节点（应用大顶堆）。堆化操作总结为一句话就是：对最后一个非叶子节点到根节点，依次执行下滤操作(siftDown)。如下是将输入数组{4, 6, 2, 1, 7, 9, 5, 8, 3}堆化成大顶堆{9, 8, 5, 6, 7, 2, 4, 1, 3}的过程。

最后一个非叶子节点（也即最后一个元素的父节点）坐标为(len - 1) / 2，len为数组长度。从最后非一个叶子开始下滤的原因是此节点之后的节点均为叶子节点，无子节点，也就无下滤的必要（无法下滤）。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyopuk6qs7g30i603ntby.gif" alt="Kapture 2022-01-23 at 18.46.27" width="500" />



**下滤方法(siftDown)**

下滤(siftDown)是堆排序的核心方法，在堆排序中用于在程序开始时创建大顶堆，以及在每次排序堆顶时用于恢复剩余元素堆序。

该方法来源于删除堆顶元素操作，所以我们先介绍下滤在删除堆顶元素的处理过程。如下动图展示了删除大顶堆{9, 8, 5, 6, 7, 2, 4, 1, 3}堆顶元素9的过程（动图中出现的100表示该堆顶，值为9）。

1. 删除堆顶，堆中元素减1，将当前最后一个元素3暂时置为堆顶。
2. 可以看到，此时影响堆序的只有该堆顶元素3，于是交换其与左右子节点中的较大者。
3. 对元素3重复操作2，直到3再无子节点，堆序恢复。

恢复堆序的过程就是将影响堆序的元素不断向下层移动（并交换）的过程，因此形象地称之为下滤(siftDown)。

※ 注意，此处沿用JDK源码中下滤操作的方法名"siftDown"，sift为过滤之意，网上许多博客文章将其讹误成shift。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyosplo6zzg30i603nwga.gif" alt="Kapture 2022-01-23 at 18.46.27" width="500" />

可以看到，对节点x的下滤操作的本质是恢复以x为根节点的树的堆序。因此在堆化操作中，之需要对所有非叶子节点分别，依次地从最后一个非叶子节点到根节点执行下滤操作，即可使整棵树满足堆序。在排序过程中，每次原地交换后（交换当前堆顶与当前未排序部分最后一个元素），只有新堆顶影响堆序，对其执行一次下滤操作（范围为未排序部分）即可使未排序部分重新满足堆序。



### 复杂度分析

时间复杂度：原地堆排序的时间复杂度为O(NlogN)。

建堆时间复杂度: O(N)，证明如下。

以完全二叉树([complete binary tree](https://www.programiz.com/dsa/complete-binary-tree))为例，以根节点为第1层，共h层。第k层有2<sup>k-1</sup>个元素，该层每个元素至多下滤h - k次。于是所有元素最大下滤次数总和为：

<img src="https://latex.codecogs.com/gif.latex?S=\sum_{k=1}^{h}2^{k-1}(h-k)" width="150" />

<img src="https://latex.codecogs.com/gif.latex?S=h-1+2(h-2)+4(h-3)+...+2^{h-2}" width="300" />

<img src="https://latex.codecogs.com/gif.latex?2S=2(h-1)+4(h-2)+8(h-3)+...+2^{h-1}" width="330" />

下式2S减去上式S得到

<img src="https://latex.codecogs.com/gif.latex?S=-h+1+2+4+...+2^{h-1}=2^{h}-1-h" width="320" />

而总元素数为N = 2<sup>h</sup>-1，因此建堆时间复杂度为O(N)。



原地交换至排序完成时间复杂度：O(NlogN)，证明如下。

当前堆顶通过交换完成排序时，其下滤次数取决于当前树高，设当前未排序元素个数为i，其下滤次数最多为层高减1（根节点为第1层），即logi。每排序一次堆顶，待排序部分元素个数减1，于是从一个大顶堆开始完成排序所需时间取决于N - 1(N, N -1, N-2,...,2)次堆顶下滤次数总和最大值。

<img src="https://latex.codecogs.com/gif.latex?\sum_{i=2}^{N}logi" width="60" />

由[Stirling公式](https://en.wikipedia.org/wiki/Stirling%27s_approximation)得到

<img src="https://latex.codecogs.com/gif.latex?\sum_{i=2}^{N}logi=log(N!)=NlogN-Nloge+\Theta(logN)" width="320" />

于是时间复杂度为O(NlogN)。

最好情形是数组所有元素均相等，则原地交换时下滤次数为0，时间复杂度为O(N)， 平均 / 最坏时间复杂度为O(NlogN)。

空间复杂度：算法中只有常数项变量，O(1)。



### 代码

```java
public int[] heapSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // 构建大顶堆
    heapify(arr, arr.length - 1);
    // 交换堆顶和当前未排序部分最后一个元素
    // 此时除了该堆顶元素外都是保持堆序的，所以只需要对他调用一次下滤操作
    // 传入endIdx = i - 1控制下滤范围
    for (int i = arr.length - 1; i > 0; i--) { // i > 0即可，无需写成i >= 0，当N-1个元素排序时，最后一个元素也已排序
        // 此处i是下标
        swap(arr, 0, i);
        // 此处i - 1是未排序部分最后一个元素下标，传入此参数是为了确保下滤不会超过此范围
        siftDown(arr, 0, i - 1);
    }
    return arr;
}

private void heapify(int[] arr, int endIdx) {
    for (int hole = endIdx / 2; hole >= 0; hole--) {
        siftDown(arr, hole, endIdx);
    }
}

private void siftDown(int[] arr, int hole, int endIdx) {
    int target = arr[hole]; // target是要下滤的节点
    int child = hole * 2 + 1;
    while(child <= endIdx) {
        // 满足第一个条件child < len表示hole有右儿子，不满足则hole无右儿子，跳过
        // 第二个条件arr[child + 1] > arr[child]只在第一个条件成立前提下进行判断（因此不必担心arr[child + 1]越界），
        // 若满足，表示hole有右儿子且右儿子更大，令child为右儿子下标。
        // 因此此if过后使得child是hole的儿子中较大的那个
        if (child < endIdx && arr[child + 1] > arr[child]) {
            child++;
        }
        // 若child大于tmp，则child上移到当前hole，hole下滤到child位置 
        if (arr[child] > target) {
            arr[hole] = arr[child];
            hole = child;
            child = hole * 2 + 1; // 当然也可以写成child = child * 2 + 1
        } else {
            break; // 若无需交换hole与child，说明hole已经满足堆序，退出while
        }
    }
    // 将tmp填入hole中
    arr[hole] = target;
}
```



## 计数排序

### 算法描述

计数排序通常适用于整数数组，是一种利用整数特点取得线性复杂度的非比较排序方法。假设待排序数组arr为正整数数组，朴素的计数排序过程如下：

1. 创建一个计数数组countArr，其大小为arr中的最大值max再加1。
2. 遍历arr，每读取一个arr[i]，直接令countArr[i]++。
3. 从下标1开始遍历countArr，依次输出counter[i]个i，即为排序结果。

朴素做法有两个明显的缺陷，首先是无法处理负数，其次是当元素个数虽然较多，但有很多相等元素使得元素分布集中在较小范围时，max+1大小的countArr中大部分空间是多余的。改进方法很简单，即创建大小为max - min + 1的countArr，max和min分别是arr中最大和最小元素。



**稳定性：取决于是否采用稳定性优化版本。**

不采用则不稳定，采用则稳定。优化方法见后。



#### **稳定性优化**

经过上述改进的计数排序仍存在一个稳定性缺陷，即通过计数来排序，当遍历到countArr[i]时，只是连续地输出countArr[i]次i + min，稳定性得不到保证。可以通过对countArr进行变形来满足稳定性，使得遍历到同一个数字，例如k时，能够将不同位置的k按他们在arr中出现的顺序放入到输出数组中。具体做法是在得到countArr后，遍历一次countArr，使得每一个countArr[i]的值都是从countArr[0]到countArr[i]中值不为0的项的值之和。例如对于待排序数组{5, 5, 4, 4, 1, 1}，得到countArr为{2, 0, 0, 2, 2}，表示有两个1，0个2，0个3，2个4，2个5。按照前述方法将其变形为{2, 0, 0, 4, 6}，表示1的最大位置为第2位(下标为1)，4的最大位置为4(下标为3)，5的最大位置为6(下标为5)。在输出排序结果时，新建一个大小等于arr的sortedArr数组，于是countArr[arr[i] - min] - 1即为arr[i]这个数应当放入sortedArr的位置(下标)，即sortedArr[countArr[arr[i] - min] - 1] = arr[i]，从0遍历到arr.length - 1，每次向sortedArr填入一个数字后，令countArr[arr[i] - min]--。遍历结束后得到的sortedArr即为arr的稳定排序结果。



### 复杂度分析

时间复杂度：朴素版为O(max)，max为原数组中最大值。改进版为O(N + M)，N为元素个数，M为最大最小值只差。当元素个数较少但差值很大时，复杂度取决于M。

空间复杂度：不考虑输入数组arr，朴素版为O(M)，countArr的大小为M+1。优化版为O(N + M)，N为sortedArr的大小，等于arr的大小。



### 代码

#### 不稳定计数排序

```java
public int[] countSortUnstable(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    int min = arr[0];
    int max = arr[0];
    for (int i = 1; i < arr.length; i++) {
        min = Math.min(min, arr[i]);
        max = Math.max(max, arr[i]);
    }
    int[] countArr = new int[max - min + 1];
    for (int i = 0; i < arr.length; i++) {
        countArr[arr[i] - min]++;
    }
    int index = 0;
    for (int i = 0; i < countArr.length; i++) {
        for (int j = 0; j < countArr[i]; j++) {
            arr[index] = i + min;
            index++;
        }
    }
    return arr;
}
```



#### 稳定计数排序

```java
public int[] countSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    int min = arr[0];
    int max = arr[0];
    for (int i = 1; i < arr.length; i++) {
        min = Math.min(min, arr[i]);
        max = Math.max(max, arr[i]);
    }
    int[] countArr = new int[max - min + 1];
    for (int i = 0; i < arr.length; i++) {
        countArr[arr[i] - min]++;
    }
    // countArr变形
    int sum = 0;
    for (int i = 0; i < countArr.length; i++) {
        // 一处小改进，当输入数组取值比较稀疏时，该判断能避免大部分无意义的赋值操作
        if (countArr[i] != 0) {
            sum += countArr[i];
            countArr[i] = sum;
        }
    }
    // 根据sortedArr, nums, countArr三者关系完成sortedArr的输出
    int[] sortedArr = new int[arr.length];
    for (int i = 0; i < arr.length; i++) {
        sortedArr[countArr[arr[i] - min] - 1] = arr[i];
        countArr[arr[i] - min]--;
    }
    return sortedArr;
```



## 桶排序

### 算法描述



### 复杂度分析



### 代码



## 基数排序

### 算法描述



### 复杂度分析



### 代码



## 决策树



## JDK中的排序



## 例题

消除逆序数