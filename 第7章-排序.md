# 第7章-排序



## 思维导图



## 总结



## 冒泡排序

### 算法描述

对于要排序的数组，从第一位开始从前往后比较相邻两个数字，若前者大，则交换两数字位置，然后比较位向右移动一位。也就是比较arr[0]和arr[1]，若arr[0] > arr[1]，交换arr[0]和arr[1]。接着比较位移动一位，比较arr[1]和arr[2]，直到比较到arr[N-1]和arr[N] (N = arr.length - 1)。第1轮从前到后的比较将使得最大的数字“冒泡”到最后，此时可以说一个数字已经被排序。每一轮的比较将使得当前未排序数字中的最大者被排序，未排序数字总数减1。第arr.length - 1轮结束后排序完成。



### 优化

当某一轮比较均未发生交换，说明排序已完成，可设置一个flag记录一轮排序是否有发生交换，若无则提前退出循环结束程序。



### 复杂度分析

时间复杂度：两层for循环，第1轮比较len - 1次(len = arr.length)，最后一轮比较1次。总比较次数为len*(len - 1) / 2次，时间复杂度为O(N^2)。

空间复杂度：算法中只有常数项变量，O(1)。



### 代码

```java
public int[] bubbleSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // N-1轮次执行，当前N-1个元素排好后，最后一个元素无需执行，故i < arr.length - 1
    for (int i = 0; i < arr.length - 1; i++) {
        // 本轮执行是否有交换的标志，若无则true，若有则false
        boolean flag = true;
        // 每轮循环，通过依次向右比较两个数，将本轮循环中最大的数放到最右
        for (int j = 1; j < arr.length - i; j++) {
            // 若左大于右则交换，并将flag置为false
            if (arr[j - 1] > arr[j]) {
                swap(arr, j - 1, j);
                flag = false;
            }
        }
        // 若无交换，表示当前数组已完全排序，退出大循环
        if (flag) {
            break;
        } 
    }
    return arr;
}
```



## 选择排序

### 算法描述

对于要排序的数组，设置一个minIdx记录最小数字下标。先假设第1个数字最小，此时minIdx = 0，将arr[minIdx]与后续数字逐一比较，当遇到更小的数字时，使minIdx等于该数字下标，第1轮比较将找出此时数组中最小的数字。找到后将minIdx下标的数字与第1个数字交换，此时可以说一个数字已被排序。然后开始第2轮比较，令minIdx = 1，重复上述过程。每一轮的比较将使得当前未排序数字中的最小者被排序，未排序数字总数减1。第arr.length - 1轮结束后排序完成。



### 优化

在交换前判断下minIdx是否有变化，若无变化则无需交换。当数组大致有序时，能够比较大量无效交换带来的开销。



### 复杂度分析

时间复杂度：两层for循环，第1轮比较len - 1次(len = arr.length)，最后一轮比较1次。总比较次数为len*(len - 1) / 2次，时间复杂度为O(N^2)。

空间复杂度：算法中只有常数项变量，O(1)。



### 代码

```java
public int[] selectSort(int[] arr) {
    if (arr.length < 2) {
        return arr;
    }
    // N-1轮次执行,当前N-1个元素排好后，最后一个元素无需执行，故i < arr.length - 1
    for (int i = 0; i < arr.length - 1; i++) {
        int minIdx = i;
        // 找到本轮执行中最小的元素，将最小值下标赋值给min
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[minIdx])
                minIdx = j;
        }
        // 若本轮第一个数字不是最小值，则交换位置（将最小值与本轮第一个数字交换位置）
        if (minIdx != i) {
            swap(arr, i, minIdx);
        }
    }
    return arr;
}
```



## 简单插入排序

### 算法描述



### 复杂度分析



### 代码

```java

```



## 希尔排序

### 算法描述



### 复杂度分析



### 代码



## 归并排序

### 算法描述



### 复杂度分析



### 代码



## 快速排序

### 算法描述



### 复杂度分析



### 代码



## 堆排序

### 算法描述



### 复杂度分析



### 代码



## 计数排序

### 算法描述



### 复杂度分析



### 代码



## 桶排序

### 算法描述



### 复杂度分析



### 代码



## 基数排序

### 算法描述



### 复杂度分析



### 代码