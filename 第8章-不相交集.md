# 第8章-不相交集(并查集)



## 基本概念

不相交集，如其名，是一种描述不相交集合的数据结构。若一个问题涉及多个元素，它们属于不同的集合，同属一个集合内的元素等价，不同集合内的元素不等价。当我们问某些元素是否等价时，就可以用不相交集来解决，或者说不相交集就是用于解决该问题的数据结构。不相交集通常也叫并查集，“不相交”描述的是问题对象抽象为集合之后的状态，“并查”描述的是这类数据结构用于处理问题时进行的操作。

本章余下内容，我们会以亲戚问题来理解不相交集及其并查操作。所谓亲戚问题，是指在一群人中随机指定两个人，问他们是否有亲戚关系（是否等价）。如果我们将所有人划分为不同的集合，有亲戚关系的人都在同一个集合里，没有亲戚关系的人分属不同的集合。询问两个人是否有亲戚关系，也就是问两个元素是否在同一个集合里，显然可以用不相交集来处理。当我们以一个集合里的某个元素作为整个集合的代表时，容易想到以树的结构来实现，根节点作为代表元。对于所有元素，当不相交集形成后，查询两个节点元素的根是否相同，即可知道他们属于同一集合。

不相交集处理问题的过程主要包括初始化、设置代表元、合并和查询。



## 处理问题的过程

以树的语言来说明不相交集如何处理上述亲戚问题。

#### **初始化**

将所有元素存入一个数组group[]，令每元素的亲戚是自己，例如group[a] = a。此时每个节点都是以自己为根的单节点树。

```
// 初始化伪代码
int group[];
init(){
    for(int i = 0; i < group.length; i++){
        group[i] = i; // 以int代表每个元素
    }
}
```

#### **设置代表元**

一开始我们设置代表元，即每一个人都至少知道一个(自己之外)的亲戚，例如group[a] = b，group[b] = c等等。设置代表元通常在main方法里执行。不难理解，输入本身已经蕴含了问题的答案。例如询问x和y是否具有亲戚关系，只需要不断查询x和y的亲戚，亲戚的亲戚，直到通过亲戚链找到同一个人，那么x和y有亲戚关系，否则没有。这步操作后，我们得到N(N是元素总数)个由两个节点构成的集合。for循环内的union是接下来要介绍的合并方法。

（图）

```
// 初始设置代表元伪代码
// 初始的亲戚关系由person[]和relative[]一一对应给出
for(int i = 0; i < group.length; i++){
    union(person[i], relative[i]);
}
```

这里需要强调的是，我们的问题只关心x和y是否有亲戚关系，所以一开始选谁做根(代表元)是无关紧要的，无论选谁，不断询问后总能确定他们是否有亲戚关系。在前面已经提到过，我们的目的是要将所有亲戚放在一个集合里，并且让每一个元素都知道该集合的根（代表元），当我们在得到这种不相交集的形式后，再来询问x和y是否具有亲戚关系，就可以直接比较他们的代表元，即问if(group[x] == group[y])。

总之我们需要将当前的2元素集合合并成这样的状态：合并后每个集合内的人都互为亲戚，group[]均为同一个人，不同集合内的人没有亲戚关系。

#### **合并**

合并的依据是查询，查询x和y，如果find(x) = find(y)，说明代表元相同，属于同一集合。此时令group[find(y)] = find(x)（ 或group[find(x)] = find(y) ）。从树的角度来看相当于把y挂在了x上。find(x)是接下来会介绍的查询操作，该方法返回x的代表元。

```
// 合并伪代码
union(x, y){
    group[find(y)] = find(x);
}
```

在确定代表元的步骤里，我们提到最初要先把每个人的一个亲戚确定下来，实际上就是两个单元素集合的求并。可是除了确定代表元时初始输入告诉我们的亲戚关系，可以容易地将两个元素合并起来，但接下来该怎样继续执行合并呢？答案是，我们在查询时合并。

#### **查询**

由于不相交集都是一棵树，故可以用递归的方式查询一个节点的根节点(代表元)。

```
// 查询伪代码
find(x){
    if(group[x] == x){ // 只有代表元满足 group[x] = x
        return x;
    } else{
        return find[group[x]]; // 如果不满足，递归地查找当前节点父节点(group[x])的代表元
    }
}
```

实际考察下上述做法的效果。如下图，问1和3是否有亲戚关系。

（图）

求解时先执行find(1)，我们可以想办法记录经过的所有父节点，例如find(1)记录下4, 3, 1。接着find(3)，记录下1, 4, 3，显然可以判断1, 3, 4互为亲戚，于是可以将1, 3, 4以某种形式拼接成一棵树。但这样做比较繁琐，需要分别执行查询得到两份记录，再进行对比，然后才能合并。实际上find()执行时就已经能够实时地修改父节点指向来达到合并的效果。适当的修改不但能将查询链路上的所有节点加入到同一节点，还使得每个节点都指向根节点代表元，实现路径压缩的效果。



## 路径压缩

只需改动else时的动作，将递归的find[group[x]]赋值给group[x]，就可以让当前查找的节点到根节点路径上所有的节点都指向根节点，如下。

```
// 带合并的查询伪代码
find(x){
    if(group[x] == x){ // 只有代表元满足 group[x] = x
        return x;
    } else{
        group[x] = find(group[x]); // 将递归查找父节点的结果作为当前节点的父节点
        return group[x]; // 每次回归都返回当前节点的父节点(已经被赋值为根节点了，所以每次都返回根节点)
    }
}
```

这种做法使得一次查询，将一个集合中所有的元素都指向这个集合的根(代表元)，也就完成了沿着父节点链上的节点的合并。如前面的例子，在执行完find(1)后如下，find(1) = 1，查询过程中3加入以1为根节点的集合，且直接指向根节点。之后再查询find(3)，就能立即(不用经过递归)得出find(3) = 1，也即两者为亲戚关系。

由于这种操作使得集合中每一个元素能直接连接到根，于是这种实现也叫**路径压缩**。



## 更好的求并

到目前为止，我们介绍的不相交集操作中的Union方法，只在设置代表元时用于组成一个个的2元素集合构成初始集合状态，其余的合并均发生在find()操作中。对于亲戚问题，前述的操作已经足够解决该问题。但若问题涉及到主动合并（以union而非find方法合并）某些集合，例如要求合并下面两个集合，如果仍以group[find(y)] = find(x);简单地将y所在树的根挂到x所在树的根形成新树，那么得到一棵树高较小的树将是一个更好的选择。



#### 按大小求并

若一棵树拥有越多的节点，其高度倾向于越高。所以我们可以通过比较两棵树的大小，将较小树的根连接到较大树的根完成合并。可以新建一个数组保存树的高度。

初始化代码需要添加保存集合(树)大小的数组和该数组的初始化内容。

```
// 初始化伪代码
int group[];
int size[];
init(){
    for(int i = 0; i < group.length; i++){
        group[i] = i; // 以int代表每个元素
        size[i] = 1; // 初始时每个集合(单节点集)大小为1
    }
}
```

```
// 按大小求并
union(x, y){
    int i = find(x);
    int j = find(y);
    if(size[j] <= size[i]){
        group[y] = i;
        size[i] += size[j];
    } else {
        group[x] = j;
        size[j] += size[i];
    }
}
```



#### 按秩(高度)求并

直接按高度求并，比按大小求并能更准确地使每次合并后的新树高度较小。且不同与按大小求并时每次合并均修改新树的大小信息，按高度求并，新树的高度变化只发生在两棵树高度相等时。

```
// 按高度(秩)求并
union(x, y){
    int i = find(x);
    int j = find(y);
    if(height[j] <= height[i]){
        group[y] = i;
    } else {
        group[x] = j;
    }
    // 当两棵树大小相等且原属不同集合时，新树的高度加1
    if(height[i] == height[j] && i != j){
        height[i]++; // 注意，size[j]不需要加1，因为每次求一个元素所在集合的高度都会先找到该集合的树的根
    }
}
```



## 基本数据结构

通过上述对实际问题处理过程的讲解，我们已经给出了能够处理集合代表元查询及合并问题的不相交集数据结构。在按大小或按高度求并时，另外新建了保存大小或高度信息的数组。如果元素的表示不涉及负数（在本章例子中用正整数表示元素）的话，可以用一个巧妙的方法，避免大小或高度数组的开销。一开始我们在初始化集合时，令每一个元素的父节点指向自己，即group[x] = x，表示这是根节点。我们可以group[x] = -1表示根节点，使得如果一个元素的group[x]为负数时，这个元素就是所在树(集合)的根节点。在按大小求并时，以当前根节点的group[root]值减去加入的树的大小的结果来更新group[root]。在按高度求并时，新树高度加一时令height[root]--。

我们将这个技巧应用到实际代码中，给出不相交集的完整实现。

```java

```



## 复杂度分析



## 例题

在“处理问题的过程”中我们介绍了应用处理不相交集问题的通用过程，但对于不同的具体问题，有些步骤并不是必须的。

我们将本节例题中看到，同样是应用不相交集，对于[LeetCode 128: 最长连续数列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)，只需在find()时以路径压缩方式合并，除设置代表元时用到主动合并(union())外，不再涉及union()。在另一个问题[LeetCode 547: 省份数量](https://leetcode-cn.com/problems/number-of-provinces/)中，没有设置代表元步骤，但需要主动合并。相对地，find()中可以不带合并(路径压缩)，当然，也可以带路径压缩以提高效率。



### LeetCode 128: 最长连续数列



### LeetCode 547: 省份数量