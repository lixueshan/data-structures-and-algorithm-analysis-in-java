# 第9章-图论算法



## 思维导图



<br />

## 基本概念

| 概念                                        | 描述                                                         |
| ------------------------------------------- | ------------------------------------------------------------ |
| 图 <br />graph                              | 由顶点集合V和边集合E组成                                     |
| 边 <br />edge                               | 一对点 $(v, w), v, w ∈ V$                                    |
| 有向图 <br />directed graph / digraph       | 点对有序的图，$(v, w)$ 与 $(w, v)$ 为两条不同的边            |
| 无向图 <br />undirected graph               | 点无序的图，$(v, w)$ 与 $(w, v)$ 为同一条边                  |
| 邻接 <br />adjacent                         | 顶点 $w$ 与 $v$ 邻接当且仅当 $(w, v) ∈ E$                    |
| 权 / 值 <br />weight / cost                 | 边的权重                                                     |
| 路径 <br />path                             | 为一顶点序列 $w_1, w_2, w_3,...,w_N$ 使得 $(w_i, w_{i+1}) ∈ E, 1<=i<=N$ <br />一个顶点到他自身也可以看成是一条路径，如果路径不包含边，则路径长为 0 |
| 路径长<br />path length                     | 路径上边的数量                                               |
| 简单路径                                    | 路径上的所有顶点都是不同的，但第一个和最后一个可能可以相同   |
| 环 <br />loop                               | 一个顶点到它自身的边 $(v, v)$ ，本章讨论的图一般都是无环的   |
| 圈<br />cycle                               | 满足 $w_1 = w_N$ 的长至少为 1 的路径                         |
| 有向无圈图<br />directed acyclic graph, DAG | 无圈的有向图                                                 |
| 连通图<br />connected graph                 | 从一顶点 $w$ 到另一顶点 $v$ 有路径相连称 $w$ 与 $v$ 连通，任意两顶点之间连通的图称为连通图。对于有向连通图，两点之间的路径上的边必须同向 |
| 强连通<br />strongly connected              | 称有向连通图是强连通的                                       |
| 基础图<br />underlying graph                | 有向图去掉边的方向后的图称为该有向图的基础图                 |
| 弱连通<br />weakly connected                | 有向图不是强连通的，但其基础图是连通的，则称该有向图是弱连通的 |
| 完全图<br />complete graph                  | 每一对顶点间都有边相连的图                                   |
| 邻接矩阵<br />/adjacent matrix)             | 对每条边 $(u, v)$ 置矩阵的 $A[u, v]$ 为 $true$，无 $(u, v)$ 边则为 $false$，若边有权，则 $A[u, v]$ 等于该值，以一个很大或很小的数表示该边不存在 |
| 邻接表<br />adjacency list                  | 以邻接矩阵表示图，当图较稀疏时空间代价为 $|V|^2$，针对这种情况，对稀疏图可以采用邻接表来表示，对每一个顶点，以一个表存放其邻接顶点，则空间降为 $|V|+|E|$，相对图的大小而言是线性的 |
| 入度<br />indegree                          | 对有向图顶点 $v$ 而言，$(u, v)$ 边的数量                     |
| 出度<br />outdegree                         | 对有向图顶点 $v$ 而言，$(v, u)$ 边的数量                     |

<br />

## 图算法一览

| 分类       | 算法             | 时间复杂度 | 空间复杂度 |
| ---------- | ---------------- | ---------- | ---------- |
| 图遍历     | $bfs$            |            |            |
|            | $dfs$            |            |            |
| 拓扑排序   | $Kahn(bfs)$      |            |            |
|            | $dfs$            |            |            |
| 最短路     | $Dijkstra$       |            |            |
|            | 朴素版           |            |            |
|            | 优先队列版       |            |            |
|            | $Bellman-Ford$   |            |            |
|            | $SPFA$           |            |            |
|            | $Floyd$          |            |            |
| 最大流     | $Ford-Fulkerson$ |            |            |
|            | $Edmonds-Karp$   |            |            |
|            | $Dinic$          |            |            |
| 最小生成树 | $Prim$           |            |            |
|            | $Kruskal$        |            |            |

<br />

## 图的表示

图的基本信息是顶点、边、边的方向 (有向图)以及边权 (赋权图)，因此图的数据结构需要能够组织这些信息。图的表示方法主要有「邻接矩阵」及「邻接表」。

<br />

### 邻接矩阵

假设顶点都以从 0 开始的非负整数连续编号，那么可以用二维数组 $edges[][]$ (或者二维容器) 表示图，其中 edges\[i][j] 表示顶点 $i$ 指向顶点 $j$ 的边，其值表示边权。若为无权图，可令值为 1 或 0 。若边不存在，可令值为 -1 。邻接矩阵表示法所需空间为 $O(|V|^2)$，当图较稀疏时，大量空间被浪费。空间利用率更好的表示法是「邻接表」表示法。

<br />

### 邻接表

对每一个顶点，以一个列表来存储其邻接顶点和相应的边权信息，因此将有 $|V|$ 个列表，所有这些列表存储了 $|E|$ 条边的信息，因此邻接表所需空间为 $O(|V|+|E|)$ 。需要访问一个顶点的所有邻接顶点时，只需遍历该顶点持有的邻接顶点列表即可。

通常以邻接表来表示图。若顶点不是非负整数，而是字符串或其他引用类型，那么可以哈希表表示图，key为顶点 (字符串或其他引用类型)，value仍是列表，内部存储

<br />

### 图数据结构



```java

```

<br />

## 初探图搜索 (遍历)

图的搜索 ($search$) 或者说遍历  ($traversal$) 算法是其他更高级的图论算法的基础，因此熟练掌握图的搜索算法非常重要。**「搜索」** 一词的重点在于关注图中的一个 $target$ ，可以是顶点，也可以是边，找到即完成任务；**「遍历」** 一词的重点在于对整张图无遗漏地探索，多数时候这两个词是通用的。如同「树」的 **深度优先搜索**  ($dfs$) 和 **广度优先搜索**  ($bfs$)，图的基本搜索方法也是这两种。实际上我们知道树是一种特殊的图，后文在有必要时我们会将二者进行对比。

$bfs$ 和 $dfs$ 的内容非常丰富，可用于解决许多图上的问题，但只需掌握其基本写法，就足以支撑我们学习后续更高级的图论算法，因此本节只以如下两道基本题目引入并详细介绍最基本的 $bfs$ 和 $dfs$ 写法。关于此二者更丰富的应用，我们将在「再探图搜索 (遍历)」中叙述。

> 

### 无向图连通性

#### BFS

<br />

#### DFS

<br />

### 有向图连通性

#### BFS

<br />

#### DFS

<br />

### 无向图判圈

#### BFS

<br />

#### DFS

<br />

### 有向图判圈

#### BFS

<br />

#### DFS

<br />

## 拓扑排序

[拓扑排序 (Topological Sorting)](https://en.wikipedia.org/wiki/Topological_sorting) 是对有向图的顶点的排序，如果存在从顶点 $u$ 到顶点 $v$ 的路径，那么拓扑排序要求 $u$ 一定在 $v$ 之前，一定不能出现 $v$ 在 $u$ 之前的排序结果。由此可以看出，拓扑排序存在的前提是 **有向图无圈 **。且只要图为 $DAG$ (Directed Acyclic Graph)，则该图 **至少有一种拓扑排序** 。此外，是否存在拓扑排序与图是否存在不连通的分量无关，这是显然的，因为互不连通的分量互不依赖，在拓扑排序中这些分量的顺序是任意的。

拓扑排序的主要实现为基于 $BFS$ 的 **「Kahn算法」** 以及基于 $DFS$ 的 **「Tarjan拓扑排序算法」** 。我们将看到，这两种算法实现的拓扑排序在求解过程上是 **「互逆」** 的。wiki 中对拓扑排序有如下更准确的说明，后续我们会再次提到该表述。

> Precisely, a topological sort is a graph traversal in which each node $v$ is visited only after all its dependencies are visited*.* 
>
> 更准确地，拓扑排序是对图的一种遍历，在这种遍历中，对一个顶点 $v$ 的访问只发生在它所依赖的顶点被访问之后。

※ 大家思考过为什么这种排序要冠以「拓扑」之名吗？根据作者有限的了解，「拓扑学 (Topology)」研究的是平面或立体图形 (多维?) 连续变形过程中的性质。说一个什么事物是「拓扑的 (Topological)」似乎在表达这个事物变形前后的关系，看起来「拓扑排序」跟数学上的「拓扑」并没有什么关联，因为点或边并未有什么变化。作者查了一下，这篇讨论 [Why is "topological sorting" topological?](https://cstheory.stackexchange.com/questions/30659/why-is-topological-sorting-topological) 的高赞回答表示该命名大概只是想体现 "network topology" 的味道 (sense)。

作者点评: 适当地探索一个算法甚至一个词语的「语源」，能够加深我们对其的理解🤔。



为了能更快地应用拓扑排序算法，我们直接给出 [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) 的代码，该题目描述的内容常作为介绍拓扑排序的一个经典的现实例子，具体看原题描述。更多相关题目请参考「实战应用」。

<br />

### Kahn算法 (BFS)

#### 算法描述

[Kahn算法](https://en.wikipedia.org/wiki/Topological_sorting)：基于 $BFS$ 的拓扑排序算法。之前我们提到过「拓扑排序准确表述」，该算法通过入度信息很好地体现了「表述」，即当访问一个顶点 $v$ ，若其 **「入度」** 为 0 ，即说明它所依赖的顶点一定已经被访问过了。具体来说，先计算所有顶点的入度，然后将入度为 0 的顶点放入队列中，从队列输出队首顶点并依次将其所有 **邻接顶点入度减 1** ，每一个邻接顶点入度减 1 后，判断其入度是否减至 0 ，若为 0 将其入队。重复上述过程，直到队列为空 (所有顶点均已入队又出队)。容易看出，一个顶点入度减至 0 ，**当前仅当** 它所依赖的顶点的入度在此之前已减至 0。算法结束时，顶点出队的顺序即为拓扑排序，这是一个 **「顺序」** 拓扑排序过程。

若某个节点出队时对其存在的邻边入度减 1 后，若这些邻边入度均未减至 0，则说明该图 **有圈** 。可以通过在 $while$ 结束后考察 **出队顶点数与总顶点数是否相等** 来判圈。

> A. B. Kahn于1962年发表的 [Topological Sorting of Large Networks ](https://dl.acm.org/doi/pdf/10.1145/368996.369025) 论文中描述了该算法。

<br />

#### 算法过程

算法的详细过程如下，也即该算法求解拓扑排序问题时的编程范式。具体代码见「代码」部分，但在参考之前，若你有时间，应当通过此处给出的算法过程尝试自己写出。

1. 根据输入建图及计算入度。
    
  1. 建图。
  
       一般可用哈希表 $Map<k, v>$ 来存储图信息，$k$ 为顶点，$v$ 为该顶点的邻接顶点列表。当顶点为一组连续整数时 (通常为 $\{0,1,2,...,n-1\}$，$n$ 为顶点总数)，用 `List<List<Integer>>` 存图效率更高，下标表示顶点，其对应的 `List<Integer>` 即为该顶点的邻接顶点表。通过下标可快速获取顶点的邻接表。
  
  2. 计算入度。
  
     入度信息一般用大小为顶点数的数组 $indegrees[]$ 表示，入度计算通常与建图同时进行。遍历输入信息，遇到边 $(u, v)$ 时，执行 `indegree[v]++` 。当所有边都被考察后，入度信息即已完备。
  
2. 拓扑排序。
     有了入度信息和图信息，开始拓扑排序。

     1. 设置一个队列 $q$ 、一个用于保存拓扑排序结果列表 $res$ 、一个用于判断图是否有圈的计数变量 $count$ 。
     2. 遍历 $indegrees$ 数组将入度为 0 的顶点入队 (若已知图为有向无圈 **连通图** ，则 **有且只有一个** 顶点入度为 0，可在找到后立即跳出遍历)。
     3. 以一个 $while$ 检查当前队列是否为空，不空则队首顶点 $u$ 出队，放入输出结果 $res$ 中。同时 `count++` ，表明 $u$ 已被排序。
     4. 遍历 $u$ 的邻接顶点 $v$ ，使 $v$ 的入度减 1，并检查减 1 后是否为 0 ，为 0 则 $v$ 入队。
     5. 当 $while$ 结束后，在返回前判圈。 **图有圈则存在入度不可能减至 0  的顶点** ，则已拓扑排序 (已出队) 的顶点个数 $count$ 必小于顶点总数。若满足 $count == n$ 则返回拓扑排序结果，否则无结果。

<br />

#### 时空复杂度

**时间复杂度: **

1. 建图及计算所有顶点入度需遍历所有边，时间复杂度为 $O(|E|)$。
2. 队列中每个顶点均入队一次，出队一次，$O(|V|)$ 。
3. 更新并检查邻接顶点的 $for$ 中，更新和检查的总次数等于边数 $O(|E|)$ 。

故总的时间复杂度为 $O(|V|+|E|)$ 。**若图是连通的** ，由于 $|E| ≥ |V|$ (仅在 $|V| = 2$，且只有一条边时 $|E| < |V|$)，因此通常也可以粗略地记做 $O(|E|)$ 。

**空间复杂度:** 取决于队列长度，任意时刻队列中的顶点数  $≤|V|$ ，故空间复杂度为 $O(|V|)$ 。

<br />

#### 代码

Kahn 拓扑排序算法实现 [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) 。在掌握了 $BFS$ 算法写法及理解Kahn算法过程的基础上，我们很容易写出如下代码。

第一份代码以 **哈希表** 存图，适合于无法用连续的整数来表示顶点的场景。本题中，顶点可以被表示为 $\{0, 1,2,3,...n - 1\}$ ，因此采用第二份以 **线性表** 存图的代码效率更高。此写法为普遍的标准的 Kahn 拓扑排序写法，读者应对该写法 **熟稔于心** 。

```java
// 以HashMap存图
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // 1. 【建图 + 计算入度】
        int[] res = new int[numCourses], indegrees = new int[numCourses];
        Map<Integer, List<Integer>> graph = new HashMap<>();
        for(int[] edge : prerequisites){ // 建图 & 计算入度
            int v = edge[0], u = edge[1]; // u是v的先修课程, u -> v
            List<Integer> adjs = graph.getOrDefault(u, new ArrayList<>()); // u的邻接表
            adjs.add(v); // v为u的邻接顶点
            graph.put(u, adjs);
            indegrees[v]++; // v的入度加1
        }
        // 2. 【拓扑排序】
        // 2-1. 遍历入度数组，将入度为 0 的顶点入队。
        int count = 0;
        Queue<Integer> q = new ArrayDeque<>();
        for(int u = 0; u < numCourses; u++){ // 找到入度为0的顶点并入队
            if(indegrees[u] == 0) q.add(u);
        }
        // 2-2. 利用队列完成拓扑排序
        while(!q.isEmpty()){
            int u = q.remove();
            res[count++] = u; // 入度为0，输出到res，同时count++
            List<Integer> adjs = graph.get(u);
            if(adjs != null){ // 有的顶点可能无邻接顶点
                for(int v : adjs){
                    indegrees[v]--; // v的入度减1
                    if(indegrees[v] == 0) q.add(v);
                }
            }
        }
        // 2-3. 返回前判圈。
        return count == numCourses ? res : new int[]{}; 
    }
}
```



```java
// 以List存图
class Solution {
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // 1. 【建图 + 计算入度】
        int[] res = new int[numCourses], indegrees = new int[numCourses];
        int n = prerequisites.length;
        List<List<Integer>> graph = new ArrayList<>();
        for(int i = 0; i < numCourses; i++) graph.add(new ArrayList<>());
        for(int[] edge : prerequisites){ // 建图 & 计算入度
            int v = edge[0], u = edge[1]; // u是v的先修课程，u -> v
            graph.get(u).add(v); // v为u的邻接顶点
            indegrees[v]++; // v的入度加1
        }
        // 2. 【拓扑排序】
        // 2-1. 遍历入度数组，将入度为 0 的顶点入队。
        int count = 0;
        Queue<Integer> q = new ArrayDeque<>();
        for(int u = 0; u < numCourses; u++){ // 找到入度为0的顶点并入队
            if(indegrees[u] == 0) q.add(u);
        }
        // 2-2. 利用队列完成拓扑排序
        while(!q.isEmpty()){ 
            int u = q.remove();
            res[count++] = u; // 入度为0，输出到res，同时count++
            for(int v : graph.get(u)){
                indegrees[v]--; // v的入度减1
                if(indegrees[v] == 0) q.add(v);
            }
        }
        // 2-3. 返回前判圈。
        return count == numCourses ? res : new int[]{}; 
    }
}
```

<br />

### Tarjan拓扑排序算法 (DFS)

#### 算法描述

[Tarjan拓扑排序算法](https://en.wikipedia.org/wiki/Topological_sorting)：基于 $DFS$ 的拓扑排序算法。回顾之前提到的「拓扑排序准确表述」中的「对一个顶点 $v$ 的访问只发生在它所依赖的顶点被访问之后」，我们从中可以嗅到「层层深入」的味道，即对于 $v$ ，「层层深入」它所依赖的顶点后访问到它，这是一个 $dfs$ 的过程，「表述」中要求，完成 $v$ 的访问的前提是完成它所依赖的顶点的访问，那么我们可以在 $dfs$ 到 $v$ 的过程中，**「缓存」** 路径上 $v$ 所依赖的顶点的状态 (即暂不处理)，当我们要处理 $v$ 的时候，已经保证了它所依赖的顶点会在此后「回溯」的过程中处理，因为它们此刻都在 **递归栈的更靠顶部的空间中 (也就是在返回路径上)** 缓存着。换句话说，我们只需要将 $v$ 放在当前用于存放拓扑排序结果的空间的最后侧 (这是栈的特点，称之为结果栈)，此后的回溯一定会将它所依赖的顶点放在它的前面。那么我们什么时候处理 $v$ 呢？自然是无法从它再深入到任何顶点的时候，可以是其无 (依赖关系的) 后继顶点，也可以是其后继顶点均已被排序 (被放入结果栈中)。理解了这一点，我们即可给出如下 Tarjan 拓扑排序的主要过程。建图过程无需多言。

顶点在算法过程中有三个状态， **未搜索，搜索中、已完成 (访问)** 。算法从遍历顶点开始，每遇到一个「未搜索」的顶点 $u$ ，就以其为起点开始 $dfs$ 。进入 $dfs$ 方法时我们首先将 $u$ 标记为「搜索中」，然后以 $for$ 循环依次考察 $u$ 的邻接顶点 $v$ 。

- 若其状态为「未搜索」，对其递归调用 $dfs$ ，重复前述过程。
- 若其状态为「搜索中」，表明我们此前进入过 $v$ 的 $dfs$ 过程，而此时又遇到了 $v$ ，显然 $v$ 是通过一个圈回到了 $v$。于是将 $hasCycle$ 标记为 $true$ 并返回。
- 注意我们不必处理「已完成」的 $v$ ，无判断分支会直接跳过。

如前一段所说，当 $u$ 无法再深入到任何顶点时，我们标记其状态为「已完成」。每以一个「未搜索」的顶点为起点完成 $dfs$ ，我们就检测一次 $hasCycle$ 是否为 $true$，是则结束，否则当程序终止时，顺序输出结果栈即为正确的拓扑排序。

> 该算法并不总是被冠以 Tarjan 之名，在 wiki 中有下面这段话，用的是「...seems to...」。另外，Cormen et al. (2001) 指的是那本著名的「算法导论」。
>
> This depth-first-search-based algorithm is the one described by [Cormen et al. (2001)](https://en.wikipedia.org/wiki/Topological_sorting#CITEREFCormenLeisersonRivestStein2001), it seems to have been first described in print by Tarjan in [1976](https://link.springer.com/article/10.1007/BF00268499).



※ 之所以称「Tarjan拓扑排序算法」而非「Tarjan算法」，是因为由 [Tarjan](https://en.wikipedia.org/wiki/Robert_Tarjan) 发明或合作发明或有重大贡献的算法和数据结构非常之多，如「[最近公共祖先(LCA)](https://en.wikipedia.org/wiki/Lowest_common_ancestor#History)」、「[强连通分量(SCC)](https://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm#cite_note-Tarjan-1)」、「[伸展树 (Splay Tree)](https://en.wikipedia.org/wiki/Splay_tree)」、「[斐波那契堆 (Fibonacci Heaps)](https://en.wikipedia.org/wiki/Fibonacci_heap)」、「[并查集 (Union-Find Set)](https://en.wikipedia.org/wiki/Disjoint-set_data_structure)」等等。狭义上的「Tarjan算法」指的是「强连通分量」算法。实际上将基于 $BFS$ 的拓扑排序算法冠以 Kahn 之名比之将基于 $DFS$ 的拓扑排序冠以 Tarjan 之名更为流行，原因除了前者发明时间更早，且更易于理解之外，还在于后者只是 Tarjan 所发明的「强连通分量」算法的副产品，而未作为一个独立的算法发表 (由此也可见 Tarjan 之强大)。详见 [Does Tarjan's SCC algorithm give a topological sort of the SCC?](https://stackoverflow.com/questions/32750511/does-tarjans-scc-algorithm-give-a-topological-sort-of-the-scc)。

> ... And his algorithm (SCC) also does topological sorting **as a byproduct**. ---- by Knuth

<br />

#### 算法过程

算法的详细过程如下，也即该算法求解拓扑排序问题时的编程范式。具体代码见「代码」部分，但在参考之前，若你有时间，应当通过此处给出的算法过程尝试自己写出。

1. 根据输入建图及准备 $visited$ 数组、 $hasCycle$ 布尔值、拓扑排序结果栈 $res$ 以及栈底下标 $idx$ (初始时为 $|V| - 1$)。

   1. 建图。与 kahn 算法一致。

   2. $visited$ 数组下标为顶点，有三种取值，表示顶点在拓扑排序过程中的三种状态。0: 未搜索 1: 搜索中 2: 已完成 (搜索)。初始时 $hasCycle = false$ 。

2. 拓扑排序。遍历所有顶点，对「未搜索」状态的顶点 $u$ 执行 $dfs$ 。

   1. 进入 dfs 后，首先置 $visited[u] = 1$，表示 $u$ 处于搜索中状态。
   2. 以 $for$ 循环依次考察 $u$ 的邻接顶点 $v$ 。
      1. 若 $visited[v] == 0$ ，状态为「未搜索」。对其递归调用 $dfs$ ，也就是看它是否是其他顶点的「依赖」，使其置于「缓存」之中。
      2. 若 $visited[v] == 1$ ，状态为「搜索中」。表明我们此前进入过 $v$ 的 $dfs$ 过程，而此时又遇到了 $v$ ，显然 $v$ 是通过一个圈回到了 $v$。于是将 $hasCycle$ 标记为 $true$ 并返回。
      3. 若 $visited[v] == 2$ ，状态为「已完成」。跳过。
   3. 对于 $u$，若其完成了 $for$，表明要么其无 (依赖关系中的) 后继顶点，要么其后继顶点均已被排序 (被放入结果栈中)。也就是 $u$ 是当前所有未完成排序的顶点中位于依赖关系最后面的顶点，于是将其放入当前结果栈中的的底部。

3. 若能完成所有顶点的遍历而无圈，说明所有顶点已被拓扑排序，返回 $res$。

<br />

#### 时空复杂度

**时间复杂度: ** 

1. 建图及需遍历所有边，时间复杂度为 $O(|E|)$。

   每个顶点至多被标记两次，$O(|V|)$ 。

2. 检查邻接顶点的 $for$ 的总次数等于边数 $O(|E|)$ 。

故总的时间复杂度为 $O(|V|+|E|)$ 。**若图是连通的** ，由于 $|E| ≥ |V|$ (仅在 $|V| = 2$，且只有一条边时 $|E| < |V|$)，因此通常也可以粗略地记做 $O(|E|)$ 。

**空间复杂度:** 取决于 $visited$ / $res$ 数组空间以及递归栈空间，空间复杂度为 $O(|V|)$ 。

<br />

#### 代码

Tarjan 拓扑排序算法实现 [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) 。不再给出以哈希表存图的实现。

此写法为普遍的标准的 Tarjan 拓扑排序写法，读者应对该写法 **熟稔于心** 。

```java
class Solution {
    List<List<Integer>> graph;
    int[] visited, res;
    boolean hasCycle = false;
    int idx;
    public int[] findOrder(int numCourses, int[][] prerequisites) {
        // 1. 建图 + 准备 visited / hasCycle / res / idx
        this.graph = new ArrayList<>();
        this.visited = new int[numCourses]; // 0: 未搜索 1: 搜索中 2: 已完成
        this.res = new int[numCourses]; // 存储拓扑排序结果的栈
        this.idx = numCourses - 1; // 栈底下标
        for(int i = 0; i < numCourses; i++) {
            graph.add(new ArrayList<>());
        }
        for(int[] edge : prerequisites){ // 建图
            int v = edge[0], u = edge[1]; // 要学习v先学习u，因此 u -> v
            graph.get(u).add(v);
        }
        // 2. 遍历所有顶点，对「未搜索」状态的顶点 u 执行 dfs
        for(int u = 0; u < numCourses; u++){
            if(visited[u] == 0) { // 对未搜索的顶点执行 dfs
                dfs(u);
                if(hasCycle) return new int[]{}; // 每次搜索后，若检测出圈，返回空数组
            }
        }
        return res;
    }
    private void dfs(int u){
        visited[u] = 1; // 立即标记为搜索中
        for(int v : graph.get(u)) {
            if(visited[v] == 0) { // 邻接顶点为「未搜索」状态，dfs之
                dfs(v);
                if(hasCycle) return;
            }
            else if(visited[v] == 1) { // 若邻接顶点为「搜索中」状态，说明有圈
                hasCycle = true;
                return;
            }
        }
        visited[u] = 2; // 完成搜索，表明在对u进行dfs的过程中未遇到正在搜索中的其他顶点
        res[idx--] = u; // 此时u所依赖的顶点都在栈中「缓存」等待后续处理，因此可以将其放入此时结果栈中的底部。
    }
}
```

<br />

## 最短路径

**单源最短路径问题：**给定一个图 $G$ 和一个顶点 $s$ ，找出从 $s$ 到 $G$ 中每一个顶点的 **最短路径** 。



- 若 G 为无向图，当图中有负值圈时，由于绕此圈路径权值可无限小，故无最短赋权路径。若 $G$ 为无权图，可看作边权均为 1 的赋权图。

后续讨论并实现如下最短路算法：

|              | 无向图 | 有向图(无负边) | 有向图(有负边) | 有向图(有负圈) | 有向无圈图 | 备注 |
| ------------ | ------ | -------------- | -------------- | -------------- | ---------- | ---- |
| 无权最短路   |        |                |                |                |            |      |
| Dijkstra     |        |                |                |                |            |      |
| Bellman-Ford |        |                |                |                |            |      |
| SPFA         |        |                |                |                |            |      |
| A*           |        |                |                |                |            |      |
| IDA*         |        |                |                |                |            |      |



|                 |                 | 单源                                        | 所有顶点间                        |
| --------------- | --------------- | ------------------------------------------- | --------------------------------- |
| 无向图          | 无权图最短路径  | 无权图最短路径                              | 所有点对最短路径 (Flyod-Warshall) |
|                 | Dijkstra        | 无负边赋权图最短路径 (Dijkstra)             |                                   |
|                 |                 | 无圈赋权图 (DAG) 最短路径 (Kahn + Dijkstra) |                                   |
|                 |                 | 有负边赋权图最短路径 (Bellman-Ford, SPFA)   |                                   |
| 有向图          | Dijkstra        |                                             |                                   |
|                 |                 |                                             |                                   |
| 有向无圈图(DAG) | Kahn + Dijkstra |                                             |                                   |
|                 |                 |                                             |                                   |

<br />

### 单源无权最短路径算法

#### 朴素版

##### 算法描述

从源点 $s$ 开始，以 BFS 方式确定 $s$ 到其他所有顶点的最短路径。对于 $s$ ，距离 (顶点到源点 $s$ 的距离，下同) 为 0，其 **邻接顶点** 的距离 +1。置这些邻接顶点的距离为 **已确定** ，并将其前驱顶点置为 $s$ 。接着对距离为 1 的顶点 $v$ 考察它们的 **距离未确定** 的邻接顶点 $w$ ，使 $w$ 的距离 +1，并将 $w$ 的前驱顶点置为 $v$ 。以 for 循环重复上述过程，循环开始时 currentDist = 0，循环次数为顶点个数减 1，每次执行后 currentDist+1，表示距离不断递增，且距离 $≤|V|-1$ (当图为链状取到最大，为 $|V|-1$ )。

<br />

##### 算法过程

1. 给定一个源点s，置其距离(到源点s的距离)为0。
2. for循环按距离递增(广度优先搜索或者说层序遍历的方式)。令currentDist=0，以顶点个数减1为遍历次数，每次currentDist加1，表示距离以1为单位不断递增，最大不超过|V|-1。
3. for循环遍历所有顶点，找到距离未确定且为currentDist的顶点v(下一层顶点)，然后置v的距离为已确定，将v输出到结果列表中。
4. for循环遍历v的未确定距离的邻接顶点w，置w的距离为currentDist+1，置w的前驱为v。
5. 最外层for循环结束后所有顶点距离都会确定，算法结束。

<br />

##### 时空复杂度

时间复杂度：两层for均为 $O(|V|)$ ，故为 $O(|V|^2)$ 。

空间复杂度：不考虑图的存储空间时，为 $O(1)$ 。

<br />

##### 代码

```java
public List<Vertex<E>> shortestPathUnweightedBasic(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>();
    s.setDistance(0);

    for (int currentDist = 0; currentDist < vertices.size(); currentDist++) {
        for (Vertex<E> v : vertices) {
            if(!v.isKnown() && v.getDistance() == currentDist) {
                v.setKnown(true);
                res.add(v);
                for (Vertex<E> w : getAdjList(v)) {
                    // 已经取得距离的w一定是之前取得的，其距离已确定，所以要判断w是否为距离未更新的顶点。
                    if(w.getDistance() == Integer.MAX_VALUE) {
                        w.setDistance(currentDist + 1);
                        w.setPre(v);
                    }
                }
            }
        }

    }
    return res;
}
```

<br />

#### 队列版

##### 算法描述

上述算法的一个明显的缺点是，尽管程序运行到后期时大部分顶点的距离均已确定，但距离每+1后仍要遍历所有顶点来寻找距离未确定的下一层顶点。可以使用队列改进这一算法。开始时令源点s距离为0，置其距离为已知并入队，然后以一个while循环使顶点出队，对于每次出队的顶点v，考察其邻接顶点w，若w距离未知，使其距离为v的距离+1，然后置w的距离为已知，置w前驱为v，w入队。while循环结束时算法完成，通过顶点前驱信息可以得到该顶点到源点间的最短路径。



##### 算法过程

1. 设置一个用于输出出队顶点顺序的结果列表res(不是必要的)，设置一个队列q，给定一个起始顶点(源点)s，置s的距离(到源点s的距离)为0，置s的距离为已知，将s加入到队列中。
2. while循环判断q是否为空，不空则队首顶点v出队，输出到结果列表res中。
3. for循环遍历v的邻接顶点w，判断w距离是否已知，若未知则w的距离等于v的距离+1，置w的距离为已知，置w的前驱为v，w入队。
4. 最外层while循环结束后所有顶点距离都会确定，算法结束。



##### 时空复杂度

时间复杂度：与拓扑排序时间复杂度分析类似，每个顶点均入队一次出队一次，O(|V|)。遍历邻接顶点的for，在程序整体运行过程中每个顶点都会遍历其邻接顶点，总遍历的次数为边的总数，O(|E|)，总的时间复杂度为O(|E|+|V|)。

空间复杂度：不考虑用于返回的列表。取决于队列长度，O(|V|)。



##### 代码

```java
public List<Vertex<E>> shortestPathUnweightedQueue(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>();
    Queue<Vertex<E>> q = new LinkedList<>();
    s.setDistance(0); // 将起始顶点的距离设为0
    s.setKnown(true);
    q.add(s); // 起始顶点入队

    while(!q.isEmpty()) {
        Vertex<E> v = q.remove();
        res.add(v);
        // 每次顶点v出队，考察其邻接顶点的距离
        for (Vertex<E> w : getAdjList(v)) {
            // 用known字段来表示w的距离是否已更新，此处也可以用w.getDistance() == Integer.MAX_VALUE，
            // 但要限制最大路径不能超过Integer.MAXVALUE，若使用该判断条件，
            // 则该方法内的s.setKnown(true);w.setKnown(true);语句可以去掉
            if(!w.isKnown()) { 
                w.setDistance(v.getDistance() + 1); // 将其距离更新为v.getDistance() + 1
                w.setKnown(true);
                w.setPre(v); // 将v设置为w的其前驱顶点
                q.add(w); // w入队
            }
        }
    }

    return res;
}
```



### 单源赋权最短路径算法

#### Dijkstra算法

##### 朴素版

###### 算法描述

[Dijkstra算法(狄杰斯特拉算法)](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)：

一种基于广度优先搜索和贪婪思想(或者说层序遍历思想)的求解无负边图单源最短路径的算法。

算法将所有顶点区分为「到源点 $s$ 的最短距离」(以后简称「距离」) **已确定** 和 **未确定** 的顶点。算法开始前所有顶点的距离均未确定(一般置为$Infinity$)，初始时置 $s$ 的距离为 0。以一个while循环查询当前 **是否有距离未确定** 的顶点，若有则将其中距离最小者 $v$ 选为 **当前顶点**，并**使其距离已知**。然后以BFS的方式松弛 $v$ 的邻接顶点 $w$ 并更新 $w$ 的前驱。当不再有未确定距离的顶点时算法结束，此时每一个顶点的距离均最小，通过递归寻找节点的前驱可以得到 $s$ 到该顶点的具体的最短路径。

**松弛操作** 是最短路径算法的关键，在确定当前顶点 $v$ (最新成为已确定距离的顶点) 后立即操作，目的是更新 $v$ 的邻接顶点 $w$ 的距离和其前驱。如下图，$s$ 经过若干个顶点到 $a$ 和 $b$，$a$ 和 $b$ 邻接 $c$。假设此时 $dw = Inifinity$，$da = 5$，$db = 10$。

$a$ 先于 $b$ 成为当前顶点，由于 $da + |(a, w)| = 15 < Infinity$，故 $a$ 松弛 $dw$，并将 $w$ 的前驱置为 $a$，$w.pre = a$。

$b$ 成为当前顶点时，由于 $db + |(b, w)| = 11 < 15$，故 $b$ 松弛 $dw$，并将 $w$ 的前驱置为 $b$，$w.pre = b$。

<div align=center>
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyd7dgs29zj307m0di0sw.jpg" alt="image" width="100"/>
</div>

一个直观的观察是，来自 $w$ 入边的松弛，使得 $dw$ 不断更新至所有可能的路径距离的最小值。本算法后续讲解以及同样用到松弛操作的Bellman-Ford和Floyd算法中，我们还会看到对松弛操作的说明。

后续小节将给出Dijkstra算法的正确性证明。

<br />

###### 算法过程

朴素版本过程如下：

1. 初始化。选定一个源点s，初始化所有顶点到源点s的距离为Infinity，表示该点到s的距离尚未确定，置s到其自身距离为0。

2. 以while循环寻找当前距离未确定顶点中距离最小者。在当前具有有效距离(即不为无穷大)的距离未确定的顶点中找到距离最小者v，置v的距离为已确定。

3. 松弛操作。更新v的所有邻接顶点w的距离dw。有如下两种情况，因为在松弛前所有顶点的距离默认为Infinity，所以两种情形的形式一样，都是判断dv + d(v, w) < dw。（若初始将顶点距离设置为负数则需要分开处理）

    3.1  如果是初次访问，w到s的距离dw有效化为dw = dv + d(v, w)。更新w的前驱，w.pre = v。

    3.2. 当w不是初次访问，当满足dv + d(v, w) < dw时，更新dw为dv + d(v, w)。更新w的前驱，w.pre = v。

4. 当所有顶点距离都确定时while循环结束，每个顶点到源点的最短距离被求出。

补充说明：

1) 第2步是该算法贪婪的体现，即每次while都确定一个顶点的最短路径，while结束时求得所有顶点的最短路径。
2) 第3步是BFS思想的体现。每次while确定一个顶点后，调整其邻接顶点的距离，即一次处理一层。
3) 针对第2步在当前距离未确定顶点中寻找距离最小值，可以采用优先队列(小顶堆)进行改进，具体实现见后续。
4) Dijkstra算法对有负值边的图无效，原因见后续。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvj8uhzs9nj60es08st9102.jpg" alt="image-20211018111446692" width="300" />
</div>
<br />

###### 正确性证明

利用数学归纳法(结合反证法)证明。

> 本证明参考了[这个帖子](https://www.zhihu.com/question/57206374)。

a) 首先回顾数学归纳法的证明过程。

1. 起始验证。对于命题 $P(n)$，当 $n = 1$ 时命题 $P$ 成立。
2. 假设命题成立。假设命题 $P(n)$ 在 $n = m (m > 1, m ∈ N)$ 时成立。
3. 递推证明。根据2的假设，若能证明 $n = m + 1$ 时命题 $P$ 成立，则命题得证。

例如，有命题 $P：1+2+3...+n = n*(n+1)/2$，按照数学归纳法证明如下：

1. 起始验证。当 $n$ 等于 $1$ 时，$1 = 1*(1+1)/2$，命题成立。

2. 假设命题成立。假设命题等于 $m$ 时成立，$1+2+3+...+m = m*(m+1)/2$。

3. 递推证明。根据2的假设，如果能证明 $n = m+1$ 时命题正确，则命题 $P$ 成立。

   证明：在2所示式子左右两边加上 $m+1$，得到 $1+2+3+...+m+(m+1) = m*(m+1)/2 + (m+1)$

   等号右边可以写成 $(m+1)*(m+2)/2$，显然该形式就是将 $n = m+1$代入原命题 $P$ 的形式，证毕。

b) 利用数学归纳法证明如下命题。

命题 $P$：Dijkstra算法第 $n$ 次进入while时，会将第 $n$ 个顶点加入距离已确定顶点集合 $A$ 中，此时对于顶点 $∀v ∈ A($共 $n$ 个)，总有 $dv = δv$。

※ $dv$ 表示由Dijkstra算法得到的最短距离估计，对于源点 $s$ ，在程序开始时赋予 $ds = 0$，对于其他顶点，由松弛操作得到。$δv$ 表示实际的顶点 $v$ 到源点的最短距离。

1. 起始验证。当 $n$ 等于 $1$ 时，$A$ 集合中只有源点 $s$ 自身，$ds = 0$ (程序开始时赋值得到)，且知 $δv = 0$，故 $n=1$ 时命题正确。

2. 假设命题成立。假设命题 $P$ 在 $n$ 等于 $m$ 时，$P(m)$ 成立，即算法经过 $m$ 次while，得到具有 $m$ 个顶点的集合 $A$，对于顶点 $∀v ∈ A$ (共 $m$ 个)，总有 $dv = δv$。

3. $P(m+1)$ 递推证明。根据 2 的假设，如果能证明第 $m+1$ 个顶点 $u$ 被放入集合 $A$ 时有 $du = δu$，则命题 $P$ 成立。

   更详细地，$|A| = m$ 时，在点集 $B (B = S - A)$ 中根据算法规则找到距离最短的顶点 $u$，将该顶点将作为第 $m+1$ 个顶点放入A中，放入后 $|A| = m + 1$，如果能证明 $du = δu$，使得 $P(m+1)$ 成立，则对于顶点 $∀v ∈ A$ (共 $m+1$ 个)，有 $dv = δv$。

   以反证法证明之。

   3.1 假设 $m+1$ 时 $du = δu$ 不成立，即有如下式(1)， 之后的目标是根据已知条件导出某种矛盾情形，推翻该假设。

   (1)    $δu < du$     

   ※ $δu$ 是实际的 $u$ 到源点的最短距离，$du = δu$ 不成立时只能是 $δu < du$。算法保证了从 $s$ 到 $u$ 的过程一定是一条由图中的有向边构成的连续路径，只要是连续路径，无论有多少条这样的路径。一定有一条最短路径，其长度记作 $δu$。

   3.2 根据3.1的假设，存在一条从源点 $s$ 到 $u$ 的路径 $Pu$，该路径是 $s$ 到 $u$ 的最短路径，即 $|Pu| = δu  < du$。路径 $Pu$ 一定有不在 $A$ 集内的顶点 (至少有 $u$ 不在 $A$ 集中)，同时也有在 $A$ 集中的点 (至少有 $s$ 点在 $A$ 集中)，可以假设 $Pu$ 经过 $x$ 和 $y$，其中 $x$ 在A中 (可以是 $s$)，$y$ 在B中 (可以是 $u$ 本身)，$y$ 到 $u$ 的过程中也可以再进入 $A$，如下图。$Px$ 为 $Pu$ 在顶点 $x$ 结束的子路径，因为路径 $Px + (x, y)$ 为路径 $Pu$ 的一部分，所以有：

   (2)    $|Px| + |(x, y)| ≤ |Pu| = δu$       

   这是显然的，因为 $Px + (x, y)$ 是 $Pu$ 的一部分，当 $y=u$ 时取到等号。

   <div align=center> 
     <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvlx6lkq0wj60nw0f6mxj02.jpg" width="250" />
   </div>
   3.3 在 $x$ 被选中进入 $A$ 集内时，对其邻接顶点 $y$ 执行过 **松弛操作**，该操作会比较 $dx + |(x, y)|$ 是否小于 $dy$，若小于则以 $dx + |(x, y)|$ 更新 $dy$ 的值，所以如果更新了，更新之后有 $dy = dx + |(x, y)|$ ，如果没更新，说明 $dy < dx + |(x, y)|$。假设之后 $y$ 还会被 $y$ 的其他前驱顶点更新 $dy$ 值 (当该前驱顶点进入 $A$ 集时)，那 $dy$ 只会变得更小，所以一定有：
   
   (3)    $dy ≤ dx + |(x, y)|$      
   
   比较式 (2) 和式 (3) 中的 $|Px|$ 和 $dx$，因为 $dx = δx$  (由步骤2的 $P(m)$ 假设给出，顶点 $x$ 是 $P(m)$ 假设的 $m$ 个顶点之一)，而 $Px$ 只是若干从 $s$ 到 $x$ 的路径之一，因此必有 $d(x) ≤ |Px|$，当 $Px$ 恰是 $s$ 到 $x$ 的最短路径时取到等号。所以根据式 (2) 和式 (3) 有：
   
   $dy ≤ dx + |(x, y)| ≤ |Px| + |(x, y)| ≤ |Pu|$，即 
   
   (4)    $dy ≤ |Pu| = δu$       
   
   3.4 顶点 $y$ 与 $u$ 均在 $B$ 集中，根据算法规则，$u$ 之所以是第 $m+1$ 个被放入A集中的顶点，是因为第 $m+1$ 次进入while时，$u$ 在B集中相比于B集中的其他顶点(自然也包括 $y$ )，到源点 $s$ 的距离最小，显然有：
   
   (5)    $du ≤ dy$        
   
   结合式 (1)，式 (4)，式 (5)得到：
   
   (6)    $δu < du ≤ dy ≤ |Pu| = δu$ ，即  $δu < δu$
   
   

至此，由3.1的假设 「$d(u) = δ(u)$ 不成立」导出了矛盾，所以 $d(u) = δ(u)$ 是成立的，Dijkstra算法正确性得证。

<br />

###### 时空复杂度

时间复杂度：$O(|V|^2 + |E|)$，由于 $|E| < |V|^2$ ，所以也可以写为 $O(|V|^2)$ 。

1. 寻找拥有最小距离的顶点的时间为 $O(|V|^2)$ 。 先遍历一遍顶点确认存在距离未确定的顶点 $O(|V|)$ ，再遍历一遍顶点寻找未确定距离的顶点中距离最小者 $O(|V|)$ 。

2. 所有顶点的距离被松弛的次数上限为 $O(|E|)$ 。由算法可知顶点距离松弛只发生在找到当前距离未确定且距离最小的顶点之后，一次更新的次数是该顶点的邻接顶点数 (即出边数，出度)。每一次循环松弛某一个顶点的所有出边。所有顶点的出边数即总边数 $|E|$ 。故总松弛次数，也即所有顶点的距离被更新的次数上限为 $O(|E|)$ 。

空间复杂度：算法过程中只用到常数个变量，不考虑顶点/边/图的数据结构本身消耗的空间时为 $O(1)$ 。

<br />

###### 代码

```java
// 为了更清楚地分析时间复杂度，将检查未确定距离顶点的方法checkUnknown和
// 获取未确定距离顶点中最小者的方法getUnknownMin写在外部。

public List<Vertex<E>> shortestPathDijkstraBasic(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>(); 
    s.setDistance(0);

    // 遍历所有顶点确认是否有距离未确定的顶点，O(|V|)
    while(checkUnknown(vertices)) { 
        // 从所有顶点中取出距离unknown的顶点中的距离最小者v，O(|V|)
        Vertex<E> v = getUnknownMin(vertices);
        v.setKnown(true); // 置v的距离已确定
        res.add(v); // 按顺序输出已确定距离的顶点
        // 松弛v的邻接顶点w，本方法总共O(|E|)
        for (Vertex<E> w : getAdjList(v)) {
            // 松弛对象是未确定距离的邻接顶点w，本程序赋权图以邻接矩阵方式存储顶点的邻接顶点信息，
            // 故以边权是否为0判断是否为邻边
            if(!w.isKnown() && getEdgeValue(adjListsWeighted, v, w) != 0) { 
                int dw = v.getDistance() + getEdgeValue(adjListsWeighted, v, w);
                if(dw < w.getDistance()) { // 松弛条件
                    w.setDistance(dw); // 更新dw
                    w.setPre(v); // 置w前驱为v
                }
            }
        }
    }

    return res;
}

/**
 * 检查顶点列表中是否存在unknown顶点，O(|V|)
 */
private boolean checkUnknown(List<Vertex<E>> vertices) {
    for (Vertex<E> v : vertices) {
        if(!v.isKnown()) {
            return true;
        }
    }
    return false;
}

/**
 * 返回顶点列表中unknown且到源点距离最小的顶点，O(|V|)
 */
private Vertex<E> getUnknownMin(List<Vertex<E>> list){
    Vertex<E> min = new Vertex<>();
    // 先将初始min的距离设置为无穷大
    min.setDistance(Integer.MAX_VALUE); 
    for (int i = 0; i < vertices.size(); i++) {
        Vertex<E> cur = vertices.get(i);
        // 在unknown顶点中找到具有有效距离的最小者，顶点距离初识为无距离(Integer.MAX_VALUE)
        if(!cur.isKnown() && cur.getDistance() < min.getDistance()) {
            min = cur;
        }
    }
    return min;
}
```

<br />

##### 优先队列(堆)版

###### 算法描述

针对朴素版第2步在当前距离未确定顶点中寻找距离最小者，可以采用优先队列(小顶堆)进行改进，其他过程与朴素版一致。需要注意的是一个顶点的距离在被确定前可能经过多次松弛，算法在每次顶点距离松弛时将其入堆，于是同一时间，堆中可能有多个相同的顶点(松弛过几次就有几个)。这其中最靠顶的将会先出堆，出堆即表明该顶点距离已确定，所以顶点出堆时要判断是否是第一次出堆，若不是则跳过。

<br />

###### 算法过程

1. 初始化。设置一个用于输出出堆顶点顺序的结果列表res(不是必要的)。选定一个源点s，初始化所有顶点到源点s的距离为无穷大，表示该点到s的距离尚未确定，置s到其自身距离为0。准备一个小顶堆pq，将s入堆。

2. 一次有效出堆完成一个顶点最短路径的确定。以while循环对pq判空，若不空，堆顶顶点v出堆。若v不是第一次出堆则跳过，若是则v即此时未确定距离的顶点中距离最小者，置v的距离为已确定。

3. 松弛操作。更新上述顶点v的所有邻接顶点w到源点s的距离dw。有如下两种情况，因为在松弛前所有顶点的距离默认为无穷大，所以两种情形的形式一样，都是判断dv + d(v, w) < dw。dw被松弛则将w入堆，以支持第2步(在当前具有有效距离的顶点中找到距离最小者)。

   3.1  如果是初次访问，w到s的距离dw有效化为dw = dv + d(v, w)。

   3.2. 当w不是初次访问，当满足dv + d(v, w) < dw时，更新dw为dv + d(v, w)。

4. 当堆中无元素即所有顶点距离都确定时while循环结束，每个顶点v到源点的最短距离被求出。

<br />

###### 时空复杂度

时间复杂度：O(|E|log|E|+|E|log|E|)，化简为O(|E|log|E|)，可进一步化简为O(|E|log|V|) ，化简依据后述。

1. 在当前距离未确定顶点中寻找距离最小者 O(|E|log|E|)。while中pq判空次数与堆大小有关，为O(|E|)，下述。获取距离最小者耗时也与堆大小有关，为O(log|E|)，故为O(|E|log|E|)。

   ※ 优先队列判空操作isEmpty()本身是常数时间操作，但总共要执行O(|E|)次。

2. 所有顶点的距离被更新(松弛)的次数上限为O(|E|)。由算法可知顶点距离的更新(或者说边的松弛)只发生在找到当前距离未确定且距离最小的顶点之后，一次更新的次数是该顶点的邻接顶点数(即出边数，出度)。每一次循环确定一个这样的顶点，也就是每一次循环松弛某一个顶点的所有出边。所有顶点的出边即总边数为|E|。故总松弛次数，也即所有顶点的距离被更新的次数，也即顶点入堆总次数为O(|E|)。dw更新时w入堆，插入操作的时间复杂度为O(log|E|)，入堆次数与更新次数相同，于是所有顶点的距离更新与顶点入堆的时间复杂度为O(|E| + |E|log|E|)，由于|E| <= |V|*(|V| - 1) ，故log|E| <= 2log|V|，故可化简为O(|E|log|V|)。

   ※ 根据上述顶点入堆次数取决于总边数的分析，堆的大小上限不是|V|而是|E|(或者说是O(|E|))，所以dw更新时w入堆的插入操作的时间复杂度为O(log|E|)，只是借助边数与顶点数的关系，可化简为O(log|V|)。

空间复杂度：不考虑用于返回的顶点列表时为O(1)。

※ 连通图顶点数与边数的关系：

无向连通图：|V| - 1 <= |E| <= |V|*(|V| - 1) / 2 

链状时|E|取到最小|V|-1，完全连通即两两相连时取到最大|V|*(|V| - 1) / 2 

有向连通图：|V| - 1 <= |E| <= |V|*(|V| - 1) 

链状时|E|取到最小|V|-1，完全连通即两两相连且正反向成对时取到最大|V|*(|V| - 1) 

<br />

###### 代码

```java
public List<Vertex<E>> shortestPathDijkstraPQ(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>(); 
    s.setDistance(0);
    // 泛型PriorityQueue的写法，重写compare方法，比较元素getDistance()方法的结果，小顶堆
    PriorityQueue<Vertex<E>> pq = new PriorityQueue<>(new Comparator<Vertex<E>>() {
        @Override
        public int compare(Vertex<E> v1, Vertex<E> v2) {
            return v1.getDistance() - v2.getDistance();
        }
    });
    pq.add(s);

    while(!pq.isEmpty()) { // 判空 O(|E|)
        // 从unknowns中取出距离最小的顶点， O(log|E|)
        Vertex<E> v = pq.remove();
        // 当顶点v被更新过多次(多次入堆)，则存在v多次出堆的情况，
        // 跳过不是第一次出堆的顶点(v.isKnown = true)
        if(v.isKnown()) { 
            continue;
        }
        v.setKnown(true); // 置v的距离为已确定
        res.add(v); // 按顺序输出已确定距离的顶点
        // 松弛v的邻接顶点w，O(|E|log|E|)
        for (Vertex<E> w : getAdjList(v)) {
            if(!w.isKnown() && getEdgeValue(adjListsWeighted, v, w) != 0) { // 松弛对象是距离未确定的w
                // 将dw初次赋有效值或dw有更新时的w加入到pq中，以保证算法过程第2步总是
                // 能够在所有“具有有效距离值但距离未确定”的顶点中寻找距离最小者。
                // 注意dw有更新的情况下堆中可能有多个w(dw不同)，因此插入次数上限与更新次数上限相同，为O(|E|)。
                int dw = v.getDistance() + getEdgeValue(adjListsWeighted, v, w);
                if(dw < w.getDistance()) { // 松弛条件
                    w.setDistance(dw); // 更新dw
                    w.setPre(v); // 置w的前驱为v
                    pq.add(w); // 插入堆中，注意一个顶点的dw可能更新多次，O(log|E|)
                }
            }
        }
    }

    return res;
}
```

<br />

##### 斐波那契堆版

###### 算法描述

###### 算法过程

###### 时空复杂度

###### 代码

<br />

##### 负边图

以下图为例说明Dijkstra算法为何无法处理负边图。

顶点A是源点，从A开始执行算法，dB和dC被更新为1，2，在距离未确定的顶点B和C中dB更小，B的距离设为已确定，dB = 1。然而实际上从A到C再到B会得到一条更短的的路径(-1)。

<div align=center>
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvys7ulosej308w08mjrb.jpg" alt="image-20211031204826493" width="140" />
</div>
<br />

##### 无圈图 (DAG)

###### 算法描述

连通的有向无圈图有且仅有一个入度为0的顶点(超过1个则不连通，0个则有圈)，以该顶点为源点s，从s开始以拓扑排序方式实现Dijkstra算法。与拓扑排序一样，每次入度为0的顶点v出队，由于已无入边，故该顶点距离dv不会再被更新，此时dv即已确定。标准的Dijkstra算法的关键操作为“在当前具有有效距离且距离未确定的顶点中寻找距离最小者，并置其距离为已确定”，目的是每一次循环确定一个顶点的最短路径(贪婪)，所以也可将本算法看作是免去了引号所描述的操作的Dijkstra算法，即无需寻找，顶点出队时其距离即被确定。

**该算法可应用于有负边的图。** 对任意顶点而言，若到源点有更短路径，会一直更新至其入度为0。以下图为例，从A开始执行算法，A出队，B.dist和C.dist被更新为1和2，然后B，C入度减为1，0，C无入边，其距离不会再被更新，即最终C.dist = 1，C入队。接着C出队，B.dist被更新为-1，B的入度减为0，此时B无入边，其距离不会再被更新，即其距离被最终确定为B.dist = -1。可以看到B的距离在其入度减至0的过程中总有机会更新至最短。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvys7ulosej308w08mjrb.jpg" alt="image-20211031204826493" width="140" />
</div>
<br />

###### 算法过程

1. 设置一个用于保存拓扑排序的列表res(不是必要的)。设置一个队列q，置s的距离为0，s入队。
2. while中对q判空，若不空则队首顶点v出队，置其距离为已知，将v放入输出列表res中。
3. 遍历v的邻接顶点w，更新dw，置w的前驱为v。
4. 将v的邻接顶点w的入度减1，并检查减1后是否为0，为0则入队。
5. 当while结束时，输出列表中res出队的顶点顺序为拓扑排序，此时所有顶点前驱确定，源点s到其他顶点的最短路径确定。

<br />

###### 时空复杂度

时间复杂度：队列中每个顶点均入队一次，出队一次O(|V|)，在更新并检查邻接顶点的for中，更新和检查的总次数等于边数O(|E|)，故总的时间复杂度为O(|E|+|V|)。

空间复杂度：取决于队列长度，不大于|V|，O(|V|)。

<br />

###### 代码

```java
public List<Vertex<E>> shortestPathDijkstraDAG(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>();
    Queue<Vertex<E>> q = new LinkedList<>();
    s.setDistance(0);
    q.add(s);

    while(!q.isEmpty()) {
        Vertex<E> v = q.remove(); 
        v.setKnown(true);
        res.add(v);
        for (Vertex<E> w : getAdjList(v)) {
            if(getEdgeValue(adjListsWeighted, v, w) != 0) {
                int dw = v.getDistance() + getEdgeValue(adjListsWeighted, v, w); // 顶点v的距离值+边(v,w)的权值
                if(dw < w.getDistance()) { // 若“v的距离+vw边权”小于w的距离，更新w的距离dw
                    w.setDistance(dw);
                    w.setPre(v);
                }
                w.setIndegree(w.getIndegree() - 1); // w的入度减1
                if(w.getIndegree() == 0) { // 考察w此时入度是否为0，为0则入队
                    q.add(w);
                }
            }
        }
    }

    return res;
}
```

<br />

#### A*算法

<br />

#### Bellman-Ford

##### 算法描述

[Bellman-Ford Algorithm(贝尔曼-福特算法)](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm): 与 Dijkstra 算法的相同点是对边 (或者说对顶点) **不断执行松弛操作** ，以逐渐得到所有顶点到源点的最短距离。Dijkstra每次循环完成 **一个** 顶点最短路径的确定，而 BF 算法则对图的 **所有边** ($|E|$ 条边) ，简单地进行 $|V|-1$ 次 **全量松弛操作** ，第 $i$ 次「全量松弛」使得位于第 $i+1$ 层的顶点的距离被确定 (详见后文)，因而 BF 算法也是「贪心」思想的应用。又因为任意顶点最多居于第 $|V|$ 层 (以源点 $s$ 为第 1 层)，因此算法结束时，保证 (无负圈图) 所有顶点距离最短。

<br />

##### 算法过程

1.  置源点 $s$ 的距离为 0。

2.  外层循环执行  $|V|-1$ 次，每一次都「松弛所有边」。

3.  进入外层循环后按顶点顺序依次对所有顶点 $v$ 考察其所有邻接顶点 $w$ 是否有 $dv + |(v, w)| < dw$，若有，松弛之，即令 $dw = dv + |(v, w)|$。

4.  在一次「松弛所有边」的操作中，若没有任何边被松弛，则退出最外层循环，表明所有可能的松弛已完成 (负圈图除外)。

5.  检查图是否有负圈。做法是再对所有边执行松弛操作，若有边可被松弛，则有负圈，结束程序，否则正常结束，所有顶点最短路径被求出。

<br />

##### 正确性证明(说明)

1.  已知若一个顶点 $v$ 的所有入边若完成了所有可能的松弛 (一条入边可被多次松弛)，则在 **最后一次松弛** 后，必有 $dv=δv$ 。 ($dv$ 表示由算法得到的 $v$ 的距离， $δv$ 表示实际的 $v$ 的最短距离)。

2.  易知，第 $i$ 次全量松弛，第 $i$ 层顶点的出边 **必被松弛** 。例如第 1 次全量松弛，$s$ (第 1 层顶点) 的出边必被松弛。第 2 次全量松弛，由于有了第 1 次全量松弛的结果，$s$ 的邻接顶点 (第 2 层顶点) 的出边必被松弛。

3.  $p(s, v)$ 路径长 (边数) 最长不会超过 $|V|-1$ ，当 $s$ 到 $v$ 为链状时最长 $|V|-1$  。当 $v$ 的入边是第 1 层入边时，将在第 1 次全量松弛时被松弛，若是第 2 层入边，则会在第 2 次全量松弛时被松弛 (这条入边的发出顶点在第 1 次全量松弛时已被松弛)，以此类推，第 $i$ 层入边会在第 $i$ 次全量松弛时被松弛。所有顶点的入边组成了该图的所有边，任意一边一定是某一层次的入边 (可以同时属于多个层次) 。某一层顶点距离的更新，一定来自其入边的松弛。

4.  由此，$v$ 的入边能否被全部松弛只取决于最深的入边能否被松弛 (当一条入边属于多个层次时，取其最深层次)，也即取决于 $s$ 到 $v$ 的最长路径 $\max\{|p(s, v)|, v ∈ V\}$的长度。如前述，  $\max\{|p(s, v)|, v ∈ V\} ≤ |V|-1$ ，故至多经过 $|V| - 1$ 次全量松弛，图的所有入边必定都松弛过且完成了所有可能的松弛 (某条入边属于多个层次时，可能经过多次松弛) 。如果把图看成以 $s$ 为根的树，也可以说为了求得所有顶点的最短路径，所需的全量松弛的次数取决于 **树的高度** 。对某一顶点，可以说该顶点至多经过其最大深度减 1 次全量松弛后取得最短路径。

5.  上述过程对任意顶点均成立，故 BF 算法正确性得证。

此证明也可以看作如下「动态规划」过程。且为较简单的单串单依赖动态规划 (单依赖指当前元素的更新只依赖前一元素)。

1.  定义: $dp[j]$ 表示源点 $s$ 到顶点 $j$ 的最短路径长度。

2.  边界: $dp[s] = 0$ 。

3.  递推: $dp[j] = dp[j - 1] + |(j - 1, j)|$ 。$j - 1$ 表示 $s-j$ 最短路径上的前一个顶点。

根据前述，$j - 1$ 顶点最大层深必比 $j$ 小 1，故 $dp[j - 1]$ 一定在求 $dp[j]$ 之前就已求出，递推式成立。

<br />

##### 实例说明

以下实际考察 BF 算法对下图的求解过程，重点关注顶点 $v$ 。 (图裂了的话可以看[这里](https://tva1.sinaimg.cn/large/008i3skNly1gyelpsd4sfj30f60cqdga.jpg))

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/008i3skNly1gyelpsd4sfj30f60cqdga.jpg" alt="image-20211215141921008" width="200"/>
</div>
$p(s, v)$ 有如下四种可能：

$p1: s > v ，|p1| = 15$ ，$(s, v)$ 是 $v$ 的第 1 层入边

$p2: s > a > v，|p2| = 14$ ，$(a, v)$ 是 $v$ 的第 2 层入边

$p3: s > b > a > v ，|p3| = 12$ ，(a, v) 是 $v$ 的第 3 层入边

$p4: s > b > c > v ，|p4| = 6$ ，$(c, v)$ 是 $v$ 的第 3 层入边

可以看到 $(a, v)$ 边同时属于 $v$ 的第 2 和第 3 层入边。这四条路径最长者长 3 (指边数，$p3$ 和 $p4$ )，根据上述分析，只需要执行 3 次全量松弛即可完成对 $v$ 最短路径的确定。又因为源点到所有顶点的所有路径中最长的长度也是 3，所以执行 3 次全量松弛可以确定所有顶点的最短路径。假设全量松弛时顶点的处理顺序为 $s, a, c, b, v$ ，下表展示算法对该图的运行过程 (第 3 次之后的全量松弛不会再松弛任何边，省略)。

| 松弛过程      | $ds$      | $da$          | $dc$          | $db$          | $dv$                            |
| ------------- | --------- | ------------- | ------------- | ------------- | ------------------------------- |
| 初始          | **0 (\*)** | ∞             | ∞             | ∞             | ∞                               |
| 第1次全量松弛 | 0         | **∞ > 9**     | ∞             | **∞ > 3 (\*)** | **∞ > 15**                      |
| 第2次全量松弛 | 0         | **9 > 7 (\*)** | **∞ > 5 (\*)** | 3             | **15 > 14**                     |
| 第3次全量松弛 | 0         | 7             | 5             | 3             | **14 > 12 > 6 (\*)** |

```
备注：
1. 初始时令 ds 为0，(*)表示已取得该顶点最短路径。
2. 第1次。(s, a), (s,b), (s, v)属于第1层入边，被松弛。
   且b只有一条入边，即经过这趟松弛操作，使得 db = δb。
3. 第2次。第1层入边不会再被松弛。第2层入边(a, v), (b, a), (b, c)被松弛。
   经过这趟松弛操作，a, c的全部入边松弛完毕，使得 da = δa，dc = δc。
4. 第3次。第1，2层入边不会再被松弛，第3层入边(a, v), (c, v)被松弛。
   v 的全部入边松弛完毕，使得 dv = δv。
```

<br />

##### 负边图 & 负圈图

-   负边图。由于该算法在 $|V|-1$ 次对所有边的松弛操作中会穷尽所有边被松弛的可能，类似以拓扑排序方式针对 DAG 图的 Dijkstra 算法 (通过入度为 0 保证穷尽所有松弛的可能)，所以也适用于有负边的图。

-   负圈图。当图存在负圈时，$s$ 到圈上任意顶点的距离都可以通过不断绕圈趋于无限小。因此若不能保证输入的图无负圈，可以在 $|V| - 1$ 次全量松弛后再执行一次全量松弛，若仍有边可被松弛，说明存在负圈。

<br />

##### 提前结束优化

当某一次全量松弛过程中没有边被松弛，说明所有可能的松弛已被穷尽，可提前结束程序。

<br />

##### 最坏情形

当图中存在两点间路径长度为 $|V|-1$ ，且在最后一次「全量松弛」时仍有边被松弛时间达到最坏情形。此情况下，需要对所有边执行 $|V|-1$ 次松弛后才能求得所有顶点的最短路径。对于一链状图 $s > a > b > c > v$ ，其中 $|(s, a)| = 1$，$|(a, b)| = 2$，$|(b, c)| = 3$，$|(c, v)| = 4$。 (图裂了的话可以看[这里](https://tva1.sinaimg.cn/large/008i3skNgy1gxekg5u1idj30ts04i0sz.jpg))

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxekg5u1idj30ts04i0sz.jpg" alt="image-20211215154902192" width="350" />
</div>
<br />

##### 时空复杂度

时间复杂度：每次全量松弛要操作 $|E|$ 条边，共 $|V|-1$ 次，复杂度为 $O((|V|-1)|E|)$ ，即 $O(|V||E|)$  。

空间复杂度：不考虑图的存储空间，为 $O(1)$ 。

<br />

##### 代码

```java
public List<Vertex<E>> shortestPathBF(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>();
    s.setDistance(0);

    for (int i = 0; i < vertices.size() - 1; i++) { // |V| - 1 次全量松弛
        // 若某一次全量松弛没有边被松弛，则提前结束
        boolean finished = true;
        // 由于本程序未实现Edge类，用如下两个for实现对顶点v，松弛其所有边
        for (Vertex<E> v : vertices) {
            for(Vertex<E> w : getAdjList(v)) {
                if(getEdgeValue(adjListsWeighted, v, w) != 0) {
                    // 当v的距离尚未被有效化时，dw会大于Integer.MAX_VALUE，所以要此处以long类型处理
                    long dw = (long)v.getDistance() + (long)getEdgeValue(adjListsWeighted, v, w); 
                    if(dw < w.getDistance()) {
                        w.setDistance((int)dw);
                        w.setPre(v);
                        res.add(w); // 这里res表示对于被松弛的顶点，按被松弛的顺序放入，一个顶点可以被多次松弛
                        finished = false; // 若本次全量松弛过程中有边被松弛，标记为false表示未完成
                    }
                }
            }
        }
        if(finished) { // 若为true，表示某一次全量松弛没有边被松弛，提前结束
            break;
        }
    }
    // 负圈检测，再次对所有边执行松弛操作，若有边被松弛，说明存在负圈
    for (Vertex<E> v : vertices) {
        for(Vertex<E> w : getAdjList(v)) {
            if(getEdgeValue(adjListsWeighted, v, w) != 0) {
                int dw = v.getDistance() + getEdgeValue(adjListsWeighted, v, w);
                if(dw < w.getDistance()) {
                    System.err.println("存在负圈！");
                    return res;
                }
            }
        }
    }

    return res;
}
```

<br />

#### SPFA

##### 算法描述

[SPFA算法(最短路径快速算法)](https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm)：SPFA 算法是对 BF 算法的一种改进。在BF 算法的说明中我们指出，第 $i$ 次「全量松弛」操作，只有第 $i+1$ 层的顶点距离会被更新至最短，这明显具有 BFS 特点，因此可以考虑不通过「全量松弛」来松弛第 $i+1$ 层顶点，而是以 BFS 的方式，借助队列 $q$ ，每松弛一层顶点，将它们入队，出队时，尝试松弛到其所有邻接顶点的距离，即可在第 $i$ 层顶点出队时松弛第 $i+1$ 顶点并使这些第 $i+1$ 顶点距离取得最小。因为顶点「按层」入队出队，层深最大为 $|V|$ (无负圈图)，因此算法可以结束。

我们还可以这样看，一个顶点 $w$ 的距离能够被更新，隐含着这样一个 **前提** ：$w$ 的前驱 $v$ 的距离被更新过 。因为 $dv + |(v, w)| < dw$ 时才会更新 $dw$，而 $|(v, w)|$ 是不变的，初始时 $dv$ 和 $dw$ 都是无穷大，所以只有 $dv$ 更新 (变小)，$dw$ 才会更新 (变小)。从源点出发指向其邻接顶点，对一个连通的有向图，总能遍历所有顶点，每次考察已松弛的顶点 $v$ 是否能松弛其邻接顶点 $w$ ，$w$ 成为已松弛的顶点后再考察是否能松弛 $w$ 的邻接顶点，重复此操作直到「当前已松弛顶点均无法再松弛任何顶点」为止。设置一个队列 $q$，程序开始时置源点s的距离为 0，$s$ 入队。while 对 $q$ 判空，不空时队首顶点 $v$ 出队，松弛其边 (即更新 $v$ 的邻接顶点 $w$ 的距离)，根据上述分析，如果 $dw$ 被更新，那它的邻接顶点将 **有机会被更新** ，所以将 $w$ 入队，等待出队时尝试松弛 $w$ 的边。需要注意的是，$w$ 入队前需要检查当前队列中是否已有 $w$ ，若有则无需入队。该检查使得时间复杂度为 $O(|V||E|)$ ，否则这一复杂度将无法得到保证。重复上述过程，当 $q$ 为空时 (无负圈图) 代表所有被更新过距离的顶点，都 **无法再触发其邻接顶点距离的更新** 。也可以说对任意一个顶点 $v$ 来说，$s$ 到 $v$ 的所有路径带来的所有可能的对 $dv$ 的更新已被穷尽。程序结束时得到所有顶点到源点的最短路径。

<br />

##### 算法过程

1.  初始时所有顶点距离为 $Infinity$。设置一个队列 $q$，置源点 $s$ 的距离为 0，$s$ 入队。

2.  设置一个用于支持负圈检测的记录所有顶点入队次数的哈希表。

3.  以 while 循环对 $q$ 判空，若 $q$ 不空，队首顶点 $v$ 出队。

4.  遍历 $v$ 的邻接顶点 $w$ ，若满足松弛条件，则更新 $w$ 的距离，置 $w$ 的前驱为 $v$ ，若当前队列无 $w$ 则将 $w$ 入队。然后检查 $w$ 的入队次数是否大于 $|V| - 1$，若大于则表示存在负圈，结束程序，否则将 $w$ 入队次数加 1。


<br />

##### 正确性证明(说明)

SPFA 算法与 BF 算法的核心内容都在于 **穷尽所有路径带来的所有可能的松弛** 。BF 算法通过 $|V|-1$ 次全量松弛达到 (详见BF算法正确性证明)，第 $i$ 次全量松弛中，有效松弛仅作用于第 $i+1$ 层顶点，其他层深顶点已不能够被松弛却还是会被尝试，这就产生了冗余操作。SPFA 算法利用顶点的距离能够被松弛的隐含前提，通过队列来减少松弛顶点距离的次数。第 $i$ 层顶点出队时发生的松弛，效果上相当于 BF 算法外层循环第 $i$ 次对所有边的全量松弛。在连通且无负圈的情况下，按层推进一定能够执行最大层深第 $|V|$ 层，因此该算法是正确的。

<br />

##### 实例说明

仍以前一张网络图为例考察 SPFA 算法的求解过程，进一步看清其正确性及 SPFA 与 BF 的关系。

第 1 层顶点只有 $s$ ，所以第 2 步 $s$ 出队相当于 BF 算法中第 1 次全量松弛。$a,b,v$ 是第 2 层顶点，所以第 3，4，5 步相当于 BF 算法中第 2 次全量松弛。此时 $v,a,c$ 是第 3 层顶点 (根据所在路径层深的不同，一个顶点可以属于不同层) ，所以接下来的第 6，7 相当于 BF 算法中的第 3 次全量松弛。最后一步使得队列为空，结束。

| 松弛过程 | $ds$      | $da$          | $dc$          | $db$          | $dv$           | 队列 $q$     |
| -------- | --------- | ------------- | ------------- | ------------- | -------------- | ------------ |
| 1. 初始  | **0 (\*)** | ∞             | ∞             | ∞             | ∞              | s;           |
| 2. s出   | 0         | **∞ > 9**     | ∞             | **∞ > 3 (\*)** | **∞ > 15**     | **a, b, v**; |
| 3. a出   | 0         | 9             | ∞             | 3             | **15 > 14**    | b, v;        |
| 4. b出   | 0         | **9 > 7 (\*)** | **∞ > 5 (\*)** | 3             | 14             | v; **a, c**  |
| 5. v出   | 0         | 7             | 5             | 3             | 14             | a, c;        |
| 6. a出   | 0         | 7             | 5             | 3             | **14 > 12**    | c; **v**     |
| 7. c出   | 0         | 7             | 5             | 3             | **12 > 6 (\*)** | v;           |
| 8. v出   | 0         | 7             | 5             | 3             | 14             | 空           |

```
1. 初始时令 ds 为0，(*)表示已取得该顶点最短路径。「;」是层的分隔符。
2. s 出队时松弛 (s, a), (s,b), (s, v)。
   且 b 只有一条路径，即经过这趟松弛操作，使得 db = δb。
3. a 出队时松弛 (a, v)，这是 v 的距离第 2 次被松弛。
4. b 出队时松弛 (b, a), (b, c)，a 有两条路径，c 只有一条，
   于是 da = δa，dc = δc。
5. 无可松弛边。
6. a 出队时松弛 (a, v)，这是 v 的距离第 3 次被松弛。
7. c 出队时松弛 (c, v)，这是 v 的距离第 4 次被松弛。
   此时 p(s, v) 所有可能的路径带来的 v 的入边的松弛均已完成，于是 dv = δv 。
8. 无可松弛边，队列空，程序结束。
```

<br />

##### 负边图 & 负圈图

-   负边图。SPFA 能够处理有负权的非负圈图，原因与 BF 算法一样，因为算法会处理所有顶点的 **所有可能的距离更新** 。

-   负圈图。若图存在负圈，负圈上的顶点将无限循环入队，算法无法结束。可以记录顶点入队的次数， 一个顶点入队次数大于 $|V|-1$ 时，该图存在负圈，此时即可结束程序。

**负圈判定：** 记录保存每个顶点入队的次数(例如用哈希表记录)，顶点 $v$ 的距离更新后判断当前更新次数是否超过了 $|V|-1$ 次，若超过则说明存在负圈，若不超过则将更新次数加 1。以层为单位追踪顶点入队出队的过程，不难理解无负圈情况下，一个顶点的距离至多被松弛 (顶点入队) $|V|-1$ 次，若超过则说明存在经过该顶点的负圈。

当图只有一个节点时，要小心处理负圈检测。如下伪代码，次数检测写在次数加一之前可以避免单节点图被误判为负圈。

```text
if(!q.contains(w)) { // 检查w是否已经在q中
    q.add(w) // 将w加入队列  
    if(w.inCount > |V| - 1) { // 若大于|V|-1则检出负圈
        System.err.println("存在负圈！")
    }
    w.inCount++ // 记录入队次数
}
```

当然也可以调换次数检测和加一的顺序，并把  $> |V| - 1$ 改成  $> |V|$ ，如下，效果相同。

```text
if(!q.contains(w)) { // 检查w是否已经在q中
    q.add(w) // 将w加入队列  
    w.inCount++ // 记录入队次数
    if(w.inCount > |V|) { // 若大于|V|则检出负圈
        System.err.println("存在负圈！")
    }
}
```

<br />

##### 时空复杂度

时间复杂度：$O(|V||E|)$ 。为方便说明，列出 SPFA 伪代码如下。

```text
SPFA (Bellman-Ford-Moore) 算法伪代码:
1    Queue q
2    q.add(s) // s的距离初始为0, 其他顶点的距离初始为Infinity

3    while(!q.isEmpty())
4        v = q.remove()
5        for (w : v.adjs)  // w是v的邻接顶点
6            if(dv + d(v, w) < dw)
7                dw = dv + d(v, w)
8                if(!q.contains(w)) //检查w是否在当前队列中，不在则入队
9                    q.add(w)
```

按层分析很容易得到 SPFA 的复杂度。顶点一层一层地入队出队，一张图最多有 $|V|$ 层 (以 $s$ 为第 1 层)，所以 **按层计** ，任何顶点最多只能入队 $|V| - 1$ 次。第 1 层顶点个数为 1，其余每层顶点数不会超过 $|V| - 1$ （第8行所保证）。再次强调，虽然一个顶点可能会通过不同的路径重复属于某一层，例如 $s > a > c，s > b > c$ ，但有了第 8 行的检查，使得一个顶点最多只能在一层顶点里出现一次。考虑每层顶点个数小于 $|V|$ ，每层顶点的松弛次数少于 $|E|$ 次，因此复杂度为 $O(|V||E|)$ 。

第 8 行 `if(!q.contains(w))` 是SPFA 作为改进 BF 的关键，有必要继续进一步说明为何加了这个检查优化不影响结果的正确性。假设从 $s$ 经过长度相同的不同路径到达若干个不同顶点，这些顶点都指向 $v$ ，每条路径带来的松弛都能执行到 (BFS 所保证)，只是除了第一次之外不把 $v$ 放入队列。将 $v$ 放入队列的目的是在之后使其邻接顶点 $w$ 有被松弛的机会。对于 $w$ ，来自 $v$ 的松弛机会只需一次即可，所以不每次都将 $v$ 放入队列中。

SPFA 每出队第 $i$ 层顶点，使得在最短路径上第 $i+1$ 层的顶点得到松弛。不厌其烦地，SPFA第 $i$ 层顶点出队的效果等同于 BF 第 $i$ 轮对边的全量松弛的效果，比 BF 的操作更有效率的地方在于，SPFA 仅仅松弛它够得着得邻边。BF 暴力地松弛所有边，但有效的只有第 $i+1$ 层，其他更深或更浅的顶点无法松弛，但一律以 `if(dv + |(v, w)| < dw)` 询问了一次。所以说 SPFA 是 BF 的一种改进。

空间复杂度：用于支持负圈检测的哈希表的空间，$O(|V|)$ 。

对时间复杂度的分析可以看出，稀疏图中顶点的 $p(s, v)$ 路径平均条数很少，SPFA 实际运行速度会很快。但在稠密图下会达到 $O(|V||E|)$ 。

<br />

##### Bellman-Ford-Moore 和 SPFA

SPFA 实际上应当称作 Bellman-Ford-Moore 算法。根据Wiki词条 [Bellman-Ford algorithm](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm) 的介绍，「对所有的边，简单地松弛 $|V| - 1$ 轮」的朴素 BF 算法在相近的几年里被三个人分别独立发明。只是不知道什么原因算法名称后来定型成了 Bellman-Ford。

```text
1955年 Alfonso Shimbel
1956年 Lester Ford Jr.
1958年 Richard Bellman
```

又过了一年，1959年的时候Edward F. Moore提出了BF算法的一个[改进](https://link.zhihu.com/?target=https%3A//mathscinet.ams.org/mathscinet-getitem%3Fmr%3D0114710)，即前文的伪代码 (SPFA / Bellman-Ford-Moore) 。

> A variation of the Bellman-Ford algorithm known as [Shortest Path Faster Algorithm](https://en.wikipedia.org/wiki/Shortest_Path_Faster_Algorithm), first described by [Moore (1959)](https://en.wikipedia.org/wiki/Bellman–Ford_algorithm#CITEREFMoore1959), reduces the number of relaxation steps that need to be performed within each iteration of the algorithm.

1994年，西南交通大学的段凡丁在该年4月的《西南交通大学学报》里发表了题为《[关于最短路径的SPFA快速算法](https://link.zhihu.com/?target=https%3A//xueshu.baidu.com/usercenter/paper/show%3Fpaperid%3D39798c8bf2d1b5236cdaae3152d490ed%26site%3Dxueshu_se)》的论文，**重新提出了Moore的改进** ，并且给了个比较通俗的名字 Shortest Path Fast Algorithm。段老师显然没看过 Moore 当初的论文，否则不会给出一个错误的复杂度估计（给出的复杂度是 $O(k|E|)$ ）。有意思的是，现在用 Google 搜 SPFA，即便在英文论坛，许多人对这个改进也称之为 SPFA，而非 BFM，真可谓是「喧宾夺主」了。

<br />

##### 代码

```java
public List<Vertex<E>> shortestPathSPFA(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>();
    s.setDistance(0);
    Queue<Vertex<E>> q = new LinkedList<>();
    q.add(s);
    // 设置一个HashMap记录每个顶点入队次数，以支持负圈检测
    Map<Vertex<E>, Integer> inCounter = new HashMap<>();
    for (Vertex<E> v : vertices) {
        inCounter.put(v, 0);
    }

    while(!q.isEmpty()) {
        Vertex<E> v = q.remove(); 
        res.add(v);
        for (Vertex<E> w : getAdjList(v)) {
            if(getEdgeValue(adjListsWeighted, v, w) != 0) { // 只对v的邻边操作
                int dw = v.getDistance() + getEdgeValue(adjListsWeighted, v, w);
                if(dw < w.getDistance()) { // 若源点经过顶点v到顶点w的距离小于源点到w的距离，更新源点w的距离
                    w.setDistance(dw);
                    w.setPre(v);
                    if(!q.contains(w)) { // 检查w是否已经在q中
                        q.add(w); // 当w有松弛操作时将w加入队列  
                        // 在w入队后判断当前入队次数，若大于|V|-1则检出负圈，输出提示信息并结束程序
                        int wInCount = inCounter.get(w);
                        if(wInCount > vertices.size() - 1) {
                            System.err.println("存在负圈！");
                            return res;
                        }
                        inCounter.put(w, wInCount + 1);
                    }
                }
            }
        }
    }

    return res;
}
```

<br />

### 所有顶点对最短路径算法

#### Floyd-Warshall算法

[Floyd-Warshall算法(弗洛伊德算法)](https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm): 求解图中任意两点的最短路径的算法。图可以是有向图或无向图，可以有负权边，但不能有负圈 (负圈上的顶点无最短路径，可无限短)。算法以 3 重循环考察任意顶点 $i$ 到任意顶点 $j$ 是否有经过任意顶点 $k$ 的可松弛路径，即对每一个顶点 $k$ (外层循环)，考察是否有 $d(i, k) + d(k, j) < d(i, j)$ ，若有则更新 $d(i, j) = d(i, k) + d(k, j)$ 。

可以这样理解其工作过程。已知确定的任意两点 $i, j$ 间有确定的最短路径 $p(i, j)$ （只要无负圈，必有最短路径），$p(i, j)$ 由多次松弛操作得到。先假设算法是正确的 (详细证明见后述)，那么在 $p(i, j)$ 的最后一次松弛后 (通过顶点 $y$ 松弛)，得到 $p(i, j) = p(i, y) + p(y, j)$ 。同理，$p(i, y)$ 和 $p(y, j)$ 是 $p(i, j)$ 的两个部分，它们由之前的松弛操作得到。例如松弛顶点 $x$ 后得到 $p(i, y)$ ，可知 $p(i, y) = p(i, x) + p(x, y)$ ，松弛顶点 $z$ 后得到 $p(y, j)$ ，可知 $p(y, j) = p(y, z) + p(z, j)$ 。路径 $p(i, j)$ 的构建过程可以一直拆分溯源到某三个相邻顶点的连接。例如在 $p(i, j)$ 上有三个相邻顶点为 $i > a > b$ ，那么在外层循环处理 $a$ ，中层循环处理 $i$ ，内层循环处理 $b$ 时，松弛操作将 $i > a > b$ **「连接起来」**（因为最短路径上的任意子路径都是最短的，必松弛）。顺着算法执行过程不难看出，算法通过外循环的 $k$ 来连接边，通过不断连接短路径产生长路径，最终增长为完整的最短路径。

<br />

##### 算法过程

1. 顶点间最短路径 (距离) 矩阵初始化并保存。顶点到自身距离为 0，相邻顶点间距离为边权，不相邻顶点间距离设为 $Infinity$ 。若要求输出路径本身，则需要另一个最短路径信息矩阵。
2. 以 3 个循环 (循环操作对象是所有顶点) 考察 $i$ 到 $j$ 是否可经由 $k$ 松弛。 $k, i, j$ 分别对应外，中，内层循环。
3. 松弛操作。若 `d(i, k) + d(k, j) < d(i, j)` ，则 `d(i, j) = d(i, k) + d(k, j)` ，若有路径信息矩阵，对应更新。

递归输出路径：通过路径信息的矩阵。$d[i] [j]$ 的值是 $k$ ，即 $i$ 经过 $k$ 到 $j$ ，在每次松弛时更新 $k$ 。例如有最短路径 $i > a > b > c > j$ 。程序结束后得到的路径信息矩阵如下。

| 顶点 | $i$    | $a$    | $b$    | $c$    | $j$    |
| ---- | ------ | ------ | ------ | ------ | ------ |
| $i$  | $null$ | $null$ | $a$    | $null$ | $b$    |
| $a$  | $null$ | $null$ | $null$ | $null$ | $null$ |
| $b$  | $null$ | $null$ | $null$ | $null$ | $c$    |
| $c$  | $null$ | $null$ | $null$ | $null$ | $null$ |
| $j$  | $null$ | $null$ | $null$ | $null$ | $null$ |

利用该矩阵，通过递归即可找到 $i > a > b > c > j$ 。递归过程大致如下，顶点输出顺序即为路径顺序。

```
i > j, 找到b
  i > b，找到a
    i > a为null，输出i
    a > b为null，输出a
  b > j，找到c
    b > c为null，输出b
    c > j为null，输出c
 最后输出j
```

<br />

##### 正确性证明 (说明)

该算法的 **本质是动态规划** ，以状态转移方程的形式描述如下，其中 $dp[k][i][j]$ 表示 **经过前 $k$ 个顶点的松弛，得到的顶点 $i$ 到顶点 $j$ 的最短路径长度** 。注意第一维的 $k$ 表示 $k$ 个顶点，第二维和第三维表示具体的顶点。

```
1. 定义: dp[k][i][j] 表示经过前 k 个顶点的松弛，得到的顶点 i 到顶点 j 的最短路径长度。
2. 边界: dp[0][i][j] = Infinity
3. 递推: dp[k][i][j]  = min{dp[k-1][i][j], dp[k-1][i][k]  + dp[k-1][k][j]}
```

最短路径 **不经过** 第 $k$ 个顶点 (顶点 $k$ ): $dp[k][i][j] = dp[k-1][i][j]$  

最短路径 **经过** 第 $k$ 个顶点 (顶点 $k$ ):   $dp[k][i][j] = dp[k-1][i][k] + dp[k-1][k][j]$   

```
// floyd核心伪代码
for(k : V)
  for(i : V)
    for(j : V)
      if(d(i, k) + d(k, j) < d(i, j))
        d(i, j) = d(i, k) + d(k, j)
```

补充说明：已知点 $i, j$ 之间的最短路径为 $p(i, j)$ ，那么 $p(i, j)$ 上的任意两点 $a, c$ 的最短路径确定在 $p(i, j)$ 上。反证法简单可证。假设 $p(i, j)$ 上两点 $a, c$ 之间的最短路径经过一不在 $p(i, j)$ 上的顶点 $b$ ，那 $i, j$ 的最短路径也就不是 $p(i, j)$ ，而是 $p(i, a) + p(a, b) + p(b, c)+ p(c, j)$ 。

<br />

##### 实例分析

下面通过一个例子观察 Floyd 算法的动态规划过程，对其正确性可以有更直观的感受。由于算法总是在整张图上进行处理，展示整张图将使过程变得杂乱，因此我们只选取一条 $i$ 到 $j$ 的最短路径，展现该路径的构建过程。由于这条路径是随意选取的，其他所有在图上的 **任意两点** 的路径的构成都是类似的。

设图 $G$ 中 $i, j$ 间最短路径 $p$ 为  $i > a > b > c > d > e > f > g > h > j$ 。最外层循环对该路径上顶点的处理顺序可以是任意顺序，例如 $b, h, i, g, a, e, j, f, c, d$ (分别标上序号 1, 2, 3, 4, 5, 6, 7, 8, 9, 10，表示外层循环处理的先后顺序)。现在我们以溯源的方式从处理最后一个顶点 $d$ 得到 $d(i, j)$ 开始观察，且只观察程序对上述十个顶点的处理（对其他顶点的处理形成其他路径）。该路径的取得只与三个循环对该路径上的顶点的操作有关，循环对其他顶点的操作不影响结果，因为其他顶点不在该最短路径上，由它们导致的松弛不影响路径 $p$ ，或者说 $p$ 会从若干条 $i$ 到 $j$ 的路径中胜出。

外层循环处理 $d$ 之后由 $d(i, d) + d(d, j)$ 的结果得到 $i$ 到 $j$ 的最短路径长 $d(i, j)$ ，因此 $d(i, d)$ 和 $d(d, j)$ 此时必是已知的。继续溯源，看看 $d(i, d)$ 和 $d(d, j)$ 是如何得到的。到 $d$ 的路径上 $c$ 是最后被处理的，处理 $c$ 时计算 $d(i, d) = d(i, c) + d(c, d)$ ，其中 $d(c, d)$ 是边长，这是程序开始时已知， $d(i, c)$ 需要继续溯源， $d(i, c) = d(i, a) + d(a, c)$ ，其中 $d(i, a)$ 是边长， $d(a, c) = d(a, b) + d(b, c)$ ， $d(a, b)$ 和 $d(b, c)$ 是边长。其余过程如图，标红处表示相邻的顶点的边长，在程序开始时得到。

可以看出，外层循环处理 i 到 j 的最短路径的所有顶点的过程中，先处理的顶点得到 **子路径总能够为后处理的顶点构建更长的子路径** ，直到处理 (最短路径上的) 最后一个顶点时，将两个子路径连接起来形成最终的最短路径，这正是动态规划过程的体现。

不同于 BF 动态规划过程的单串单依赖，Floyd 动态规划是 **多依赖** 的。也可以描述为某一次的松弛形成的路径 **不一定直接作用于下一次松弛** ，而是在之后某一次松弛中发生作用。例如处理 $b(1)$ 和处理 $h(2)$ 是外层循环的两次相邻的操作，它们分别产生了两条不相连的子路径 $a>b>c$ 和 $g>h>j$ 。之后外层循环处理 $a(5)$ 时 $a>b>c$ 增长为 $i>a>b>c$ ，处理 $c(9)$ 时增长为 $i>a>b>c>d$ 。 $g>h>j$ 在外层循环处理 $g(4)$ 时增长为 $f>g>h>j$ ，处理 $f(8)$ 时增长为 $d>e>f>g>h>j$  ( $d>e>f$  在外层循环处理 $e(6)$ 时得到)。最终在处理 $d(10)$ 时得到 $i > a > b > c > d > e > f > g > h > j$ 。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/008i3skNly1gxlre6dkzlj312k0pyace.jpg" alt="image-20211221210813747" width="700" />
</div>

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyd3nnjv03g30fq07anpe.gif" alt="floyd_demo_202112231607_compressed3" width="500" />
</div>
总结 Floyd 算法的过程，外层循环执行完第 $k$ 次，给出由 $k+1$ 条边组成的路径，下一次会利用长度为 $1, 2, ... , k+1$ 的路径连接出长度为 $k+2$ 的路径。这就好像将任意两点连成单边线（只要这两点之间存在路径），然后再将两条单边线作为零件连成长度为 2 的线，因为具备所有单边线，所以无论长度为 2 的线是由哪些单边线组成的，都可以找到并连起来。然后再利用长度为 1，2 的线作为零件连成长度为 3 的线，因为无论一条长度为 3 的线是如何构成的，构成它的单边线和 2边线都已具备。以此类推直到连出所有可能长度的线。

<br />

##### 时空复杂度

时间复杂度: 3 重循环，$O(|V|^3)$ 。

空间复杂度: 用于存储路径长度信息的二维矩阵 (若需求具体路径，还需路径信息矩阵)，为 $O(|V|^2)$ 。

<br />

##### 代码

```java
public List<Object> allShortestPathFloyd(){
    // 创建最短路径矩阵(以哈希表套哈希表形式)，并初始化。
    List<Object> res = new ArrayList<>();
    Map<Vertex<E>, Map<Vertex<E>, Integer>> interVerticesDist = copyMap(adjListsWeighted);
    Map<Vertex<E>, Map<Vertex<E>, Vertex<E>>> pathRecord = new HashMap<>(); // 路径信息矩阵
    for (Vertex<E> v : vertices) {
        Map<Vertex<E>, Vertex<E>> neighbors = new HashMap<>(); // 路径信息矩阵初始化步骤
        for (Vertex<E> w : vertices) {
            neighbors.put(w, null); // 路径信息矩阵初始化步骤
            if(v == w) { // 顶点到自身的边权初始化为0
                setEdgeValue(interVerticesDist, v, w, 0);
            }
            // 不存在的边权初始化为Infinity (在构造器中初始化为0，这里修改为Integer.MAX_VALUE表示无穷大，便于后续松弛操作)
            else if(getEdgeValue(interVerticesDist, v, w) == 0){
                setEdgeValue(interVerticesDist, v, w, Integer.MAX_VALUE);
            }
        }
        pathRecord.put(v, neighbors); // 路径信息矩阵初始化步骤
    }
    // 核心部分：3个for实现floyd算法
    for (Vertex<E> k : vertices) {
        for (Vertex<E> i : vertices) {
            for (Vertex<E> j : vertices) {
                // 若D(i,k) + D(k, j) < D(i, j)，则更新D(i, j)
                int ik = interVerticesDist.get(i).get(k);
                int kj = interVerticesDist.get(k).get(j);
                int ij = interVerticesDist.get(i).get(j);
                // 由于不存在的边权设为了Integer.MAX_VALUE，需要转型为long
                if((long)ik + (long)kj < (long)ij){
                    Map<Vertex<E>, Integer> neighbors = interVerticesDist.get(i);
                    neighbors.put(j, ik + kj);
                    interVerticesDist.put(i, neighbors); // 更新最短路径长度矩阵
                    pathRecord.get(i).put(j, k); // 更新路径信息矩阵
                }
            }
        }
    }
    res.add(interVerticesDist);
    res.add(pathRecord);
    return res;
}

private Map<Vertex<E>, Map<Vertex<E>, Integer>> copyMap(Map<Vertex<E>, Map<Vertex<E>, Integer>> origin){
    Map<Vertex<E>, Map<Vertex<E>, Integer>> copiedMap = new HashMap<>();

    for (Map.Entry<Vertex<E>, Map<Vertex<E>, Integer>> entry : origin.entrySet()) {
        Vertex<E> key = entry.getKey();
        Map<Vertex<E>, Integer> value = new HashMap<>();
        for (Map.Entry<Vertex<E>, Integer> neighbor : entry.getValue().entrySet()) {
            value.put(neighbor.getKey(), neighbor.getValue());

        }
        copiedMap.put(key, value);
    }

    return copiedMap;
}

/**
 * 通过递归方式从Floyd算法得到的路径信息矩阵中得到两点间的最路径并返回
 */
public List<Vertex<E>> getPath(Map<Vertex<E>, Map<Vertex<E>, Vertex<E>>> pathRecord, 
        Vertex<E> i, Vertex<E> j) {
    List<Vertex<E>> res = new ArrayList<>();
    getPre(pathRecord, i, j, res);
    res.add(j);

    return res;
}

private void getPre(Map<Vertex<E>, Map<Vertex<E>, Vertex<E>>> pathRecord, 
        Vertex<E> i, Vertex<E> j, List<Vertex<E>> res) {
    Vertex<E> k = pathRecord.get(i).get(j);
    // 当i, j之间无k，将i加入res中
    if(k == null) { 
        res.add(i); 
        return;
    }
    getPre(pathRecord, i, k, res);
    getPre(pathRecord, k, j, res);

    return;
}
```

<br />

## 网络流

### 最大流最小割定理及其证明

> 本节整理自B站南大老师蒋炎岩的授课视频: [[算法竞赛入门] 网络流基础: 理解最大流/最小割定理](https://www.bilibili.com/video/BV1Q7411R7ie?spm_id_from=333.999.0.0)。

[最大流最小割定理(Max-flow min-cut theorem)](https://en.wikipedia.org/wiki/Max-flow_min-cut_theorem)：对于一张网络图，从源点 $s$ 到汇点 $t$ 的 **最大流量等于最小割所有割边容量之和**。

以下将从 **路径存在问题** 引入 **割和割的大小** 的概念，再由割的大小与 $s-t$ 不相交路径数量的关系，证明上述定理，也即证明 Ford-Fulkerson 方法的正确性。证明过程中先假设有向图 (网络) 边无权 (或者说均为单位边权，即边权为1)，随后再推广至有权图。

> [L. R. Ford Jr.](https://en.wikipedia.org/wiki/L._R._Ford_Jr.) & [D. R. Fulkerson](https://en.wikipedia.org/wiki/D._R._Fulkerson) (1962) *Flows in Networks*, 这一[论文](https://www.rand.org/content/dam/rand/pubs/reports/2007/R375.pdf)第23页，作者给出的最大流最小割定理描述如下。
>
> Theorem 5.1 Max flow min cut theorem.
>
> For any network the maximal flow value from s to t is equal to the minimal cut capacity  over cuts separating s and t.

<br />

#### 从路径存在问题到割

$s-t$ 流 (flow) 存在的前提是 $s-t$ **路径** 存在。对于路径存在问题，通常以 $DFS/BFS$ 算法判定，算法从 $s$ 出发找到 $t$ 则说明 $s-t$ 路径存在，否则不存在。为了引入割的概念，现在尝试以更本质的方式考察该问题。首先以排列组合的方式简单罗列所有可能的 $s-t$ 路径。例如一张包含顶点 $s, a, b ,c, d, t$ 的图，可以罗列出如下路径，暂不考虑边是否存在。

```
s > t
s > a > t
s > b > t
...
s > a > b > t
s > a > c > t
...
```

对于上述列表中的一条路径，若该路径中的每对相邻顶点构成的边均存在，则该路径为一条 $s-t$ 路径。若对于列表中的所有路径都能找到不存在的边，则证明该图不存在 $s-t$ 的路径。

对于路径存在问题，罗列所有可能路径并逐一判断的方法虽最严格，但显然不是证明的好办法。再次考虑 $DFS/BFS$，算法从 $s$ 出发，会找到所有能到达的顶点，将这些顶点作为集合 $S$，剩下 $s$ 无法到达的顶点作为集合 $T$ 。$s-t$ 路径不存在，等价于 $S$ 中任意顶点到 $T$ 中任意顶点顶点的连边都不存在，由此引入如下 **割** 的概念。

**割的定义**：割(cut)是对图 $G$ 的 **顶点集 $V$ 的划分**。有向图 $G(V, E)$ 的 $s-t$ 割 $C = (S, T)$ 指 $V$ 被划分为顶点集 $S$ 和 $T$ ，使得 $s ∈ S$，$t ∈ T$。

**割的大小**：对于上述割，其大小指从 $S$ 到 $T$ 的边的数量，即边 $(u, v) ∈ E | u ∈ S, v ∈ T$ 的数量，称这些边为 **割边**。

根据割及其大小的定义，只要存在 $s-t$ 路径，无论如何划分 $V$ 得到 $s-t$ 割，总能在图中找到从 $S$ 到 $T$ 的边，即该割的大小一定大于0。例如下面的 $s-t$ 路径，$s, a, d, e, h ∈ S， b, c, f, g, i, t ∈ T$，红箭头表示 $s-t$ 割的边。只要满足 $s ∈ S$  ($s$ 在绿色阴影里)，$t ∈ T$ ($t$ 不在绿色阴影里)，在有路径的情况下，红箭头一定存在，而与绿色阴影的形状 (具体的 $s-t$ 割) 无关。反过来说就是**若$s-t$ 路径存在，则所有 $s-t$ 割的大小都大于0** 。

因此，要想证明 $s-t$ 路径不存在，**只需要找到一个大小为 0 的 $s-t$ 割即可** 。 注意，当 $s-t$ 路径不存在时，也可能存在大小不为 0 的 $s-t$ 割，很容易找到相关例子。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyb3myal6dj30e603cjrb.jpg" alt="graph cut example" width="400" />
</div>
<br />

#### 不相交路径数量与割的大小

现在，我们初步建立了「流」与「割」在特定情形下的联系，即上述分析给出的「$s-t$ 路径数量为 0 时 (流为0)，必存在大小为 0 的 $s-t$ 割」。这也是 **「$s-t$ 路径数量」 ** 与 **「$s-t$ 割大小」** 的特定关系。再次回到定理内容，定理描述了「最大流」和「最小割边容量」(对无权图来说即割边数量) 的关系，实际上，最大流就是 **不相交的 $s-t$ 的路径** 数量 (再次注意，我们当前讨论的是无权图)。$s-t$ 的 **不相交** 路径指对于多条 $s-t$ 路径，它们之间没有公共边。后续我们通过如下三个量的关系来证明定理，即证明 $k = l$。

- $k$ 为图中实际的 $s-t$ 不相交路径数量。
- $m$ 为算法找到的 $s-t$ 不相交路径数量。
- $l$ 为图中最小 $s-t$ 割边数量。

##### 不相交路径数上界

假设图有 $k$ 条 $s-t$ 的不相交路径，想要知道 $k$ 的大小，可以逐步假设 $k (k = 0, k = 1, k = 2,...)$，再验证是否确实有那么多条。例如假设 $k=0$ 时，实际上就是前述 $s-t$ 路径存在性问题，已经指出，若存在大小为 0 的 $s-t$ 割，则 $k=0$。当 $k > 0$ 时，考虑是否还能用 $s-t$ 割的大小表达不相交路径数量。下图 $k=1$，以图中的阴影表示 $s-t$ 割，可以看出该割的大小为 1。容易看出 **不相交路径数量受到割边 $(b, c)$ 数量的限制** ，如果所有 $s-t$ 割大小最小为1，那么任意 $s-t$ 路径一定都要经过该唯一割边，即 $s-t$ 不相交路径至多为1。若最小割大小为 2，则存在 2 条经过 2 条不同割边的 $s-t$ 路径。总之，最小 $s-t$ 割的大小 $l$ 决定了 $s-t$ 不相交路径数量 $k$ 的上界，即 $k ≤ l$。现在我们离目标近了一步，即「最小割边数」$l$ 和「最大流」($s-t$ 不相交路径数量) $k$ 的关系满足: $k ≤ l$。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyb4kwuxbjj306b0373yc.jpg" alt="size one cut" width="250" />
</div>
##### 不相交路径数下界

上述以最小割的割边数给出了不相交路径数量 $k$ 的上界，而如果能直接找到 $m$ 条不相交路径，此 $m$ 可立即作为 $k$ 的一个下界，且若 $m = l$，便可得到 $k = l$。 直接地，我们用 $DFS/BFS$ 求 $m$，在$G$ 中寻找一条 $s-t$ 路径 $p$，找不到时 $k=0$，若能找到，为了保证找到的路径总是 **不相交** 的，需要从 $G$ 中删去 $p$，然后 $k = k + 1$。看起来有效，但实际操作后我们会发现一个问题，如下图，当第一次选择的路径为 $s > d > a > t$ 后，由于该路径被删除，将无法再找到下一条路径，而该图显然有 $k=2$ ($s > a > t, s > d > t$)，因此单纯使用 $DFS/BFS$ 算法并不总能得到正确的 $m$ (更紧的 $m$)。于是引出 Ford-Fulkerson 方法。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyb5g414o5j305i03hglg.jpg" alt="graph" width="200" />
</div>
##### 反向边 (路径)

L. R. Ford, JR & D. R. Fulkerson 在1956年的[论文](http://www.cs.yale.edu/homes/lans/readings/routing/ford-max_flow-1956.pdf)中改进了上述方法，并证明了改进后算法的正确性。改进的内容十分简单，即在每一次找到一条路径并删除该路径后，在 $t-s$ 的方向上 ($s-t$ 的反方向)  **添加原路径的反向路径**，仅此而已。如下，找到 $s > d > a > t$ 的路径后将其删除，立即添加 $t > a > d > s$ 路径。该操作使得后续仍能找到一条 $s-t$ 路径，即 $s > a > d > t$，继续删除并添加相应的反向路径，最终无法再找到 $s-t$ 路径，$m=2$ 被正确求出。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gyb5zoni2aj305i03n3yd.jpg" alt="reverse path" width="200" />
</div>

$s-t$ 路径称为 **增广路径(Augmenting Path)**，可以将反向路径称作 **反向增广路径**。添加这一反向路径的操作是整个算法最为核心的部分，以下证明这一操作的正确性，即以「寻找增广路-删除该路径-添加反向路径」这一FF方法，为何一定正确求出原图中的所有 $s-t$ 不相交路径 ($s-t$ 流 / $s-t$ 增广路) 数量。

<br />

#### 定理证明过程

蒋岩炎老师的视频中不以严谨的数学证明，而是以图形化的直观方式证明了FF方法的正确性 (也即证明了最大流最小割定理本身)。

##### 添加反向边的有效性

如下左图 (图中的 $s$ 和 $t$ 虽画出了多个点，但表示一个点)，$p1, p2, p3$ 是先找到的 3 条 $s-t$ 不相交路径 (未经过反向边)，$p4$ 是第 4 条 (经过反向边)。$p4$ 由两种边组成，如下中图，一种是不与 $p1, p2, p3$ 交叠的边，即此前尚未出现在不相交路径上的 **原边**，另一种是与 $p2$ 和 $p3$ (反向)交叠的边，这些边是找到 $p2$，$p3$ 后添加的 **反向边**，它们使得 $p4$ 可以沿着这样的反向边到达 $t$。假设之后找不到新的路径，我们就可以说该图的不相交路径数量是 4。$p4$ 是通过添加反向边来间接得到的 (此路径并不存在于原图中)，现在的问题是如何知道 **原图** 中确实有 4 条不相交路径。为了更清楚地看到这个事实，去掉 $p4$ 走过的反向边，如下右图，$p1$不变。而 $p'2, p'3, p'4$ 就是 **原图** 中的 $s-t$  路径，它们显然不相交 。注意下右图本身就是原图的一部分，只不过一开始没找到 $p'2, p'3, p'4$ (所以没在前图中画出)，而是找到了 $p2, p3$，然后通过反向边找到了 $p4$。尽管算法找到的路径与下右图显示的原图上的路径不同，**但数量是正确的**。如果还有 $p5$，仍然可以通过相同的方法证明原图中确实有 5 条不相交路径。**在示意图中那些通过反向边得到的 (在原图中不存在的) 路径看起来就像是切开了起初得到的路径 ($p2, p3$)，并通过部分原边连接这些路径的断点，使得 $s$ 到 $t$ 可达。**

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rp8nxjqhj215u0g0jsz.jpg" alt="FF correctness" width="850" />
</div>


##### 最小割大小及 m = k 的正确性

上述内容说明了添加反向边能够找到新的 (在不添加反向边时可能找不到的) 不相交路径，并且我们说明了算法找到的路径与原图实际的路径 **一一对应 (数量相等)**，接下来进一步说明为什么 **算法终止时得到的路径数量是正确的 (穷尽了原图的 $s-t$ 不相交路径，即 $m = k$)**。

以上中图为例，找到 $p4$ 后将边反向得到下图。假设此时算法无法再在残留图中找到新的路径，算法终止，算法得到的不相交路径数量是 $m = 4$。现在已经得到了 $m$，要证明 $k = 4$ 是正确的，根据 $m ≤ k ≤ l$ 关系，只需要指出原图中存在一个大小为 $l = 4$ 的 $s-t$ 割即可 (再次强调，$m$ 是FF算法找到的 $s-t$ 不相交路径数量，$k$ 是原图中存在的实际的 $s-t$ 不相交路径数量， $l$ 是原图中一个 $s-t$ 割的大小)。你可能注意到了，我们并没有强调找到的这个 $l = 4$ 的割为原图 **「最小」** $s-t$ 割。 这是因为已经知道 $m = 4$ 的情况下，$s-t$ 割的大小不可能小于 4。如果我们还能找到更多的不相交路径，那么最小 $s-t$ 割的大小也会随着不相交路径数量的增多而「水涨船高」。于是我们转为直接求证：$m = k$，当此式成立时，立即有 $l = m$。

现在我们来指出一个 $l = 4$ 的割。观察上右图 (注意其表现的是原图)，通过一条线简单地切断 $p1, p'2, p',3, p'4$，线左边的点归入 $S$ 集，其他顶点(包括未在图中体现的点) 归入 $T$ 集，就得到了原图的一个大小为 4 的 $s-t$ 割。注意，此时尚不能宣称该割最小，因为尚未证明 $m = k$。

回到下图，不难发现，残留图中由两种边构成，一种是 $s-t$ 不相交路径的反向边（注意，这里说的 $s-t$ 不相交路径不是通过算法找到的路径，而是前述说明中 $p1, p'2, p'3, p'4$ 那样的原图中存在的 $s-t$ 路径），一种是其他不在不相交路径上的原边。由于 $s-t$ 已不连通，我们不必指出具体的割就可以知道此时在残留图中存在一个 $s-t$ 割大小为 0。

这说明残留图的 4 条 $t-s$ 路径只能穿过一次 $T-S$，因为如果穿过一次以上，则必有穿过 $S-T$ 的边 (路径是连续的，$t → s → t → s$，会导致出现一次 $s → t$)，这与 $s-t$ 不连通矛盾。所以 $t-s$ 确定只有 4 条路径，而残留图与原图的区别 **仅为不相交路径的方向相反** (这一点非常关键)，由于残留图中只有 4 条 $t-s$ 路径，等价于原图中只有 4 条 $s-t$ 不相交路径。再次强调，残留图中的 $t-s$ 路径与原图中的 $s-t$ 路径 **一一对应**，当算法结束时，我们确定残留图中确实只有 4 条 $t-s$ 路径，也就同时确定了原图中只有 4 条 $s-t$ 路径，因为如果残留图中还能找到 $t-s$ 路径，那这条路径一定来自于原图的另一条 $s-t$ 路径。最终我们证明了 $m = k$，与此同时， $l = m$ (因为这样的 $l$ 已被我们指出确实存在，且它不可能更小)。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h2rpb5616nj20fy0ecmxg.jpg" alt="residual graph after p4" width="300" />
</div>

上述证明过程总结如下。

1. 算法结束时知原图有 4 条不相交路径，即 $m = 4$，并立即指出存在 $l = 4$。需要证明 **有且只有** 4条，即证明 $m = k$。
2. 易知原图 $s-t$ 不相交路径数量与残留图 $t-s$ 不相交路径数量严格相等，证明 $m = k$，转为证明 **残留图** 中有且只有 4 条 $t- s$ 不相交路径。
3. 若能证明此时 $t-s$ 路径只穿过 $T-S$ 一次就能证明 2。
4. 因残留图 $s-t$ 已不连通，因此残留图存在大小为 0 的 $s-t$ 割，因此 $t-s$ 路径确实只穿过一次 $T-S$ (否则 $t → s → t → s$，会导致出现一次 $s → t$)。

4证明了3，于是证明了2，于是证明了1，于是证明了 $m = k$，且 $l = m = 4$ 的割被明确指出，于是知道 $l = 4$ 为最小割，于是 **证明了最大流等于最小割**。证毕。

<br />

#### 推广至有权图 

只需将边权为 $n$ 的边看作 $n$ 条单位边，转换成无权图即可适用前述证明。例如 $s > a > t$ 路径，$(s, a)$ 边权为 2，$(a, t)$ 边权为3，将边拆成单位边后，原容量为 2 的一条路径被分成两条单位容量的路径。

<br />

### Ford-Fulkerson方法

#### 算法描述

[Ford-Fulkerson方法(福特-富尔克森方法)](https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm): 1956年L. R. Ford Jr和D. R. Fulkerson在其发表的[论文](http://www.cs.yale.edu/homes/lans/readings/routing/ford-max_flow-1956.pdf)中描述的基于 **贪婪思想** 的求 **有向图最大流** 的算法。因为该算法未指定求增广路径的具体算法，所以通常将其称作 Ford-Fulkerson **方法** (Method)而非 Ford-Fulkerson **算法** (Algorithm)。若增广路径 **以 BFS 方式求出** ，则为 **Edmonds-Karp 算法** 。此外也可以以 DFS 方式求最短路径，后续会看到 **结合 BFS 和 DFS 方式求增广路的 Dinic's 算法** 。FF 先设置要求解的目标，即源点 $s$ 到目标点 $t$ 的最大流，设为 $f$，初始值为 0，然后寻找 $s-t$ 路径 $p1$，$p1$ 上最小权边的边权即 $s$ 能沿 $p1$ 发往 $t$ 的流量 $c(p1)$。由于不适当的增广路选择会使得最大流量 $f$ 在求出前 $s$ 到 $t$ 就没有了增广路，因此 Ford-Fulkerson 提出每次求出一条增广路后，要在相反方向路径上添加 $c(p1)$，其作用是 $t$ 到 $s$ 在必要时能够发回原先 $s$ 发送到 $t$ 的流量。该做法的正确性证明见「最大流最小割定理及其证明」。当无法再在残余图中找到 $s-t$ 的增广路时所得到的 $f$ 即为原图 $s-t$ 最大流。

<br />

#### 算法过程

给定一张图 $G(V, E)$ ，源点为 $s$ ，汇点为 $t$ 。求 $G$ 中从 $s$ 到 $t$ 的最大流 $f$ 。

1. 设置一张残留网络 (残余图，residual graph) $Gf$，$Gf$ 初始为 $G$。

2. 考察 $Gf$ 中是否有从 $s$ 到 $t$ 的路径 $p$ ，使得 $p$ 上的每一条边 $(u,v) ∈ p$ ，都有 $c(u, v) > 0$ 。$p$ 称作 **增广路径 (Augmenting Path)** 。若存在 $p$ ，则：
   2.1 将 $p$ 中最小边的权 $c$ 加入 $f$。
   2.2 在 $Gf$ 中 $p$ 的每条边减去该最小边的权 $c$。
   2.3 在 $Gf$ 中 $p$ 的反向路径上的每条边上加上该最小边权 $c$。
   
3. 在 $Gf$ 中反复寻找增广路径 $p$ 并执行 2 中的操作直到 $Gf$ 中找不到 $p$，算法停止。此时得到的 $f$ 即为 $s$ 到 $t$ 的最大流。


<br />

#### 算法正确性证明

请参考「最大流最小割定理及其证明」。

<br />

#### 两种坏情形

**小边权增广路径情形**

如下图，寻找从 $A$ 到 $B$ 的增广路径时，若选取 $A>B>C>D$ 后，再选取 $A>C>B>D$ ( $C>B$ 由反向边操作得到)，如此反复选取。由于 $B $ ， $C$ 之间的小权边限制了流的大小，需经历 2000 次增广才能结束算法，而选取 $A>B>D$，然后选取 $A>C>D$ 则只需要两次。针对如何避免选取含有小边权的增广路，有以下两种做法。

- 做法1:  **总是选取流最大的增广路径** 。显然能够避免小权边引起的多次增广路选取。比如利用Dijkstra算法，将顶点距离的更新策略从选取最小值改为选取最大值，即可实现该做法。

- 做法2:  **总是选取最短的增广路径** 。较短的增广路降低了路径上出现小权边的概率。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvev606qcyj60ey0a0mxg02.jpg" width="250" />
</div>

以BFS方式应用无权最短路径方法实现做法2即为 Edmonds-Karp 算法。

<br />

**算法无法终止的情形**

算法能够结束的一个隐含前提是 **每次找到的增广路至少使 $s$ 到 $t$ 的发送流增加 1 个单位 (例如整数 1)** ，只要最大流是固定的，经过有限次操作后总能发送到最大流。如果边权存在 **无理数** ，则算法可能无法结束。以下举例说明 (该例来自[Wiki](https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm))。

如下图左的流量网络，e1 = (b, a), e2 = (d, c), e3 = (b, c)， |e1| = |e3| = 1，|e2| = r = (√5 - 1) / 2。其他边的容量为M (M >= 2)，且r^2 = 1 - r， r^3 = r - r^2, r^4 = r^2 - r^3...。有路径 p0 = s > b > c > t，p1 = s > d > c > b > a > t， p2 = s > b > c > d > t，p3 = s > a > b > c > t。若按路径p0, p1, p2, p1, p3, p1, p2, p1, p3, p1, p2, p1, p3...的顺序增广，则算法无法结束。

观察下表经过上述顺序一次循环后的结果，步骤1和步骤5时e1, e2, e3剩余容量为r^n, r^(n+1), 0的形式。发送流为1+2(r^1+r^2)。经过无限次完整的循环，e1, e2, e3剩余容量都会是r^n, r^(n+1), 0的形式，而发送流为1+2∑r^i  (r是从1到正无穷的整数)。根据等比数列求和公式有：

1+2∑r^i   = 1 + 2*r/(1-r)

将r = 1 - r^2 = (1+r)*(1-r)代入上式分子中的r，得到3+2r，即发送流会向2+√5趋近，但从原图可以看出最大流为2M + 1 > 5 > 2+√5。

| 步骤 | 增广路 | 发送流 | e1剩余  | e2剩余 | e3剩余 |
| ---- | ------ | ------ | ------- | ------ | ------ |
| 0    |        |        | r^0 = 1 | r^1    | 1      |
| 1    | p0     | 1      | r^0     | r^1    | 0      |
| 2    | p1     | r      | r^2     | 0      | r^1    |
| 3    | p2     | r      | r^2     | r^1    | 0      |
| 4    | p1     | r^2    | 0       | r^3    | r^2    |
| 5    | p3     | r^2    | r^2     | r^3    | 0      |

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxw1wu8pnjj31co0n8q8f.jpg" alt="image-a" width="800" />
</div>
<br />

#### 时空复杂度

时间复杂度：$O(E*f)$ 。

设最大流为 $f$ ，算法过程为穷尽增广路径的过程，对于任意一条增广路，都可以保证在 $O(E)$ 时间内找到 (例如以 BFS 方式寻找，为 $O(|V|+|E|)$ )，而每找到一条增广路径，至少增加 1  个单位的流量 (不考虑边权为无理数的情况，该情况可能会导致算法无法终止)，故总的时间复杂度为 $O(E*f)$ 。此时间复杂度与最大流的大小正相关，当 $f$ 较大时会导致较高的时间复杂度。若以BFS算法寻找增广路，即 Edmonds-Karp 算法，时间复杂度为 $O(|V||E|^2)$ 。若以 BFS 和 DFS 相结合的 Dinic's  算法寻找增广路，则时间复杂度进一步降为 $O(|V|^2|E|)$ 。

空间复杂度：依赖于求最短路径的具体方法，若以BFS求最短路径，即 Edmonds-Karp 算法，则取决于队列的长度，$O(|V|)$ 。若以 DFS 求最短路径，则取决于递归深度，$O(|V|)$ 。

<br />

### Edmonds-Karp算法

#### 算法描述

[Edmonds-Karp算法(埃德蒙兹-卡普算法)](https://en.wikipedia.org/wiki/Edmonds%E2%80%93Karp_algorithm): 以 BFS 方式 (无权最短路) 寻找增广路径实现 Ford-Fulkerson 方法即为 Edmonds-Karp 算法。每找到一条增广路并确定该路径上的最小边权 (该路径最大可发送流) 后，将此边权计入最大流中，并在此路径上对 $s-t$ 方向的边减去该权值， $t-s$ 方向上加上该权值。当 BFS 无法再找到增广路时算法结束，得到 $s$ 到 $t$ 的最大流。

<br />

#### 算法过程

给定一张图 $G(V, E)$ ，源点为 $s$ ，汇点为 $t$ 。求 $G$ 中从 $s$ 到 $t$ 的最大流 $f$ 。

1. 设置一张残留网络 (残余图，residual graph) $Gf$，$Gf$ 初始为 $G$。

2. 以 **BFS 方法** 考察 $Gf$ 中是否有从 $s$ 到 $t$ 的路径 $p$ ，使得 $p$ 上的每一条边 $(u,v) ∈ p$ ，都有 $c(u, v) > 0$ 。$p$ 称作 **增广路径 (Augmenting Path)** 。若存在 $p$ ，则：
   2.1 将 $p$ 中最小边的权 $c$ 加入 $f$。
   2.2 在 $Gf$ 中 $p$ 的每条边减去该最小边的权 $c$。
   2.3 在 $Gf$ 中 $p$ 的反向路径上的每条边上加上该最小边权 $c$。

3. 在 $Gf$ 中反复寻找增广路径 $p$ 并执行 2 中的操作直到 $Gf$ 中找不到 $p$，算法停止。此时得到的 $f$ 即为 $s$ 到 $t$ 的最大流。

<br />

#### 时空复杂度

以下证明 EK 算法的时间复杂度为：$O(|V||E|^2)$

> 本证明参考了[证明1](http://pisces.ck.tp.edu.tw/~peng/index.php?action=showfile&file=f6cdf7ef750d7dc79c7d599b942acbaaee86a2e3e)、[证明2](https://brilliant.org/wiki/edmonds-karp-algorithm/)。

##### 1. 一次BFS增广: $O(|E|)$

每次BFS增广，在增广路上的未饱和边会多出一条反向边，故增广操作导致的边数增长不会使总边数超过原来的 2 倍，即算法的任意时刻总边数 $< 2|E|$。一次BFS的时间复杂为 $O(2|E|)$，即 $O(|E|)$。详细可参考利用队列的无权最短路径复杂度分析。

##### 2. BFS增广次数: $O(|V||E|)$

###### 2.1 增广路长度非递减

即证明算法过程中的 $s$ 到 $t$ 的BFS增广操作，即正向边删除和反向边增加的操作，不会导致源点 $s$ 到任意一点 $v$ 的最短路径距离减少。残留图 $G_f$ 经过一次BFS增广变为 $G_{f'}$ 后，对任意顶点 $v$ ，源点 $s$ 到 $v$ 的最短路径长度 **非递减**，即有 $d'(s, v) ≥ d(s, v)$。以下利用反证法证明，并在证明中解释为何**只能证明非递减而无法证明严格递增**，即 $d'(s, v) > d(s, v)$。

1. 假设某一次 $s - t$ 增广后，使得某些顶点到源点 $s$ 的最短路径距离相比增广前变小了，且这其中距离源点 $s$ 最近者为 $v$。则根据该假设有

   (1)    $d'(s, v) < d(s, v)$ 

2. 令 $u$ 为 $G_{f'}$ 中 $v$ 的靠近源点 $s$ 的前一个顶点，则有

   (2)    $d'(s, u) + 1= d'(s, v)$ 

   

   如 2.1.1 所述，$v$ 是我们有意选择的在 $G_{f'}$ 中最短距离相比在 $G_f$ 中变小的且距离 $s$ 最近的顶点，$u$ 比 $v$ 更靠近 $s$，但在 $G_{f'}$ 中相比在 $G_f$ 中距离 $s$ 的最短路径未变小，即有

   (3)    $d(s, u) ≤ d'(s, u)$ 

3. 假设 $(u, v) ∈ E_f$，已知 $s$ 到 $v$ 的最短路径距离为 $d(s, v)$，则有

   (4)    $d(s, u) + 1 = d(s, v)$

   

   结合(1)、(2)、(3)有 

   $d(s, u) ≤ d'(s, u) → d(s, u) + 1 ≤ d'(s, u)+ 1 = d'(s, v)  < d(s, v)$，即

   (5)    $d(s, u) + 1 <  d(s, v)$ 

   

   (4) 是由 2.1.3 的假设得到的，与由 (1), (2), (3) 得到的 (5) 矛盾，故在 2.1.1 假设成立的前提下，2.1.3 的假设 $(u, v) ∈ E_f$ 不成立，即 $(u, v) ∉ E_f$。同时我们还能看到，如果一开始证明的是 $d'(s, v) > d(s, v)$，那么就要反证 $d'(s, v) ≤ d(s, v)$ (即式(1))，经过同样的过程当前的式 (5) 会变为 $d(s, u) + 1 ≤  d(s, v)$，将推导不出与 (4) 式的矛盾（因为都有一个等号）。

4. 由上述知 $(u, v) ∉ E_f$，但如 2.1.2 所述，$(u, v) ∈ E_{f’}$ ，故在 $G_f$ 上的增广必定经过了 $(v, u)$，且此边饱和，导致在 $G_{f'}$ 中产生了反向边 $(u, v)$。于是可知在 $G_f$ 中有

   (6)    $d(s, u) = d(s, v) + 1$

   

(6) 与 (5) 矛盾，于是最初 2.1.1 的假设不成立，即不存在这样的顶点 $v$，也即增广操作使得源点到任意一点 $v$ 的长度 **非递减**， **故EK算法寻找的增广路长度非递减**。

每次增广，在增广路上的未饱和边会多出一条反向边，故增广操作导致的边数增长不会使总边数超过原来的 2 倍，即 $|E'| < 2|E|$。又知道增广路长度是非递减的，增广路上界是总边数 ( $< 2|E|$ )，故任意一次BFS寻找增广路的时间复杂度总是 $O(|E|)$。

###### 2.2 增广次数: $O(|V||E|)$

1. 假设某次 $G_f$ 的增广中 $(u, v)$ 为饱和边，增广后 $(u, v) ∉ E_{f'}$，$(v, u) ∈ E_{f'}$。之后 $(u, v)$ 要再次出现的前提是 $(v, u)$ 为饱和边。在 $G_f$ 中  $(u, v)$ 第一次成为饱和边时有

   (7)    $d(s, v) = d(s, u) + 1$

2. 若 $(u, v)$ 第二次成为饱和边，可知在此前的 $G_{f'}$ 中 $(v, u)$ 中为饱和边，在 $G_{f'}$ 的这次增广中有

   (8)    $d'(s, u) = d'(s, v) + 1$

3. 由 2.1 的结论，$s$ 到任意顶点的最短路径非递减，即必有 $d'(s, v)  ≥ d(s, v)$ ，结合 (7) 和 (8)，有

   $d'(s, u) = d'(s, v) + 1 ≥ d(s, v) + 1 = d(s, u)+ 2$，即

   (9)    $d'(s, u)   ≥ d(s, u) + 2$

也就是说，$(u, v)$ 第二次成为饱和边时 $s$ 到 $u$ 的最短距离至少比前一次成为饱和边时大 2。而 $s$ 到任意顶点的距离最多不超过$|V| - 1$，故 $(u, v)$ 可以成为饱和边的次数最多为 $(|V| - 1) / 2$。每次增广至少有一条边成为饱和边，根据 2.1 中的说明，EK算法过程中边数 $< 2|E|$，故考虑 **所有边的总的增广次数必小于** $2|E|*(|V| - 1)/2$，即 **增广次数复杂度为 $O(|V||E|)$**。

**综上，EK算法复杂度为 $O(|V||E|^2)$。**

<br />

证明过程中**BFS增广使得增广路长度非递减**的结论是关键，网上有的文章声称BFS寻找增广路的操作使得增广路长度递增，但我们已经在 2.1.3 的叙述中指出这是不对的。根据 2.1 的证明，只能得到 **非递减** 的结果，但这一结论在 2.2 中足以证明任意边第二次成为饱和边时其最短路径长至少增加2，由此得到BFS次数的上界。

<br />

空间复杂度：取决于每次 BFS 寻找增广路时使用的队列大小，为 $O(|V|)$。

<br />

#### 代码

```java
public int maxFlowEK(Vertex<E> src, Vertex<E> des) {
    int incFlow = 0;
    int maxFlow = 0;
    // 不断寻找增广路径直到找不到 (== -1时)
    while((incFlow = augPathBFS(src, des)) != AUGMENTING_PATH_NOT_FOUND) {
        Vertex<E> current = des;
        // 每找到一条增广路径，从des顶点开始，向前对路径上每一条边(src > des方向)
        // 执行-inc操作，对其反向边执行+inc操作，直到到达src顶点为止
        while(current != src) {
            Vertex<E> pre = current.getPre();
            // 增广路方向上边权-1
            setEdgeValue(adjListsWeighted, pre, current, getEdgeValue(adjListsWeighted, pre, current) - incFlow); 
            // 逆增广路方向边权+1
            setEdgeValue(adjListsWeighted, current, pre, getEdgeValue(adjListsWeighted, current, pre) + incFlow);
            current = pre;
        }
        clearVertices(); // 重置所有顶点信息准备下一条增广路的寻找(主要是顶点访问标志)
        maxFlow += incFlow; // 将每次增广路带来的流量增加到maxFlow上
    }

    return maxFlow;
}

/**
 * bfs方式寻找增广路径，返回增广路径中最小权边的权值
 */
private int augPathBFS(Vertex<E> src, Vertex<E> des){
    int minEdge = Integer.MAX_VALUE;
    Queue<Vertex<E>> q = new LinkedList<>();
    q.add(src); // 起始顶点入队
    boolean isExist = false;

    while(!q.isEmpty()) {
        Vertex<E> v = q.remove();
        if(v == des) {
            isExist = true;
            break;
        }
        // 每次顶点v出队，考察其邻接顶点的距离
        for (Vertex<E> w : getAdjList(v)) {
            // 寻找未访问过且存在邻接顶点 (以是否有前驱节点作为是否访问过的标志，效果相当于!w.isKnown())
            if(w.getPre() == null && getEdgeValue(adjListsWeighted, v, w) > 0) {
                w.setPre(v);
                q.add(w); // w入队
                minEdge = Math.min(minEdge, getEdgeValue(adjListsWeighted, v, w)); // 更新增广路最小边权值
            }
        }
    }
    if(!isExist) {
        return AUGMENTING_PATH_NOT_FOUND;
    }

    return minEdge;
}
```

<br />

### Dinic's(Dinitz's)算法

#### 算法描述

[Dinic's算法(迪尼茨算法)](https://en.wikipedia.org/wiki/Dinic%27s_algorithm)：EK算法以BFS方式实现FF方法中的增广操作，在Dinic算法中，采用BFS和DFS结合的方式增广。首先引进高度标号(层次标号)和分层图的概念。以BFS算法从s到t，标记s为第1层，s的邻接顶点为第2层，以此类推t为最后一层。执行一次BFS，赋予每个顶点高度标号信息，此时的图称作分层图。在此分层图内以DFS方式反复寻找增广路并执行增广操作(找到饱和边，发送和发回流)，累计发送流。完成当前分层图的所有增广操作称作一个阶段。一个阶段结束后，重置高度标号信息，再次执行BFS得到新的分层图并重复DFS的增广操作，直到无法分层时说明s到t已无增广路，算法结束，此时得到的发送流总和即为s到t的最大流。

高度标号的作用：在以DFS增广时，每次从顶点v到其邻接顶点w的路径增长，都要考察w的的高度是否比v的高度大1，以此来保证路径总是能按步增长到最后一层的t(在有增广路的前提下)。

<br />

#### 算法过程

给定一张图G(V, E)，源点为s，汇点为t。求G中从s到t的最大流f。

1. 设置一张残留网络(残余图)Gf，Gf初始为G。
2. 调用BFS方法，赋予Gf中所有顶点以高度标号，建立当前分层图。注意在赋予高度时会先判断是否已赋过值，若有则跳过，因此顶点高度不会因为它处于多个层次而被较高的高度值覆盖，即一个顶点的高度是是它离源点最近的高度。此方法返回布尔值，有分层图(即有增广路)时返回true，否则返回false。
3. 求当前分层图发送流总和的方法(为方便叙述，称作主调函数f)，调用求单条增广路发送流的DFS方法搜索s到t的路径p，使得p上的每一条边(u,v) ∈ p，都有c(u, v) > 0。p称作增广路径(Augmenting Path)。DFS为一递归调用方法，返回值为本次增广路发送流。在方法中比较当前边与上一条边的边权，取较小者，并将此取值作为递归DFS方法的入参数(具体看代码)。若存在p，也即递归调用到基本情形(遇到t)，以当前边权减去c，当前边的反向边权加上c，然后返回c。
4. 在返回c的过程中完成增广路上的边权调整，返回到主调函数，以while(f.res > 0)判断，满足则将f.res加入当前分层图发送流总和的累积结果中。当前分层图完成所有增广后再递归调用DFS，由于已无增广路，故不会递进到基本情形(遇到t)，返回0且层层返回0，于是while(f.res > 0)不成立，返回当前分层图下的发送流总和。
5. 累计分层图发送流，清空所有顶点的高度标号信息，再次调用BFS方法建立当前分层图，重复2、3、 4，直到建立分层图的BFS方法返回false，表明当前图无法分层，即s到t无增广路，算法结束。此时得到的累积发送流为s到t的最大流。

<br />

#### 优化

上述朴素Dinic算法中，在当前分层图下，每次主程序(对单条增广路方法singleAugPathDfs来说的主程序是分层图增广路方法levelGraphAugPathDfsDrive)主调用DFS(singleAugPathDfs)找到一条增广路后，会一直return到本次主调用结束，层层返回本次增广路的发送流，并在每次返回时修改当前边的正反向边权。接着主程序基于`(singleAugFlow = singleAugPathDfs(des, src, singleAugFlow)) > 0`的判断再次调用singleAugPathDfs，又一次从src顶点开始搜索下一条到des的增广路。以下图为例，增广过程如下：

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvfw5jat8ij608a0aiaa502.jpg" width="150" />
</div>

第一次主调：s>a>c>t, 找到增广路后return，得到minEdge，修改当前边正向和反向边权后return，再次修改当前边的正向和反向边权后return(层层返回并如此操作)，t>c>a>s然后退出主调用，本次主调结束，得到本次增广路发送流为2。整体的顶点访问顺序为s>a>c>t>c>a>s。

第二次主调：s>a>c，发现(c, t)边权为0，不满足邻边边权要大于0的条件，找a的下一个满足层号关系的邻接顶点d，然后d>t，同上，找到增广路后在return过程中修改正反向边权，t>d>a>s后退出主调用，本次主调结束，得到本次增广路发送流为1。整体的顶点访问顺序为s>a>c>d>t>d>a>s。

第三次主调：从s开始，发现(s, a)边权为0，不满足邻边边权要大于0的条件，找s的下一个满足层号关系的邻接顶点b，然后b>d>t，同上，找到增广路后在return过程中修改正反向边权，t>d>b>s后退出主调用，本次调用结束，得到本次增广路发送流为2。整体的顶点访问顺序为s>b>d>t>d>b>s。

第四次主调：从s开始，for循环遍历所有邻接顶点均不满足邻边边权要大于0的条件，返回0 (`return 0;`)，于是主调方法的while也结束，得到最终结果maxFlow = 5.

注意：使用对DFS“主调”这个表述是为了区别于DFS自身的递归调用。

第一次主调详细递归过程如下，黑框表示levelGraphAugPathDfsDrive方法，蓝框表示singleAugPathDfs方法。如图所示，levelGraphAugPathDfsDrive对singleAugPathDfs的一次主调，在singleAugPathDfs的多次递归调用后，找到第一条增广路s>a>c>t，并得到该增广路的可发送流(大小为2)，将其加入multipleAugFlow中。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxvvfct28bj30cs0cq0tt.jpg" width="510"/>
</div>

##### 优化: 当前弧优化

朴素Dinic算法中，假设源点src有多个邻接顶点A，B，C，D....。每次DFS都会从源点第一个邻接顶点A开始尝试增广，假设经过A有两条增广路。那么两次主调用DFS后，经过A的两条增广路都被找到，接着第3次主调用DFS，从A开始尝试增广，显然已无法经过A增广，于是尝试B，假设经过B有一条增广路，于是第3次主调用DFS的结果是找到经过B的一条增广路。接着第4次主调用DFS，此时仍然会从A开始尝试，到这里我们就可以发现，尽管经过A的增广路早已被穷尽，但每次对DFS的新的主调用，还是会从源点的第一个邻接顶点A开始尝试增广，这显然是无谓的开销。每次主调DFS时，不是从源点的第一个邻接顶点开始，而是从上一次主调所处理的那个源点的邻接顶点开始，就可以避免上述无谓的开销。如前述，经过3次对DFS的主调用，已经完成了经过A，B共3条增广路的寻找，在第4次主调用DFS时，不是从A开始，而是从B开始(注意不是C，因为要等到判断B.isBlocked = true才跳过)尝试，已无经过B的增广路(B.isBlocked = true)，于是寻找下一个邻接顶点C，执行经过C的增广路的寻找。下一次对DFS的主调用，从C开始(注意不是D)。这就是“当前弧优化”。

<br />

##### 优化: 分层图多路增广优化

通过上述对程序运行过程的分析，可以看到每次对DFS的主调，得到增广路后不断回退到主调结束，然后再利用下一次主调寻找下一条增广路。每一次主调寻找当前分层图下的一条增广路，如果在找到增广路后不是一路回退，而是在回退到上一个节点后继续探索其下一个满足条件的邻接顶点，那么可以期待一次主调就能完成当前分层图下所有增广路的寻找，得到当前分层图下s到t的最大流。做法如下：

1. 为每一个顶点维护一个可用流数据(flow)，源点s的可用流设置为Integer.MAX_VALUE。该属性表示顶点的可发送流。
2. 在分层图中以DFS搜索增广路的过程中，for循环考察当前顶点v的邻接顶点w，对每一个w，更新w.flow值，则w.flow = min(v.flow, edgeValue(v, w))。
3. 找到增广路时通过汇点的可用流得到该增广路的最小边权(饱和边权)singleAugFlow。注意，朴素版本在DFS增广过程维护一个增广路上的最小边权，增广完成后以其为该次增广的发送流，在本优化中，增广完成时，本次增广的发送流是当前顶点即汇点的可用流`des.flow`。在2中已经知道，每一个顶点的可用流都是在以它为当前顶点时赋予或更新的。
4. 得到当前增广路发送流currentFlow后回退，将其累积到分层图发送流incFlow上，并将当前顶点v的可用流中减去singleAugFlow，即v.flow -= currentFlow。之后可以加入一个即时判断优化，if(v.flow == 0)，若v的可用流为0，则不必再考察通往v的其他邻接顶点的增广路，直接跳出for循环。
4. for循环结束后，表明经过当前顶点v(假设其前驱顶点为u)的所有增广路已穷尽，于是将(u, v)边权减去incFlow，将(v, u)边权加上incFlow。
4. 当前分层图无增广路时，即递归调用的DFS返回到最外层并结束for循环时，返回的incFlow即为当前分层图下总发送流。
4. 累计分层图发送流，清空所有顶点的高度标号信息，再次调用BFS方法建立当前分层图，重复2、3、 4、5、6，直到建立分层图的BFS方法返回false，表明当前图无法分层，即s到t无增广路，算法结束。此时得到的累积发送流为s到t的最大流。

以下图为例分析展示应用了分层图多路增广优化的Dinic算法对初次建立的分层图的详细运行过程。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy59ygvtc5j3035069jr8.jpg" width="100" />
</div>

每一个蓝框表示一次multipleAugPathDfs调用。可以看到最外层的对multipleAugPathDfs的一次主调用即可得到当前分层图下的最大流。此后无法再建立分层图，程序结束，得到正确的最大流为5。

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gy59u61skuj31z40o5797.jpg" alt="dinic opt" width="1000" />
</div>

注意：当前弧优化是针对朴素Dinic算法来说的，如果已经实现了分层图多路增广优化，在当前分层图下，对DFS只需执行一次主调用，也就不存在当前弧优化应对的场景了。

<br />

#### 时空复杂度

以下证明时间复杂度为：$O(|V|^2|E|)$

>  如下证明参考了[COMPSCI 638: Graph Algorithms, Lecture3](https://courses.cs.duke.edu/fall19/compsci638/fall19_notes/lecture3.pdf)。

##### 1. BFS建立分层图: $O(|E|)$

可参考无权最短路径复杂度分析，略。

##### 2. 一次DFS增广: $O(|V|)$

在分层图中，由于高度标号加一的判断条件限制，DFS只能沿着高度递增的方向从 $s$ 到 $t$ 推进，因此单次DFS推进次数最多不超过 $|V|-1$ 次，时间复杂度为 $O(|V|)$。

##### 3. 一个阶段中DFS增广次数：$O(|E|)$

在分层图中，每次DFS增广的结果使得一条高度递增方向上的饱和边 $(u, v)$ 消失，此边的反向边 $(v, u)$ 增加。如前述，**增广路只能沿着高度递增的方向**，而同一阶段内(同一张分层图中)反向边是沿着高度递减方向增加的。$(u, v)$ 消失后再次出现的条件是 $(v, u)$ 为此后某次增广路上的饱和边。**再次强调**，在 **同一阶段内** (同一张分层图中)，$(v, u)$方向是**高度递减**的，不可能出现在增广路上，因此一条高度递增边 $(u, v)$ 被删除后不会再次出现。一次增广至少令一条高度递增边饱和并删除，高度递增边数量不大于$|E|$，于是 **一个阶段内DFS的次数最多为 $|E|$，即 $O(|E|)$**。结合 2 可知，**一个阶段的总复杂度为单次DFS的复杂度与DFS次数的乘积，即 $O(|V||E|)$**。

##### 4. 阶段数(分层图建立次数): $O(|V|)$

**此证明是难点。** 如前述，在层高递增条件的限制下，$s - t$ 最短路径长度即 $t$ 的层高，因此最短路径最大不超过 $|V| - 1$。如果能证明每次分层图使得 $s - t$ 最短路径长 **「严格」递增** ，则立即推出阶段数(分层图建立次数)的上限为 $|V|$，复杂度为 $O(|V|)$。最短路径长严格递增的证明如下。

令相邻的两次分层图为 $G_f$  和 $G_{f'}$ ，以 $d(u, v)$ 和 $d'(u, v)$ 分别表示$G_f$  和 $G_{f'}$ 中的 $u$ 到 $v$ 的最短距离。

1. 由[Edmonds-Karp算法复杂度证明](https://leetcode-cn.com/circle/discuss/tN3sZc/)已知 (这一点很重要)，删正向边加反向边的操作，使得**源点 $s$ 到任意一点 $u$ 的距离是非递减**的，即 **必有** $d'(s, u) ≥ d(s, u)$。对证明过程稍加改造很容易得到一个对汇点 $t$ 来说类似的结论，即删正向边加反向边的操作，使得任意一点 $u$ 到汇点 $t$ 的距离是非递减的，即 **必有** $d'(u, t) ≥ d(u, t)$。

   (1)    $d'(s, u) ≥ d(s, u)$

   (2)    $d'(u, t) ≥ d(u, t)$ 

对于 $s - t$ 来说有 $d'(s, t) ≥ d(s, t)$。接下来的证明目标是**拿掉该不等式中的等号**，证明 $G_{f'}$ 相比 $G_f$，严格地有 $d'(s, t) > d(s, t)$。可用**反证法证明不可能取等号**。

2. **假设 $d'(s, t) ≥ d(s, t)$ 可以取到等号**。 
   若$G_{f'}$ 有一条 $s$ 到 $t$ 的最短路径 $f'$，则一定存在边 $(x, y) ∈ E_{f'}$，是 $G_f$ 某条增广路饱和边的反向边。因为如果 $E_{f'}$ 都是 $G_f$ 中存在的边，由于 $d'(s, t) = d(s, t)$，这样的 $f'$ 路径在 $G_f$ 中就**一定**已经被找到了。因此在 $G_f$ 中有 $(y, x) ∈ E_f$ ，于是有

   (3)    $d(s, x) = d(s, y) + 1$

<div align=center> 
  <img src="https://tva1.sinaimg.cn/large/e6c9d24ely1h29ezrs42cj20aq0fa74i.jpg" alt="image-20220515213405940" width="180;" />
</div>



3. 由 (1) 和 (2) 易知

   (4)    $d'(s, x) ≥ d(s, x)$  

   (5)    $d'(y, t) ≥ d(y, t)$

4. $f'$ 路径长可写成 $d'(s, t) = d'(s, x) + 1 + d'(y, t)$ ，应用 (4) 和 (5) 得到

   $d'(s, t) = d'(s, x) + 1 + d'(y, t) ≥ d(s, x) + 1 + d(y, t)$ 

   又由 (3) 得到

   $d'(s, t) = d'(s, x) + 1 + d'(y, t) ≥ d(s, x) + 1 + d(y, t) = d(s, y) + d(y, t) + 2$

   即

   (6)    $d'(s, t) ≥ d(s, t) + 2$

由此，$d'(s, t) = d(s, t)$ 的假设不成立，但我们知道 $d'(s, t) ≥ d(s, t)$ ，因此有 $d'(s, t) > d(s, t)$ ，也即证明了**Dinic算法中下一分层图的最短路径长度与前一分层图相比严格递增**。

<br />

综上，总时间复杂度为每个阶段建立分层图的复杂度 $O(|E|)$ 与在该分层图内执行的总DFS复杂度 $O(|V||E|)$ 之和乘以阶段数 $O(|V|)$，为 $O((|E|+|V||E|)*|V|)$，即 $O(|V|^2|E|)$。

<br />

空间复杂度：

<br />

#### 代码

##### 朴素版本

```java
public int maxFlowDinicBasic(Vertex<E> src, Vertex<E> des) {
    int maxFlow = 0;
    // 不断构建分层图，levelGraphBFS(src, dec)返回是否有增广路的布尔值
    while(levelGraphBFS(src, des)) {
        // 在一个确定有增广路的分层图中，求多条增广路可发送流的和，加入到最大流中
        maxFlow += levelGraphAugPathDfsDrive(src, des);
        // 当前分层图处理完毕后重置顶点，主要是层号信息
        clearVertices();
    }

    return maxFlow;
}
/**
 * bfs方式构建分层图，确定每个顶点的层号属性值(int level，取值0,1,2,3...)
 * 返回判断是否存在增广路径的布尔值
 */
private boolean levelGraphBFS(Vertex<E> src, Vertex<E> des){
    Queue<Vertex<E>> q = new LinkedList<>();
    src.setLevel(0);
    q.add(src); // 起始顶点入队
    boolean isExist = false; // 包含des的分层图是否存在，即当前图是否存在增广路

    while(!q.isEmpty()) {
        int levelSize = q.size(); // 获取当前队列大小，也即本层顶点个数
        for (int i = 0; i < levelSize; i++) { // 分配层号的关键
            Vertex<E> v = q.remove(); // 由于有levelSize的边界控制，本轮for只会将本层顶点出队
            // 每次顶点v出队
            for (Vertex<E> w : getAdjList(v)) {
                // 寻找未访问过且存在的邻接顶点，通过level标志判断是否访问过，所以不需要!isKnown条件
                if(w.getLevel() == -1 && getEdgeValue(adjListsWeighted, v, w) > 0) {
                    w.setLevel(v.getLevel() + 1);
                    q.add(w); // w入队
                }
            }
        }
    }
    if(des.getLevel() != -1) {
        return isExist = true;
    }

    return isExist;
}
/**
 * 求当前分层图下所有增广路径发送流的和
 */
private int levelGraphAugPathDfsDrive(Vertex<E> src, Vertex<E> des) {
    int singleAugFlow = Integer.MAX_VALUE;
    int multipleAugFlow = 0;
    // 将singleAugPathDfs方法换成singleAugPathDfsCurrentEdgeOpt应用当前弧优化
    // while((singleAugFlow = singleAugPathDfsCurrentEdgeOpt(des, src, singleAugFlow)) > 0) {
    while((singleAugFlow = singleAugPathDfs(des, src, singleAugFlow)) > 0) {
        multipleAugFlow += singleAugFlow;
    }
    return multipleAugFlow;
}
/**
 * 朴素Dinic算法未应用当前弧优化的版本
 */
private int singleAugPathDfs(Vertex<E> des, Vertex<E> current, int singleAugFlow){
    if(current == des) {
        return singleAugFlow;
    }
    for(Vertex<E> w : getAdjList(current)) {
        // 层号关系是关键 w.getLevel() == current.getLevel() + 1
        // 保证了每次dfs总是当前图src到des的最短路径
        if(w.getLevel() == current.getLevel() + 1 && getEdgeValue(adjListsWeighted, current, w) > 0) {
            int minEdge = singleAugPathDfs(des, w, Math.min(singleAugFlow, getEdgeValue(adjListsWeighted, current, w)));
            if(minEdge > 0) {
                setEdgeValue(adjListsWeighted, current, w, getEdgeValue(adjListsWeighted, current, w) - minEdge);
                setEdgeValue(adjListsWeighted, w, current, getEdgeValue(adjListsWeighted, w, current) + minEdge);
                return minEdge; 
            }
        }
    }

    // 在当前分层图下完成所有增广后，s已无到t的增广路，
    return 0;
}
```

<br />

##### 当前弧优化版本

```java
private int singleAugPathDfsCurrentEdgeOpt(Vertex<E> des, Vertex<E> current, int singleAugFlow){
    if(current == des) {
        return singleAugFlow;
    }
    boolean blockFlag = true;
    for(Vertex<E> w : getAdjList(current)) {
        // 层号关系是关键 w.getLevel() == current.getLevel() + 1
        // 保证了每次dfs总是当前图src到des的最短路径
        // 添加 !w.isBlocked() 条件实现当前弧优化
        if(!w.isBlocked() && w.getLevel() == current.getLevel() + 1 && getEdgeValue(adjListsWeighted, current, w) > 0) {
            blockFlag = false;
            int minEdge = singleAugPathDfsCurrentEdgeOpt(des, w, Math.min(singleAugFlow, getEdgeValue(adjListsWeighted, current, w)));
            if(minEdge > 0) {
                setEdgeValue(adjListsWeighted, current, w, getEdgeValue(adjListsWeighted, current, w) - minEdge);
                setEdgeValue(adjListsWeighted, w, current, getEdgeValue(adjListsWeighted, w, current) + minEdge);
                return minEdge; 
            }
        }
    }
    // 若current经过整个for都无法找到满足条件的邻接顶点，即blockFlag保持不变，则将current置为阻塞
    if(blockFlag) {
        current.setBlock(true);
    }

    return 0;
}
```

<br />

##### 分层图多路增广优化版本

```java
public int maxFlowDinic(Vertex<E> src, Vertex<E> des) {
    int maxFlow = 0;
    // 不断构建分层图，在一个确定有增广路的分层图中，求多条增广路可发送流的和，加入到最大流中
    while(levelGraphBFS(src, des)) {
        // 每次在当前分层图下多路增广前设置src的可用流
        src.setRemainFlow(Integer.MAX_VALUE); 
        maxFlow += multipleAugPathDfs(src, des);
        clearVertices(); // 每次结束当前分层图下的多路增广后重置顶点信息(层号信息)
    }

    return maxFlow;
}

/**
 * 以DFS方式查找当前分层图上所有增广路
 * 返回这些增广路可发送流之和
 */
private int multipleAugPathDfs(Vertex<E> current, Vertex<E> des) {
    int incFlow = 0;
    // 如果当前顶点是汇点，说明找到一条增广路，得到本条增广路的发送流量incFlow，
    // 调整des.pre和des正反向边权后返回incFlow
    if(current == des) {
        Vertex<E> v = current.getPre();
        incFlow = des.getRemainFlow();
        setEdgeValue(adjListsWeighted, v, current, getEdgeValue(adjListsWeighted, v, current) - incFlow);
        setEdgeValue(adjListsWeighted, current, v, getEdgeValue(adjListsWeighted, current, v) + incFlow);
        return incFlow;
    }
    // 考察当前顶点的邻接顶点，对满足条件的顶点执行dfs
    for (Vertex<E> w : getAdjList(current)) {
        if(w.getLevel() == current.getLevel() + 1 && getEdgeValue(adjListsWeighted, current, w) > 0) {
            w.setPre(current); // 将current记录为其邻接顶点w的前驱
            // 设置w的可用流为current的可用流和(current, w)边权中的较小者
            w.setRemainFlow(Math.min(current.getRemainFlow(), getEdgeValue(adjListsWeighted, current, w)));
            // dfs递归寻找增广路
            incFlow += multipleAugPathDfs(w, des);
            // 找到增广路回退后，对回退到的当前顶点，从它的可用流减中减去求当次增广路发送流incFlow
            current.setRemainFlow(current.getRemainFlow() - incFlow);;
            // 如下是一个高效优化，当前顶点的流减到0后，直接退出当前for循环，
            // 即由于当前顶点current已无剩余流可发送，也即不再存在经过current的其他增广路，所以不必再尝试它的其他邻接顶点
            if(current.getRemainFlow() == 0) {
                break;
            }
        }
    }
    // 上述for循环结束，说明当前顶点current的邻接顶点均已考察完毕，即已
    // 穷尽经过current节点的增广路，此时的incFlow就是这些增广路的可发送流量的和，
    // 用incFlow对(curPre, current)和(current, curPre)边权进行调整。
    Vertex<E> curPre = current.getPre();
    if(curPre != null) { // 注意当current为src时，其前驱为null
        setEdgeValue(adjListsWeighted, curPre, current, getEdgeValue(adjListsWeighted, curPre, current) - incFlow);
        setEdgeValue(adjListsWeighted, current, curPre, getEdgeValue(adjListsWeighted, current, curPre) + incFlow);
    }

    return incFlow;
}
```

<br />

### 最小费用流

<br />

### 二分图

<br />

## 最小生成树

### Prim算法

Prim 算法与 Dijkstra 算法非常类似，在形式上仅有一行松弛操作不同，后续以表格对比形式给出该算法的描述。

<br />

#### 朴素版

##### 算法描述

| Dijkstra                                                     | Prim                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 贪婪算法                                                     | 贪婪算法                                                     |
| 算法将顶点区分为已确定到源点s最短路径的距离的顶点和未确定的顶点 | 算法将顶点区分为已经加入最小生成树的顶点和尚未加入的顶点     |
| 将所有顶点到源点s的距离初始化为Infinity<br />源点s的距离初始化为0 | 将所有顶点到父顶点的距离初始化为Infinity<br />生成树起始点s的距离初始化为0 |
| while判断是否还有未确定顶点，若有则以BFS的方式访问当前顶点v的所有邻接顶点w，以如下方式松弛dw，并更新w的前驱顶点为v<br />**dw = min(dw, dv + d(v, w))** | while判断是否还有未确定顶点，若有则以BFS的方式访问当前顶点v的所有邻接顶点w，以如下方式松弛，并更新w的前驱顶点为v<br />**dw = min(dw, d(v, w))** |
| 在具有有效距离(d != infinity)的未确定顶点中找到距离最小者作为当前顶点 | 在具有有效距离(d != infinity)的未确定顶点中找到距离最小者作为当前顶点 |
| 当前不存在未确定顶点时退出while，算法结束<br />取得所有顶点最短路径距离 | 当前不存在未确定顶点时退出while，算法结束<br />取得所有顶点在最小生成树上的距离 |

<br />

##### 算法过程

朴素版本过程如下：

1. 初始化。选定一个起始点s，初始化所有顶点到源点s的距离为Infinity，表示该点到父顶点的距离尚未确定（尚未确定选择哪条父顶点接入生成树），置s的距离为0。

2. 以while循环寻找当前距离未确定顶点中距离最小者。在当前具有有效距离(即不为无穷大)的距离未确定的顶点中找到距离最小者v，置v的距离为已确定。

3. 松弛操作。更新v的所有邻接顶点w的距离dw。有如下两种情况，因为在松弛前所有顶点的距离默认为Infinity，所以两种情形的形式一样，都是判断d(v, w) < dw。（若初始将顶点距离设置为负数则需要分开处理）

   3.1  若初次访问，dw有效化为dw = d(v, w)。更新w的前驱，w.pre = v。

   3.2. 若不是初次访问，当满足d(v, w) < dw时，更新dw，dw = dv + d(v, w)。更新w的前驱，w.pre = v。

4. 当所有顶点距离都确定时while循环结束，每个顶点的父顶点和到父顶点的距离被确定。

补充说明：

1) 第2步是该算法贪婪的体现，即每次while都确定一个顶点的最短路径，while结束时求得所有顶点的最短路径。
2) 第3步是BFS思想的体现。每次while确定一个顶点后，调整其邻接顶点的距离，即一次处理一层。
3) 针对第2步在当前距离未确定顶点中寻找距离最小值，可以采用优先队列(小顶堆)进行改进，具体实现见后续。
4) 与Dijkstra算法不同的是，Prim算法只比较所有可能的父边(到父顶点的边)的边权的大小，不受Dijkstra中路径上边权累计的影响，所以负值边和圈都不影响算法的正确性，Prim能够处理负边图和有圈图。

<br />

##### 时空复杂度

与Dijkstra算法相同。

时间复杂度: $O(|V|^2+|E|)$ ，由于 $|E| < |V|^2$ ，所以也可以写为 $O(|V|^2)$ 。

1. 寻找拥有最小距离的顶点的时间为O(|V|^2)。 先遍历一遍顶点确认存在距离未确定的顶点O(|V|)，再遍历一遍顶点寻找未确定距离的顶点中距离最小者O(|V|)。

2. 所有顶点的距离被松弛的次数上限为O(|E|)。由算法可知顶点距离松弛只发生在找到当前距离未确定且距离最小的顶点之后，一次更新的次数是该顶点的邻接顶点数(即出边数，出度)。每一次循环松弛某一个顶点的所有出边。所有顶点的出边数即总边数|E|。故总松弛次数，也即所有顶点的距离被更新的次数上限为O(|E|)。

空间复杂度：算法过程中只用到常数个变量，不考虑顶点/边/图的数据结构本身消耗的空间时为 $O(1)$ 。

<br />

##### 代码

```java
public List<Vertex<E>> primBasic(Vertex<E> s){
    // 按顶点确定的顺序输出，res最终包含所有顶点，且每个顶点的距离满足最小生成树
    List<Vertex<E>> res = new ArrayList<>(); 
    s.setDistance(0);

    // 遍历所有顶点确认是否有未访问过的顶点， O(|V|)
    while(checkUnknown(vertices)) { 
        // 从unknowns中取出距离最小的顶点， O(|V|)
        Vertex<E> v = getUnknownMin(vertices);
        v.setKnown(true); // 设置为距离已确定
        res.add(v); // 按顺序输出已确定距离的顶点
        // 松弛v的邻接顶点w，O(|E|)
        for (Vertex<E> w : getAdjList(v)) {
            // 松弛对象是未确定距离的w
            // 因为是无向图，以v的邻接顶点以邻接表实现，不需要边是否存在的判断条件 getEdgeValue(v, w) != 0
            if(!w.isKnown()) { 
                int dw = getEdgeValue(adjListsWeighted, v, w);
                if(dw < w.getDistance()) { // 松弛条件
                    w.setDistance(dw);
                    w.setPre(v); 
                }
            }
        }
    }

    return res;
}
```

<br />

#### 优先队列(堆)版

##### 算法描述

针对朴素版算法第2步在当前距离未确定顶点中寻找距离最小者，可以采用优先队列(小顶堆)进行改进，其他过程与朴素版一致。需要注意的是一个顶点的距离在被确定前可能经过多次松弛，算法在每次顶点距离松弛时将其入堆，于是同一时间，堆中可能有多个相同的顶点(松弛过几次就有几个)。这其中最靠顶的将会先出堆，出堆即表明该顶点距离已确定(或者说在此时确定)，所以顶点出堆时要判断是否是第一次出堆，若不是则跳过。

<br />

##### 算法过程

1. 初始化。选定一个起始点s，初始化所有顶点到s的距离为Infinity，表示该点到s的距离尚未确定，置s的距离为0。准备一个小顶堆pq，将s入堆。

2. 一次有效出堆完成一个顶点最短路径的确定。以while循环对pq判空，若不空，堆顶顶点v出堆。若v不是第一次出堆则跳过，若是则v为此时未确定距离的顶点中距离最小者，置v的距离为已确定。

3. 松弛操作。更新上述顶点v的所有邻接顶点w的距离dw。有如下两种情况，因为在松弛前所有顶点的距离默认为无穷大，所以两种情形的形式一样，都是判断是否有d(v, w) < dw。dw被松弛则将w入堆，以支持第2步(在当前具有有效距离的顶点中找到距离最小者)。

   3.1  如果是初次访问，满足d(v, w) < dw，w到s的距离dw有效化为dw = d(v, w)。

   3.2. 当w不是初次访问，当满足d(v, w) < dw时，更新dw，dw = d(v, w)。

4. 当堆中无元素即所有顶点距离都确定时while循环结束，每个顶点的父顶点和到父顶点的距离被确定。

<br />

##### 时空复杂度

时间复杂度：O(|E|log|E|+(|E| + |E|log|E|)，化简为O(|E|log|V|) ，化简依据后述。

1. 在当前距离未确定顶点中寻找距离最小者 O(|E|log|E|)。while中pq判空次数与堆大小有关，为O(|E|)，下述。获取距离最小者耗时也与堆大小有关，为O(log|E|)，故为O(|E|log|E|)。

   ※ 优先队列判空操作isEmpty()本身是常数时间操作，但总共要执行O(|E|)次。

2. 所有顶点的距离被更新(松弛)的次数上限为O(|E|)。由算法可知顶点距离的更新(或者说边的松弛)只发生在找到当前距离未确定且距离最小的顶点之后，一次更新的次数是该顶点的邻接顶点数(即出边数，出度)。每一次循环确定一个这样的顶点，也就是每一次循环松弛某一个顶点的所有出边。所有顶点的出边即总边数为|E|。故总松弛次数，也即所有顶点的距离被更新的次数，也即顶点入堆总次数为O(|E|)。dw更新时w入堆，插入操作的时间复杂度为O(log|E|)，入堆次数与更新次数相同，于是所有顶点的距离更新与顶点入堆的时间复杂度为O(|E| + |E|log|E|)，由于|E| <= |V|*(|V| - 1) ，故log|E| <= 2log|V|，故可化简为O(|E|log|V|)。

   ※ 根据上述顶点入堆次数取决于总边数的分析，堆的大小上限不是|V|而是|E|(或者说是O(|E|))，所以dw更新时w入堆的插入操作的时间复杂度为O(log|E|)，只是借助边数与顶点数的关系，可化简为O(log|V|)。

空间复杂度：不考虑用于返回的顶点列表时为O(1)。

※ 连通图顶点数与边数的关系：

无向连通图：|V| - 1 <= |E| <= |V|*(|V| - 1) / 2 

链状时|E|取到最小|V|-1，完全连通即两两相连时取到最大|V|*(|V| - 1) / 2 

有向连通图：|V| - 1 <= |E| <= |V|*(|V| - 1) 

链状时|E|取到最小|V|-1 (只差常数1)，完全连通即两两相连且正反向成对时取到最大|V|*(|V| - 1) 

<br />

##### 代码

```java
public List<Vertex<E>> primPQ1(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>(); 
    s.setDistance(0);
    // 泛型PriorityQueue的写法，重写compare方法，比较元素getDistance()方法的结果，小顶堆
    PriorityQueue<Vertex<E>> pq = new PriorityQueue<>(new Comparator<Vertex<E>>() {
        @Override
        public int compare(Vertex<E> v1, Vertex<E> v2) {
            return v1.getDistance() - v2.getDistance();
        }
    });
    pq.add(s);

    while(!pq.isEmpty()) { // 判空 O(|E|)
        // 从unknowns中取出距离最小的顶点， O(log|E|)
        Vertex<E> v = pq.remove();
        // 当顶点v被更新过多次(多次入堆)，则存在v多次出堆的情况，
        // 跳过不是第一次出堆的顶点(v.isKnown = true)
        if(v.isKnown()) { 
            continue;
        }
        v.setKnown(true); // 置v的距离为已确定
        res.add(v); // 按顺序输出已确定距离的顶点
        // 松弛v的邻接顶点w，O(|E|log|E|)
        for (Vertex<E> w : getAdjList(v)) {
            if(!w.isKnown() && getEdgeValue(adjListsWeighted, v, w) != 0) { // 松弛对象是距离未确定的w
                // 将dw初次赋有效值或dw有更新时的w加入到pq中，以保证算法过程第2步总是
                // 能够在所有“具有有效距离值但距离未确定”的顶点中寻找距离最小者。
                // 注意dw有更新的情况下堆中可能有多个w(dw不同)，因此插入次数上限与更新次数上限相同，为O(|E|)。
                int dw = getEdgeValue(adjListsWeighted, v, w);
                if(dw < w.getDistance()) { // 松弛条件
                    w.setDistance(dw); // 更新dw
                    w.setPre(v); // 置w的前驱为v
                    pq.add(w); // 插入堆中，注意一个顶点的dw可能更新多次，O(log|E|)
                }
            }
        }
    }

    return res;
}

public int getMSTCost() {
    int cost = 0;
    for (Vertex<E> v : vertices) {
        cost += v.getDistance();
    }
    return cost;
}
```

<br />

### Kruskal算法

#### 算法描述

<br />

#### 算法过程

<br />

#### 时空复杂度

<br />

#### 代码

<br />

## 再探图搜索 (遍历)

### 双向 BFS

<br />

### 多源 BFS

<br />

### 无向图所有圈

<br />

### 有向图所有圈

<br />

### 无向图割点

<br />

### 无向图欧拉回路

<br />

### 有向图强连通分量

<br />

## 实战应用

给出以下图论相关题目即作者写的题解，供读者在阅读本文后自查。

| 题目                                                         | UF   | BFS  | DFS  | Topo | SP   | MF   | MST  |
| ------------------------------------------------------------ | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| [323. 无向图中连通分量的数目](https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/) | 〇   | 〇   | 〇   |      |      |      |      |
| [684. 冗余连接](https://leetcode.cn/problems/redundant-connection/) | 〇   | 〇   | 〇   |      |      |      |      |
| [329. 矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/) |      |      |      | 〇   |      |      |      |
| [207. 课程表](https://leetcode.cn/problems/course-schedule/) |      | 〇   | 〇   | 〇   |      |      |      |
| [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) |      | 〇   | 〇   | 〇   |      |      |      |
| [269. 火星词典](https://leetcode.cn/problems/alien-dictionary/) |      |      |      | 〇   |      |      |      |
| [444. 序列重建](https://leetcode.cn/problems/sequence-reconstruction/) |      |      |      | 〇   |      |      |      |
|                                                              |      |      |      |      |      |      |      |

```
UF: Union-Find 并查集
FS: DFS & BFS 深搜和广搜
Topo: Topological Sort 拓扑排序
SP: Shortest Path 最短路
MF: Maximum Flow 最大流
MST: Minimum Spanning Tree 最小生成树

标记 〇 表示该题的解决方法应用了该算法。
```

| 题目                                                         | 难度 | 题解                                                         |
| ------------------------------------------------------------ | ---- | ------------------------------------------------------------ |
| [323. 无向图中连通分量的数目](https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/) | 中等 | [题解](https://leetcode.cn/problems/number-of-connected-components-in-an-undirected-graph/solution/by-yukiyama-y5l4/) |
| [684. 冗余连接](https://leetcode.cn/problems/redundant-connection/) | 中等 | [题解](https://leetcode.cn/problems/redundant-connection/solution/-by-yukiyama-mlqi/) |
| [329. 矩阵中的最长递增路径](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/) | 困难 | [题解](https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/solution/by-yukiyama-d7bv/) |
| [207. 课程表](https://leetcode.cn/problems/course-schedule/) | 中等 |                                                              |
| [210. 课程表 II](https://leetcode.cn/problems/course-schedule-ii/) | 中等 | [题解](https://leetcode.cn/problems/course-schedule-ii/solution/-by-yukiyama-9scu/) |
| [269. 火星词典](https://leetcode.cn/problems/alien-dictionary/) | 困难 | [题解](https://leetcode.cn/problems/alien-dictionary/solution/by-yukiyama-2cam/) |
| [444. 序列重建](https://leetcode.cn/problems/sequence-reconstruction/) | 中等 | [题解](https://leetcode.cn/problems/sequence-reconstruction/solution/by-yukiyama-a371/) |
|                                                              |      |                                                              |
|                                                              |      |                                                              |

<br />