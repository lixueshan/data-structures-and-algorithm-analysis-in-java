# 第9章 - 图论算法

## 思维导图和算法总结



## 图的基本知识

### 基本概念汇总

| 概念                                     | 描述                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| 图 (graph)                               | 由顶点集合V和边集合E组成                                     |
| 边 (edge)                                | 一对点 (v, w), v, w ∈ V                                      |
| 有向图 (directed graph / digraph)        | 点对有序的图                                                 |
| 无向图 (undirected graph)                | 点无序的图，(v, w)与(w, v)为两条不同的边                     |
| 邻接 (adjacent)                          | 顶点w与v邻接当且仅当 (v, w) ∈ E                              |
| 权 (weight) / 值 (cost)                  | 边的权重                                                     |
| 路径 (path)                              | 为一顶点序列 w1, w2, w3,...,wN使得(wi, w(i+1)) ∈ E, 1<=i<=N<br />一个顶点到他自身也可以看成是一条路径，如果路径不包含边，则路径长为0 |
| 路径的长 (path length)                   | 路径上边的数量                                               |
| 简单路径                                 | 路径上的所有顶点都是不同的，但第一个和最后一个可能可以相同   |
| 环 (loop)                                | 一个顶点到它自身的边 (v, v)，本章讨论的图一般都是无环的      |
| 圈 (cycle)                               | 满足w1 = wN的长至少为1的路径                                 |
| 有向无圈图 (directed acyclic graph, DAG) | 无圈的有向图                                                 |
| 连通图 (connected graph)                 | 从一顶点w到另一顶点v有路径相连称w与v连通，任意两顶点之间连通的图称为连通图。对于有向连通图，两点之间的路径上的边必须同向 |
| 强连通 (strongly connected)              | 称有向连通图是强连通的                                       |
| 基础图 (underlying graph)                | 有向图去掉边的方向后的图称为该有向图的基础图                 |
| 弱连通 (weakly connected)                | 有向图不是强连通的，但其基础图是连通的，则称该有向图是弱连通的 |
| 完全图 (complete graph)                  | 每一对顶点间都有边相连的图                                   |
| 邻接矩阵 (adjacent matrix)               | 对每条边(u, v)置矩阵的A[u, v]为true，无(u, v)边则为false，若边有权，则A[u, v]等于该值，以一个很大或很小的数表示该边不存在 |
| 邻接表 (adjacency list)                  | 以邻接矩阵表示图，当图较稀疏时空间代价为\|V\|^2，针对这种情况，对稀疏图可以采用邻接表来表示，对每一个顶点，以一个表存放其邻接顶点，则空间降为\|E\|+\|V\|，相对图的大小而言是线性的 |
| 拓扑排序 (topological sorting)           | 对有向无圈图的顶点的排序，使得若存在从w到v的路径，则v在排序中出现在w之后<br />显然当图含有圈时无法做到拓扑排序 |
| 入度 (indegree)                          | 对有向图顶点v而言，(u, v)边的数量                            |
| 出度 (outdegree)                         | 对有向图顶点v而言，(v, u)边的数量                            |
| 赋权路径长(weighted path length)         |                                                              |
| 无权路径长(unweighted path length)       |                                                              |
| 单源最短路径问题                         |                                                              |
| 无权最短路径                             |                                                              |
| 广度优先搜索                             |                                                              |
|                                          |                                                              |
|                                          |                                                              |



### 图数据结构示例



```java
```



## 拓扑排序

### Kahn算法

#### 算法描述

找出任意一个入度为0的顶点，放入队列中，从队列输出该顶点并将其邻边入度减1，同时检查这些邻边的入度，若算法未结束，则会出现新的入度为0的顶点，将其入队。于是不断有新的入度为0的顶点入队出队，直到队列为空(所有顶点均已入队又出队)，算法结束。若在某个节点找不到入度为0的顶点，则说明该图有圈。

#### 算法过程

1. 设置一个队列q和一个用于保存拓扑排序的列表res。
2. 遍历所有顶点，将入度为0的顶点入队后跳出遍历(无圈连通图有且只有一个顶点入度为0)。
3. 用一个while检查当前队列是否为空，不空则队首顶点v出队放入输出列表res中。
4. 将v的邻接顶点的入度减1，并检查减1后是否为0，为0则入队。
5. 当退出while时，输出列表中res出队的顶点顺序即为拓扑排序。

#### 时空复杂度

时间复杂度：队列中每个顶点均入队一次，出队一次O(|V|)，在更新并检查邻接顶点的for中，更新和检查的总次数等于边数O(|E|)，故总的时间复杂度为O(|E|+|V|)。

空间复杂度：取决于队列长度，不大于|V|，O(|V|)。

#### 代码

```java
public List<E> topoSort() {
    List<E> res = new ArrayList<>();
    Queue<Vertex<E>> q = new LinkedList<>();
    int counter = 0;

    // 遍历顶点，将入度为0的顶点入队
    for (Vertex<E> v : vertices) {
        if(v.getIndegree() == 0) {
            q.add(v);
            // 如果图是连通的初始时有且只有一个入度为0的顶点
            break;
        }
    }
    // 若队列不空，队首顶点v出队，输出到res，counter加1(用于设置拓扑排序序号和后续判断是否有圈)，
    // 设置v的拓扑排序序号，接着将v的邻接顶点w的入度减1，同时检w的入度是否变为0，是则入队
    while(!q.isEmpty()) {
        Vertex<E> v = q.remove();
        res.add(v.getName());
        counter++;
        v.setTopoNum(counter);
        for (Vertex<E> w : getAdjList(v)) {
            w.setIndegree(w.getIndegree() - 1);
            if(w.getIndegree() == 0) {
                q.add(w);
            }
        }
    }
    // 若while后counter不等于顶点数，则说明该有向图有圈
    if(counter != vertices.size()) {
        System.err.println("Cycle found!");
    }

    return res;
}
```



## 最短路径算法

**单源最短路径问题：**

给定一个赋权图G和一个特定顶点s，找出从s到G中每一个其他顶点的最短赋权路径。当图中有负值圈时，该图无最短赋权路径。若G为无权图，可看作边的权均为1的赋权图。

本节讨论并实现如下情形：

单源：

1. 无权图最短路径
2. 无负边赋权图最短路径 (Dijkstra)
3. 有负边赋权图最短路径 (Bellman-Ford, SPFA)
4. 无圈赋权图最短路径 (Kahn + Dijkstra)

多源间：

5. 所有点对最短路径 (Flyod-Warshall)

### 无权最短路径

#### 不使用队列的朴素算法

##### 算法描述

从源点s开始，以广度优先搜索(或者说层序遍历)的方式确定s到其他所有顶点的最短路径。对于s，距离(顶点到源点的距离，下同)为0，其邻接顶点的距离+1。置这些邻接顶点的距离为已确定，并将其前驱顶点置为s。接着对距离为1的顶点v考察它们的距离未确定的邻接顶点w，使w的距离+1，并将w的前驱顶点置为v。以for循环重复上述过程，循环开始时currentDist = 0，循环次数为顶点个数减1，每次执行后currentDist+1，表示距离不断递增，且距离最大不超过|V|-1(当图为链状时最大距离为|V|-1)。

##### 算法过程

1. 设置一个用于输出出队顶点顺序的结果列表res(不是必要的)，给定一个起始顶点(源点)s，置其距离(到源点s的距离)为0。
2. for循环按距离递增(广度优先搜索或者说层序遍历的做方式)。令currentDist=0，以顶点个数减1为遍历次数，每次currentDist加1，表示距离以1为单位不断递增，最大不超过|V|-1。
3. for循环遍历所有顶点，找到距离未确定且为currentDist的顶点v(下一层顶点)，然后置v的距离为已确定，将v输出到结果列表中。
4. for循环遍历v的邻接顶点w，置w的距离为currentDist+1，置w的前驱为v。
5. 最外层for循环结束后所有顶点距离都会确定，算法结束。

##### 时空复杂度

时间复杂度：两层for均为O(|V|)，故为O(|V|^2)。

空间复杂度：不考虑用于返回的顶点列表时(对于寻找最短路径并不是必要的)时为O(1)。

##### 代码

```java
public List<Vertex<E>> shortestPathUnweightedBasic(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>();
    s.setDistance(0);

    for (int currentDist = 0; currentDist < vertices.size() - 1; currentDist++) {
        for (Vertex<E> v : vertices) {
            if(!v.isKnown() && v.getDistance() == currentDist) {
                v.setKnown(true);
                res.add(v);
                for (Vertex<E> w : getAdjList(v)) {
                    if(w.getDistance() == Integer.MAX_VALUE) {
                        w.setDistance(currentDist + 1);
                        w.setPre(v);
                    }
                }
            }
        }
    }
    return res;
} 
```

#### 使用队列的改进算法

##### 算法描述

上述不使用队列的算法的一个明显的缺点是，尽管程序运行到后期时大部分顶点的距离均已确定，但距离每+1后仍要遍历所有顶点来寻找距离未确定的下一层顶点，可以使用队列改进这一算法。开始时令源点s距离为0，置其距离为已知并入队，然后以一个while循环使顶点出队，对于每次出队的顶点v，考察其邻接顶点w，若w距离未知，使其距离为v的距离+1，然后置w的距离为已知，置w前驱为v，w入队。while循环结束时算法完成，通过顶点前驱信息可以得到该顶点到源点间的最短路径。

##### 算法过程

1. 设置一个用于输出出队顶点顺序的结果列表res(不是必要的)，设置一个队列q，给定一个起始顶点(源点)s，置s的距离(到源点s的距离)为0，置s的距离为已知，将s加入到队列中。
2. while循环判断q是否为空，不空则队首顶点v出队，输出到结果列表res中。
3. for循环遍历v的邻接顶点w，判断w距离是否已知，若未知则w的距离等于v的距离+1，置w的距离为已知，置w的前驱为v，w入队。
4. 最外层while循环结束后所有顶点距离都会确定，算法结束。

##### 时空复杂度

时间复杂度：与拓扑排序时间复杂度分析类似。每个顶点均入队一次出队一次，O(|V|)，遍历邻接顶点的for，总共遍历的次数为边的总数，O(|E|)，总的时间复杂度为O(|E|+|V|)。

空间复杂度：不考虑用于返回的列表。取决于队列长度，O(|V|)。

##### 代码

```java
public List<Vertex<E>> shortestPathUnweightedQueue(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>();
    Queue<Vertex<E>> q = new LinkedList<>();
    s.setDistance(0); // 将起始顶点的距离设为0
    s.setKnown(true);
    q.add(s); // 起始顶点入队

    while(!q.isEmpty()) {
        Vertex<E> v = q.remove();
        res.add(v);
        // 每次顶点v出队，考察其邻接顶点的距离
        for (Vertex<E> w : getAdjList(v)) {
            // 用known字段来表示w的距离是否已更新，此处也可以用w.getDistance() == Integer.MAXVALUE，
            // 但要限制最大路径不能超过Integer.MAXVALUE，若使用该判断条件，
            // 则该方法内的s.setKnown(true);w.setKnown(true);语句可以去掉
            if(!w.isKnown()) { 
                w.setDistance(v.getDistance() + 1); // 将其距离置为v.getDistance() + 1
                w.setKnown(true);
                w.setPre(v); // 将v设置为w的其前驱顶点
                q.add(w); // w入队
            }
        }
    }

    return res;
}  
```



### 赋权最短路径 

#### 单源最短路径

##### Dijkstra算法朴素版

###### 算法描述

Dijkstra算法是一种基于广度优先搜索思想(或者说层序遍历思想)的贪婪算法。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvj8uhzs9nj60es08st9102.jpg" alt="image-20211018111446692" style="float:left;zoom:50%;" />



###### 算法过程

朴素版本过程如下：

1. 初始化。设置一个用于输出出队顶点顺序的结果列表res(不是必要的)。选定一个源点s，初始化所有顶点到源点s的距离为无穷大，表示该点到s的距离尚未确定，置s到其自身距离为0。

2. 以while循环寻找当前距离未确定顶点中距离最小者。在当前具有有效距离(即不为无穷大)的未确定距离的顶点中找到距离最小者v，置v的距离为已确定。

3. 松弛操作。更新上述顶点v的所有邻接顶点w到源点s的距离dw。有如下两种情况，因为在松弛前所有顶点的距离默认为无穷大，所以两种情形都是判断dv + d(v, w) < dw。

    3.1  如果是初次访问，w到s的距离dw有效化为dw = dv + d(v, w)。

    3.2. 当w不是初次访问，当满足dv + d(v, w) < dw时，更新dw为dv + d(v, w)。

4. 当所有顶点距离都确定时算法结束，每个顶点v到源点的最短距离都是dv。

**补充说明：**

1) 第2步是该算法贪婪的体现，即每次while都确定一个顶点的最短路径，while结束即求得所有顶点的最短路径。
2) 第3步是BFS思想的体现。每次while确定一个顶点v后，调整其邻接顶点的距离，即一次处理一层。
3) 针对第2步在当前距离未确定顶点中寻找距离最小值，可以采用优先队列(小顶堆)进行改进，具体实现见后续。
4) 本实现对有负值边的图无效，原因见后续。



###### 正确性证明

利用数学归纳法(结合反证法)证明，以下是证明全过程[^1]。

a) 首先回顾数学归纳法的证明过程。

1. 起始验证。对于命题P(n)，当n = 1时命题P成立。
2. 假设命题成立。假设命题P(n)在n = m (m > 1, m ∈ N)时成立。
3. 递推证明。根据2的假设，若能证明n = m + 1时命题P成立，则命题得证。

例如，有命题P：1+2+3...+n = n*(n+1)/2，按照数学归纳法证明如下：

1. 起始验证。当n等于1时，1 = 1*(1+1)/2，命题成立。

2. 假设命题成立。假设命题等于m时成立，1+2+3+...+m = m*(m+1)/2。

3. 递推证明。根据2的假设，如果能证明n = m+1时命题正确，则命题P正确。

   证明：在2所示式子左右两边加上m+1，得到 1+2+3+...+m+(m+1) = m*(m+1)/2 + (m+1)

   等号右边可以写成(m+1)*(m+2)/2，显然该形式就是将n = m+1代入原命题P的形式，证毕。

b) 利用数学归纳法证明如下命题P。

Dijkstra算法第n次进入while，会将第n个顶点加入距离已确定顶点集合A中，此时命题P宣称对于顶点∀v ∈ A(共n个)，总有d(v) = δ(v)。

※ d(v)表示由Dijkstra算法得到的最短距离估计，对于源点s，在程序开始时赋予d(s) = 0，对于其他顶点，由松弛操作得到。δ(v)表示实际的源点到v的最短距离。

1. 起始验证。当n等于1时，A集合中只有源点s自身，d(s) = 0 (程序开始时赋值得到)，且知道δ(v) = 0，故n=1时命题正确。

2. 假设命题成立。假设命题P在n等于m时，P(m)成立，即算法经过m次while，得到具有m个顶点的集合A，对于顶点∀v ∈ A(共m个)，总有d(v) = δ(v)。

3. P(m+1)递推证明。根据2的假设，如果能证明第m+1个顶点u被放入集合A时有 d(u) = δ(u)正确，则命题P正确。

   证明：|A| = m时，在集合B (B = S - A) 中根据算法规则找到距离最短的顶点u，将该顶点将作为第m+1个顶点放入A中，放入后|A| = m + 1，证明 d(u) = δ(u)，使得P(m+1)成立，即对于顶点∀v ∈ A(共m+1个)，有d(v) = δ(v)。

   以反证法证明之。

   3.1 假设m+1时d(u) = δ(u)不成立，即有如下式(1)， 之后的目标是根据已知条件导出某种矛盾情形，推翻该假设。

   δ(u) < d(u)       式 (1) 

   ※ δ(u)是实际的u到源点的最短距离，d(u) = δ(u)不成立时只能是δ(u) < d(u)。

   3.2 根据3.1的假设，存在一条从源点s到u的路径Pu，该路径是s到u的最短路径，即 len(Pu) = δ(u)  < d(u)。路径Pu一定有不在A集内的顶点(至少有u不在A集中)，同时也有在A集中的点(至少有s点在A集中)，可以假设Pu经过x和y，其中x在A中(可以是s)，y在B中(可以是u本身)，y到u的过程中也可以再进入A，如下图。Px为Pu在顶点x结束的子路径，因为路径Px加边(x, y)为路径Pu的一部分，所以有：

   len(Px) + len(x, y) ≤ len(Pu) = δ(u)       式(2)

   这是显然的，因为len(Px) + len(x, y)是len(Pu)的一部分，当y=u时取到等号。

   <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvlx6lkq0wj60nw0f6mxj02.jpg" style="float:left;zoom:33%;" />

   3.3 在x被选中进入A集内时，对其邻接顶点y执行过松弛操作，该操作比较d(x) + len(x, y)是否小于d(y)，若小于则以d(x) + len(x, y)更新d(y)的值，所以如果更新了，更新之后有d(y) = d(x) + len(x, y) ，如果没更新，说明d(y) < d(x) + len(x, y)。假设之后y还会被y的其他前驱顶点更新d(y)值(当该前驱顶点进入A集时)，那d(y)只会变得更小，所以一定有：

   d(y) ≤ d(x) + len(x, y)        式(3)

   比较式(2)和式(3)中的len(Px)和d(x)，因为d(x) = δ(x) (由步骤2的P(m)假设给出，顶点x是P(m)假设的m个顶点之一)，而Px只是若干从s到x的路径之一，必有d(x) ≤ len(Px)，当Px就是s到x的最短路径时取到等号。所以根据(2)和式(3)有：

   d(y) ≤ d(x) + len(x, y) ≤ len(Px) + len(x, y) ≤ len(Pu)，即 

   d(y) ≤ len(Pu) = δ(u)       式(4)

   3.4 顶点y与u均在B集中，根据算法规则，u之所以是第m+1个被放入A集中的顶点，是因为第m+1次进入while时，u在B集中相比于B集中的其他顶点(自然也包括y)，到源点s的距离最小，显然有：
   
   d(u) ≤ d(y)        式(5)
   
   结合式(1)，式(4)，式(5)得到：
   
   δ(u) < d(u) ≤ d(y) ≤ len(Pu) = δ(u) ，即 δ(u) < δ(u)，至此，由3.1的假设“d(u) = δ(u)不成立”导出了矛盾，所以d(u) = δ(u)成立的，反证结束。

至此，对Dijkstra算法正确性的归纳证明结束。



###### 时空复杂度

时间复杂度：O(|E|+|V|^2)，由于|E| < |V|^2，也可写为O(|V|^2)。

1. 寻找拥有到源点最小距离的顶点的时间为O(|V|^2)。 先遍历一遍顶点确认存在距离未确定的顶点O(|V|)，再遍历一遍顶点寻找未确定距离的顶点中距离最短者O(|V|)。

2. 所有顶点的距离被更新的次数上限为O(|E|)。顶点w的距离dw被更新的次数与w的入边有关，无论是对dw的初始化还是更新，都是由其前驱(入边)来决定的，所有顶点的入边数等于总边数，故为O(|E|)。

空间复杂度：不考虑用于返回的顶点列表时为O(1)。



###### 代码

```java
public List<Vertex<E>> shortestPathDijkstraBasic(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>(); 
    s.setDistance(0);

    // 遍历所有顶点确认是否有距离未确定的顶点，O(|V|)
    while(checkUnknown(vertices)) { 
        // 从所有顶点中取出距离unknown的顶点中的距离最小者v，O(|V|)
        Vertex<E> v = getUnknownMin(vertices);
        v.setKnown(true); // 置v的距离已确定
        res.add(v); // 按顺序输出已确定距离的顶点
        // 松弛v的邻接顶点w，本方法总共O(|E|)
        for (Vertex<E> w : getAdjList(v)) {
            // 松弛对象是未确定距离的邻接顶点w，本程序赋权图以邻接矩阵方式存储顶点的邻接顶点信息，
            // 故以边权是否为0判断是否为邻边
            if(!w.isKnown() && getEdgeValue(v, w) != 0) { 
                int dw = v.getDistance() + getEdgeValue(v, w);
                if(dw < w.getDistance()) { // 松弛条件
                    w.setDistance(dw); // 更新dw
                    w.setPre(v); // 置w前驱为v
                }
            }
        }
    }

    return res;
}

/**
 * 检查顶点列表中是否存在unknown顶点，O(|V|)
 */
private boolean checkUnknown(List<Vertex<E>> vertices) {
    for (Vertex<E> v : vertices) {
        if(!v.isKnown()) {
            return true;
        }
    }
    return false;
}

/**
 * 返回顶点列表中unknown且到源点距离最小的顶点，O(|V|)
 */
private Vertex<E> getUnknownMin(List<Vertex<E>> list){
    Vertex<E> min = new Vertex<>();
    // 先将初始min的距离设置为无穷大
    min.setDistance(Integer.MAX_VALUE); 
    for (int i = 0; i < vertices.size(); i++) {
        Vertex<E> cur = vertices.get(i);
        // 在unknown顶点中找到具有有效距离的最小者，顶点距离初识为无距离(Integer.MAX_VALUE)
        if(!cur.isKnown() && cur.getDistance() < min.getDistance()) {
            min = cur;
        }
    }
    return min;
}
```



##### Dijkstra算法优先队列版

###### 算法描述

针对Dijkstra算法朴素版第2步在当前距离未确定顶点中寻找距离最小者，可以采用优先队列(小顶堆)进行改进，其他过程与朴素版一致。



###### 算法过程



###### 时空复杂度

时间复杂度：O((|E|+|V|)log|V|)，即O(|E|log|V|)

1. 在当前距离未确定顶点中寻找距离最小者 O(|V|log|V|)。while中从pq判空耗时O(|V|)，获取距离最小者耗时O(log|V|)，故为O(|V|log|V|)。

   ※ 优先队列判空操作isEmpty()本身是常数时间操作，但总共要执行|V|次。

2. 所有顶点的距离被更新的次数上限为O(|E|)。顶点w的距离dw被更新的次数与w的入边有关，无论是对dw的初始化还是更新，都是由其前驱(入边)来决定的，所有顶点的入边数等于总边数，故为O(|E|)。dw更新时w入堆，插入操作的时间复杂度为O(log|E|)，入堆次数与更新次数相同，dw更新与w入堆的时间复杂度为O(|E|log|E|)，由于|E| <= |V|^2，故log|E| <= 2log|V|，于是dw更新与w入堆的时间复杂度为O(|E|log|V|)。

   ※ 注意，由上述分析，堆的大小上限不再是|V|而是|E|，所以dw更新时w入堆的插入操作的时间复杂度为O(log|E|)，由于边数与顶点数的关系，其时间复杂度为O(log|V|)。

空间复杂度：不考虑用于返回的顶点列表时为O(1)。



###### 代码

```java
public List<Vertex<E>> shortestPathDijkstraPQ(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>(); 
    s.setDistance(0);
    // 泛型PriorityQueue的写法，重写compare方法，比较元素getDistance()方法的结果，小顶堆
    PriorityQueue<Vertex<E>> pq = new PriorityQueue<>(new Comparator<Vertex<E>>() {
        @Override
        public int compare(Vertex<E> v1, Vertex<E> v2) {
            return v1.getDistance() - v2.getDistance();
        }
    });
    pq.add(s);

    while(!pq.isEmpty()) { // 判空 O(|V|)
        // 从unknowns中取出距离最小的顶点， O(log|V|)
        Vertex<E> v = pq.remove();
        // 当顶点v被更新过多次(多次入堆)，则存在v多次出堆的情况，
        // 对于不是第一次出堆的情况(v.isKnown = true)，出堆后直接跳到下一次堆判空
        if(v.isKnown()) { 
            continue;
        }
        v.setKnown(true); // 置v的距离为已确定
        res.add(v); // 按顺序输出已确定距离的顶点
        // 松弛v的邻接顶点w，O(|E|log|E|)
        for (Vertex<E> w : getAdjList(v)) {
            if(!w.isKnown() && getEdgeValue(v, w) != 0) { // 松弛对象是距离未确定的w
                // 将dw初次赋有效值或dw有更新时的w加入到pq中，以保证算法过程第2步总是
                // 能够在所有“具有有效距离值但距离未确定”的顶点中寻找距离最小者。
                // 注意dw有更新的情况下队列中w顶点会有多个(dw不同)，因此插入次数上限与更新次数上限相同，为|E|。
                int dw = v.getDistance() + getEdgeValue(v, w);
                if(dw < w.getDistance()) { // 松弛条件
                    w.setDistance(dw); // 更新dw
                    w.setPre(v); // 置w的前驱为v
                    pq.add(w); // 插入堆中，注意一个顶点的dw可能更新多次，O(log|E|)
                }
            }
        }
    }

    return res;
}
```



##### Dijkstra算法无法处理负边图

如下图，顶点A是源点，从A开始执行算法，B.dist和C.dist被更新为1，2，在距离未确定的顶点B和C中B.dist更小，B无可松弛的边，接着B的距离设为已确定，B.dist = 1，但实际上从A到C再到B会得到一条更短的的路径(-1)。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvys7ulosej308w08mjrb.jpg" alt="image-20211031204826493" style="float:left;zoom:50%;" />



##### Dijkstra算法之无圈图情形 (可处理有负边情形)

###### 算法描述

连通的有向无圈图有且仅有一个入度为0的顶点(超过1个则不连通，0个则有圈)，以该顶点为源点s，从s开始以拓扑排序方式实现Dijkstra算法。

※ 与拓扑排序一样，每次入度为0的顶点v出队，由于已无入边，故该顶点距离dv不会再被更新，此时dv即已确定。显式的Dijkstra算法的关键操作为“在当前具有有效距离且距离未确定的顶点中寻找距离最小者，并置其距离为已确定”，目的是每一次循环确定一个顶点的最短路径(贪婪)，所以也可将本算法看作是免去了引号所描述的操作的Dijkstra算法，即无需寻找，顶点出队时其距离即被确定。

**该算法可应用于有负边的图。**对任意顶点而言，若到源点有更短路径，会一直更新至其入度为0。以下图为例，从A开始执行算法，A出队，B.dist和C.dist被更新为1和2，然后B，C入度减为1，0，C无入边，其距离不会再被更新，即最终C.dist = 1，C入队。接着C出队，B.dist被更新为-1，B的入度减为0，此时B无入边，其距离不会再被更新，即其距离被最终确定为B.dist = -1。可以看到B的距离在其入度减至0的过程中总有机会更新至最短。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvys7ulosej308w08mjrb.jpg" alt="image-20211031204826493" style="float:left;zoom:50%;" />



###### 算法过程

1. 设置一个用于保存拓扑排序的列表res(不是必要的)。设置一个队列q，置s的距离为0，s入队。
2. while中对q判空，若不空则队首顶点v出队，置其距离为已知，将v放入输出列表res中。
3. 遍历v的邻接顶点w，更新dw，置w的前驱为v。
4. 将v的邻接顶点w的入度减1，并检查减1后是否为0，为0则入队。
5. 当while结束时，输出列表中res出队的顶点顺序为拓扑排序，此时所有顶点前驱确定，源点s到其他顶点的最短路径确定。



###### 时空复杂度

时间复杂度：队列中每个顶点均入队一次，出队一次O(|V|)，在更新并检查邻接顶点的for中，更新和检查的总次数等于边数O(|E|)，故总的时间复杂度为O(|E|+|V|)。

空间复杂度：取决于队列长度，不大于|V|，O(|V|)。



###### 代码

```java
public List<Vertex<E>> shortestPathDijkstraDAG(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>();
    Queue<Vertex<E>> q = new LinkedList<>();
    s.setDistance(0);
    q.add(s);

    while(!q.isEmpty()) {
        Vertex<E> v = q.remove(); 
        v.setKnown(true);
        res.add(v);
        for (Vertex<E> w : getAdjList(v)) {
            if(getEdgeValue(v, w) != 0) { // 由于采用邻接矩阵方式存储，根据边权是否为0判断是否为真的邻接顶点
                int dw = v.getDistance() + getEdgeValue(v, w); // 顶点v的距离值+边(v,w)的权值
                if(dw < w.getDistance()) { // 若“v的距离+vw边权”小于w的距离，更新w的距离dw
                    w.setDistance(dw);
                    w.setPre(v);
                }
                w.setIndegree(w.getIndegree() - 1); // w的入度减1
                if(w.getIndegree() == 0) { // 考察w此时入度是否为0，为0则入队
                    q.add(w);
                }
            }
        }
    }

    return res;
}
```



##### Bellman-Ford算法

###### 算法描述

[Bellman-Ford Algorithm(贝尔曼-福特算法)](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm): 与Dijkstra算法的相同点是对边(或者说对顶点)不断执行松弛操作，以逐渐得到所有顶点到源点的最短距离。Dijkstra以贪婪的思路每次循环完成一个顶点最短路径的确定，而BF算法则对图的所有边(|E|条边)，简单地进行|V|-1次全量松弛操作，以此保证即使出现最坏情形，也能使每个顶点到源点的距离，都经过了所有可能的松弛操作而达到最短。这是一种思路简单但复杂度较高的做法，复杂度为O((|V|-1)|E|)，即O(|V||E|)。



###### 算法过程

1. 设置一个用于保存按顺序被松弛的顶点列表res(不是必要的)。置源点s的距离为0。
2. |V|-1次for循环，在该循环内执行对所有边的松弛操作。|V|-1次保证了最坏情形下程序的正确性，后述。
3. 进入for后按顶点顺序依次对所有顶点v考察其所有邻接顶点w，是否有v.dist + d(v, w) < w.dist，若有，则松弛之，即令w.dist更新为v.dist + d(v, w)。
4. 在对所有边进行松弛的循环操作中，若某一次没有任何边被松弛，则退出第2步的循环，表明所有可能的松弛已完成(负圈图除外)。
5. 检查图是否有负圈。做法是再对所有边执行松弛操作，若有边可被松弛，则有负圈，结束程序，否则循环一遍后程序正常结束，所有顶点最短路径被求出。

**该算法可应用于有负边的图。**由于该算法在|V|-1次对所有边的松弛操作中会穷尽所有边被松弛的可能，在这一点上类似于以拓扑排序方式针对DAG图的Dijkstra算法(通过入度为0保证穷尽所有松弛的可能)，也适用于有负边的图。

**最坏情形。**当图为链状且每次松弛均从底端开始时达到最坏情形，需要对所有边执行|V|-1次松弛后才能求得所有顶点的最短路径。如下图：

假定每次循环均以E,D,C,B,A的顺序松弛，程序开始时置源点A的距离为0。

- 第1次循环只有B的距离被松弛为1

- 第2次循环C的距离被松弛为3

- 第3次循环D的距离被松弛为6

- 第4次循环E的距离被松弛为10

每次循环都对所有边尝试松弛，但每次只有一个顶点的距离被更新，经过|V|-1次即4次循环后才完成。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gx6ozzaf58j30g002qweh.jpg" alt="image-20211208202156220" style="float:left;zoom:50%;" />



###### 时空复杂度

时间复杂度：由上述分析可知为O(|V||E|)。

空间复杂度：不考虑用于返回的顶点列表时(对于寻找最短路径并不是必要的)时为O(1)。



###### 代码

```java
public List<Vertex<E>> shortestPathBF(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>();
    s.setDistance(0);

    for (int i = 0; i < vertices.size(); i++) {
        // 若某一次全量松弛没有边被松弛，则提前结束
        boolean finished = true;
        // 由于本程序未实现Edge类，用如下两个for实现对顶点v，松弛其所有边
        for (Vertex<E> v : vertices) {
            for(Vertex<E> w : getAdjList(v)) {
                if(getEdgeValue(v, w) != 0) {
                    // 当v的距离尚未被有效化时，dw会大于Integer.MAX_VALUE，所以要此处以long类型处理
                    long dw = (long)v.getDistance() + (long)getEdgeValue(v, w); 
                    if(dw < w.getDistance()) {
                        w.setDistance((int)dw);
                        w.setPre(v);
                        res.add(w); // 这里res表示对于被松弛的顶点，按被松弛的顺序放入，一个顶点可以被多次松弛
                        finished = false; // 若本次全量松弛过程中有边被松弛，标记为false表示未完成
                    }
                }
            }
        }
        if(finished) { // 若未true，表示某一次全量松弛没有边被松弛，提前结束
            break;
        }
    }
    // 负圈检测，再次对所有边执行松弛操作，若有边被松弛，说明存在负圈
    for (Vertex<E> v : vertices) {
        for(Vertex<E> w : getAdjList(v)) {
            if(getEdgeValue(v, w) != 0) {
                int dw = v.getDistance() + getEdgeValue(v, w);
                if(dw < w.getDistance()) {
                    System.err.println("存在负圈！");
                    return res;
                }
            }
        }
    }

    return res;
}
```



##### SPFA

###### 算法描述

BF算法通过对所有边执行|V|-1次松弛操作，保证了所有顶点的距离都能更新到最短。这一做法的本质是确保所有顶点的所有入边都尝试过松弛操作，如果能够以更高的效率实现这一点，即可改进BF算法。实际上除源点外(源点的距离直接给出，为0)，一个顶点w的距离能够被更新，隐含着这样一个信息，即w的前驱v的距离被更新过。因为dv + d(v, w)小于dw时才会更新dw，而d(v, w)是不变的，初始时dv和dw都是无穷大，所以只有dv更新(变小)，dw才会更新(变小)，有点链式反应的味道，从源点出发指向其邻接顶点，对一个连通的有向图，总能遍历所有顶点。于是可以设置一个队列q，程序开始时置源点s的距离为0，s入队。然后对q判空，不空时队首顶点v出队，松弛其边(即更新v的邻接顶点w的距离)，根据上述分析，如果dw有更新，那它的邻接顶点将有机会被更新，所以将w入队，等待出队时尝试松弛其边。重复这一过程，最后当q为空时表示所有被更新过距离的顶点，都无法再触发其邻接顶点距离的更新，也即所有顶点入边带来的所有可能的对该顶点距离的更新确实已被穷尽，程序结束，得到所有顶点到源点的最短路径。



###### 算法过程

1. 设置一个保存按顺序出队的顶点的列表(不是必要的)，设置一个队列q，置源点s的距离为0，s入队。
2. 以while循环对q判空，若q不空，队首顶点v出队，将v加入结果列表中。
3. 遍历v的邻接顶点w，若满足松弛条件，则更新w的距离，置w的前驱为v，将w入队。



###### 时空复杂度



###### 代码

```java
public List<Vertex<E>> shortestPathSPFA(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>();
    s.setDistance(0);
    Queue<Vertex<E>> q = new LinkedList<>();
    q.add(s);

    while(!q.isEmpty()) {
        Vertex<E> v = q.remove(); 
        res.add(v);
        for (Vertex<E> w : getAdjList(v)) {
            if(getEdgeValue(v, w) != 0) { // 只对v的邻边操作
                int dw = v.getDistance() + getEdgeValue(v, w);
                if(dw < w.getDistance()) { // 若源点经过顶点v到顶点w的距离小于源点到w的距离，更新源点w的距离
                    w.setDistance(dw);
                    w.setPre(v);
                    q.add(w); // 当w有松弛操作时将w加入队列
                }
            }
        }
    }
    // 负圈检测。
    // 由于本程序未实现Edge类，用如下两个for实现对顶点v，松弛所有边，若有边被松弛，说明存在负圈
    for (Vertex<E> v : vertices) {
        for(Vertex<E> w : getAdjList(v)) {
            if(getEdgeValue(v, w) != 0) {
                int dw = v.getDistance() + getEdgeValue(v, w);
                if(dw < w.getDistance()) {
                    System.err.println("存在负圈！");
                    return res;
                }
            }
        }
    }

    return res;
}
```



#### 所有点对最短路径 

##### Floyd-Warshall算法

[Floyd算法(Floyd-Warshall Algorithm)](https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm): 应用动态规划思想。

###### 算法描述



###### 时空复杂度



###### 代码



### 最短路径例子：词梯问题



## 网络流问题

### 最大流最小割定理(Max-flow min-cut theorem)

对于一个网络流(图)，从源点到目标点的最大的流量等于最小割的每一条边的和。

流

割和割的大小

无权有向图两点间不相交路径数量问题

添加反向增广路不影响结果的证明

下界和上界

推广至有权图

最大流最小割定理

### Ford-Fulkerson方法

[福特-富尔克森方法](https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm)1956年由L. R. Ford Jr和D. R. Fulkerson发表的用于求有向图最大流的算法。因为该算法未完全明确指定求增广路径的方法，所以通常也将其称作福特-福尔克森方法。若增广路径以BFS方式求出，则为Edmonds-Karp算法。

#### 算法描述

给定一张边的容量为c的图G(V, E)，源点s和汇点t。求G中从s到t的最大流f。

1. 设置一张流量图Gf和一张残余图Gr，初始化Gf为边权均为0的图G，Gr为G。
2. 考察Gr中是否有从s到t的路径p，使得p上的每一条边(u,v) ∈ p，都有cr(u, v) > 0。p称作增广路径(Augmenting Path)。若存在p，则：
   2.1 将p中最小边的权加到Gf中相同位置的每条边上。
   2.2 在Gr中p的每条边减去该最小边的权。
   2.3 在Gr中p的反向路径上的每条边上加上该最小边权。
3. 在Gr中反复寻找增广路径p并执行2中的操作直到Gr中找不到p，算法停止。
4. 在Gr中定义S为s可以达到的点的集合，T是剩余点的集合，在G中，S到T的割的大小即为所求的最大流。

#### 坏情形

**增广路径选取的坏情形：**

如下图，寻找从A到B的增广路径时，若总是选取A>B>C>D，由于小权边限制了流的大小，需经历1000次选取才能结束算法，而选取A>B>D，A>C>D则只需要两次，有两种做法能够有效解决。

做法1: 总是选取流最大的增广路径。显然能够避免小权边引起的多次增广路选取。利用Dijkstra算法，将顶点距离的更新策略从选取较小值改为选取较大值，即可实现该做法。

做法2: 总是选取最短的增广路径。较短的增广路降低了路径上出现小权边的概率。该做法显然可以用无权最短路径实现。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvev606qcyj60ey0a0mxg02.jpg" style="float:left;zoom:50%;" />

**边权值的坏情形：**



#### 时空复杂度

时间复杂度：设最大流为f，算法过程为穷尽增广路径的过程，以无权最短路径算法(即上述做法2，总是选取最短的增广路径)寻找一条s到t的增广路径需O(E) (O(E+V)可表成O(E)) 时间，而每找到一条增广路径，至少增加1个单位的流量，故总的时间复杂度为O(E*f)。

空间复杂度：取决于求最短路径时用到的队列的长度，O(|V|)。

### Edmonds-Karp算法

[埃德蒙兹-卡普算法]()



### Dinic算法

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvfw5jat8ij608a0aiaa502.jpg" style="float:left;zoom:50%;" />

朴素Dinic算法中，在当前分层图下，每次主程序(对singleAugPathDFS来说的主程序是multipleAugPathDFS)主调用DFS(singleAugPathDFS)找到一条增广路后，会一直return到本次主调用结束。然后主程序基于`(singleAugFlow = singleAugPathDFS(des, current, singleAugFlow)) != 0`的判断再次调用DFS，又一次从src顶点开始搜索下一条到des的增广路。以上图为例，增广过程如下：

第一次主调：s>a>c>t, 找到增广路后return，得到minEdge，且minEdge > 0，修改正向和反向边权后return，t>c>a>s然后退出主调用，本次主调结束，得到本次增广路发送流为2。整体的顶点访问顺序为s>a>c>t>c>a>s。

第二次主调：s>a>c，发现(c, t)边权为0，不满足isAdjacent(current, w)条件，找a的下一个满足层号关系的邻接顶点d，然后d>t，同上，找到增广路后在return过程中修改正反向边权，t>d>a>s后退出主调用，本次主调结束，得到本次增广路发送流为1。整体的顶点访问顺序为s>a>c>d>t>d>a>s。

第三次主调：从s开始，发现(s, a)边权为0，不满足isAdjacent(current, w)条件，找s的下一个满足层号关系的邻接顶点b，然后b>d>t，同上，找到增广路后在return过程中修改正反向边权，t>d>b>s后退出主调用，本次调用结束，得到本次增广路发送流为2。整体的顶点访问顺序为s>b>d>t>d>b>s。

第四次主调：从s开始，for循环遍历所有邻接顶点均不满足isAdjacent(current, w)条件，返回0 (`return 0;`)，于是主调方法的while也结束，得到最终结果maxFlow = 5.

注意：对DFS的主调用这个描述是为了区别于DFS的递归调用。

#### 优化1: 一次DFS主调用实现多路增广

通过上述对程序运行过程的分析，可以看到每次对DFS的主调，得到增广路后不断回退到主调结束，然后再利用下一次主调寻找下一条增广路。如果在找到增广路后不是一路回退，而是在回退到上一个节点后继续探索其下一个满足条件的邻接顶点，那么可以期待一次主调就能完成当前分层图下所有增广路的寻找，得到当前分层图下源点可发送的最大流multipleAugFlow。做法如下：

1. 为每一个顶点维护一个可用流数据(flow)，源点可用流设置为Integer.MAX_VALUE。
2. 在分层图中利用DFS搜索增广路的过程中，更新当前顶点u的flow值。假设u的前驱顶点为v，则u.flow = min(v.flow, edgeValue(v, u))。
3. 找到增广路时会得到本条增广路的最小边权singleAugFlow。注意，基础版本在BFS增广过程维护一个增广路上的最小边权，增广完成后以其为本次增广的发送流，在优化1中，增广完成时，本次增广的发送流singleAugFlow是当前汇点的可用流，即`singleAugFlow = des.flow`。在2中已经知道，每一个顶点的可用流都是在以它为当前顶点时更新或赋予的。
4. 得到singleAugFlow后回退，与基础版本算法一样，每回退到当前顶点v(假设其后继顶点为u)，将正向边(v, u)边权减去singleAugFlow，将反向边(u, v)边权加上singleAugFlow。同时，在优化1版本中会令u的可用流减去singleAugFlow，即u.flow -= singleAugFlow (这一点是实现优化的关键！)。接着不是继续回退，而是考察u的下一个满足条件的邻接顶点，假设存在，为顶点w。同样，先求w的可用流w.flow = min(u.flow, edgeValue(u, w))。可以看到顶点u在寻找经过它的下一条增广路时，携带了其可发送的流大小的信息(u.flow)，继续向汇点更新新增广路上的顶点的可用流时，都会受到当前u.flow的限制，即如果存在新的从u到汇点的增广路，汇点des的可用流最多为u.flow(当u.flow相比于该路径上所有边权最小时)，由于最终`singleAugFlow = des.flow`，所以新的增广路可发送流最多也只能够是singleAugFlow = u.flow。本次增广后从汇点des回退到u，回退过程同前述，对每个回退到的顶点(k)执行k.flow -= singleAugFlow，调整路径上每条边的正反向边权，最终再次回到u，u再次减去本次singleAugFlow。当当前顶点的可用流为0，即u.flow = 0时，无需再考察从u到它的其他邻接顶点的新的增广路的可能性，直接break跳出。
5. 当源点src遍历完所有邻接顶点时，当前分层图的所有增广路被找到，返回src的多路增广可发送流大小。

#### 优化2: 当前弧优化

朴素Dinic算法中，假设源点src有多个邻接顶点A，B，C，D....。每次DFS都会从源点第一个邻接顶点A开始尝试增广，假设经过A有两条增广路。那么两次主调用DFS后，经过A的两条增广路都被找到，接着第3次主调用DFS，从A开始尝试增广，显然已无法经过A增广，于是尝试B，假设经过B有一条增广路，于是第3次主调用DFS的结果是找到经过B的一条增广路。接着第4次主调用DFS，此时仍然会从A开始尝试，这时我们已经可以发现，尽管经过A的增广路早已被穷尽，但每次对DFS的新的主调用，还是会从源点的第一个邻接顶点A开始尝试增广，这显然是无谓的开销。每次主调DFS时，不是从源点的第一个邻接顶点开始，而是从上一次主调所处理的那个源点的邻接顶点开始，就可以避免上述无谓的开销。如前述，经过3次对DFS的主调用，已经完成了经过A，B共3条增广路的寻找，在第4次主调用DFS时，不是从A开始，而是从B开始(注意不是C)尝试，已无经过B的增广路，于是寻找下一个邻接顶点C，执行经过C的增广路的寻找。下一次对DFS的主调用，从C开始(注意不是D)。这就是“当前弧优化”。

注意：当前弧优化是针对朴素Dinic算法来说的，如果已经实现了优化1，在当前分层图下，对DFS只需执行一次主调用，也就不存在当前弧优化所解决的问题。

### 最小费用流问题

## 最小生成树



### Prim算法



### Kruskal算法



## 深度优先搜索的应用



### 无向图



#### 判断无向图的连通性



#### 寻找无向图中的割点



#### 解决欧拉回路问题



### 有向图



#### 判断有向图是否无圈



#### 判断有向图是否强连通

[^1]: https://www.zhihu.com/question/57206374 为什么Dijkstra算法每轮递推能够保证找到一个顶点的最短路径？