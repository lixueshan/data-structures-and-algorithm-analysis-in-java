# 第9章 - 图论算法

## 思维导图和算法总结



## 图的基本知识

### 基本概念汇总

| 概念                                     | 描述                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| 图 (graph)                               | 由顶点集合V和边集合E组成                                     |
| 边 (edge)                                | 一对点 (v, w), v, w ∈ V                                      |
| 有向图 (directed graph / digraph)        | 点对有序的图，(v, w)与(w, v)为两条不同的边                   |
| 无向图 (undirected graph)                | 点无序的图，(v, w)与(w, v)为同一条边                         |
| 邻接 (adjacent)                          | 顶点w与v邻接当且仅当 (v, w) ∈ E                              |
| 权 (weight) / 值 (cost)                  | 边的权重                                                     |
| 路径 (path)                              | 为一顶点序列 w1, w2, w3,...,wN使得(wi, w(i+1)) ∈ E, 1<=i<=N<br />一个顶点到他自身也可以看成是一条路径，如果路径不包含边，则路径长为0 |
| 路径的长 (path length)                   | 路径上边的数量                                               |
| 简单路径                                 | 路径上的所有顶点都是不同的，但第一个和最后一个可能可以相同   |
| 环 (loop)                                | 一个顶点到它自身的边 (v, v)，本章讨论的图一般都是无环的      |
| 圈 (cycle)                               | 满足w1 = wN的长至少为1的路径                                 |
| 有向无圈图 (directed acyclic graph, DAG) | 无圈的有向图                                                 |
| 连通图 (connected graph)                 | 从一顶点w到另一顶点v有路径相连称w与v连通，任意两顶点之间连通的图称为连通图。对于有向连通图，两点之间的路径上的边必须同向 |
| 强连通 (strongly connected)              | 称有向连通图是强连通的                                       |
| 基础图 (underlying graph)                | 有向图去掉边的方向后的图称为该有向图的基础图                 |
| 弱连通 (weakly connected)                | 有向图不是强连通的，但其基础图是连通的，则称该有向图是弱连通的 |
| 完全图 (complete graph)                  | 每一对顶点间都有边相连的图                                   |
| 邻接矩阵 (adjacent matrix)               | 对每条边(u, v)置矩阵的A[u, v]为true，无(u, v)边则为false，若边有权，则A[u, v]等于该值，以一个很大或很小的数表示该边不存在 |
| 邻接表 (adjacency list)                  | 以邻接矩阵表示图，当图较稀疏时空间代价为\|V\|^2，针对这种情况，对稀疏图可以采用邻接表来表示，对每一个顶点，以一个表存放其邻接顶点，则空间降为\|E\|+\|V\|，相对图的大小而言是线性的 |
| 拓扑排序 (topological sorting)           | 对有向无圈图的顶点的排序，使得若存在从w到v的路径，则v在排序中出现在w之后<br />显然当图含有圈时无法做到拓扑排序 |
| 入度 (indegree)                          | 对有向图顶点v而言，(u, v)边的数量                            |
| 出度 (outdegree)                         | 对有向图顶点v而言，(v, u)边的数量                            |
| 赋权路径长(weighted path length)         |                                                              |
| 无权路径长(unweighted path length)       |                                                              |
| 单源最短路径问题                         |                                                              |
| 无权最短路径                             |                                                              |
| 广度优先搜索                             |                                                              |
|                                          |                                                              |
|                                          |                                                              |



### 图数据结构示例



```java
```



## 拓扑排序

### Kahn算法

拓扑排序是对有向无圈图的一种排序，这种排序如果存在从顶点u到顶点v的路径，那v一定在u之后而不能从v走到u。所以拓扑排序存在要求有向图无圈。



#### 算法描述

[Kahn算法](https://en.wikipedia.org/wiki/Topological_sorting)：找出任意一个入度为0的顶点，放入队列中，从队列输出该顶点并将其邻边入度减1，同时检查这些邻边的入度，若算法未结束，则会出现新的入度为0的顶点，将其入队。于是不断有新的入度为0的顶点入队出队，直到队列为空(所有顶点均已入队又出队)，算法结束。若在某个节点找不到入度为0的顶点，则说明该图有圈。



#### 算法过程

1. 设置一个队列q和一个用于保存拓扑排序的列表res。
2. 遍历所有顶点，将入度为0的顶点入队后跳出遍历(有向无圈连通图有且只有一个顶点入度为0)。
3. 用一个while检查当前队列是否为空，不空则队首顶点v出队放入输出列表res中。
4. 将v的邻接顶点的入度减1，并检查减1后是否为0，为0则入队。
5. 当退出while时，输出列表中res出队的顶点顺序即为拓扑排序后的顺序。



#### 时空复杂度

时间复杂度：队列中每个顶点均入队一次，出队一次，O(|V|)。更新并检查邻接顶点的for中，更新和检查的总次数等于边数O(|E|)，故总的时间复杂度为O(|E|+|V|)。

空间复杂度：取决于队列长度，不大于|V|，O(|V|)。



#### 代码

```java
public List<E> topoSort() {
    List<E> res = new ArrayList<>();
    Queue<Vertex<E>> q = new LinkedList<>();
    int counter = 0;

    // 遍历顶点，将入度为0的顶点入队
    for (Vertex<E> v : vertices) {
        if(v.getIndegree() == 0) {
            q.add(v);
            // 如果图是连通的初始时有且只有一个入度为0的顶点
            break;
        }
    }
    // 若队列不空，队首顶点v出队，输出到res，counter加1(用于设置拓扑排序序号和后续判断是否有圈)，
    // 设置v的拓扑排序序号，接着将v的邻接顶点w的入度减1，并检查w的入度是否变为0，是则入队。
    while(!q.isEmpty()) {
        Vertex<E> v = q.remove();
        res.add(v.getName());
        counter++;
        v.setTopoNum(counter);
        for (Vertex<E> w : getAdjList(v)) {
            w.setIndegree(w.getIndegree() - 1);
            if(w.getIndegree() == 0) {
                q.add(w);
            }
        }
    }
    // 若while后counter不等于顶点数，则说明该有向图有圈
    // 由于有圈，执行到该圈入口顶点时找不到入度为0的顶点，while结束，因此counter会小于顶点数。
    if(counter != vertices.size()) {
        System.err.println("Cycle found!");
    }

    return res;
}
```



## 最短路径算法

**单源最短路径问题：**

给定一个赋权图G和一个顶点s，找出从s到G中每一个其他顶点的最短赋权路径。当图中有负值圈时，该图无最短赋权路径。若G为无权图，可看作边的权均为1的赋权图。

本节讨论并实现如下情形：

单源：

1. 无权图最短路径
2. 无负边赋权图最短路径 (Dijkstra)
3. 无圈赋权图最短路径 (Kahn + Dijkstra)
4. 有负边赋权图最短路径 (Bellman-Ford, SPFA)

多源间：

5. 所有点对最短路径 (Flyod-Warshall)



### 无权最短路径

#### 不使用队列的朴素算法

##### 算法描述

从源点s开始，以广度优先搜索(或者说层序遍历)的方式确定s到其他所有顶点的最短路径。对于s，距离(顶点到源点的距离，下同)为0，其邻接顶点的距离+1。置这些邻接顶点的距离为已确定，并将其前驱顶点置为s。接着对距离为1的顶点v考察它们的距离未确定的邻接顶点w，使w的距离+1，并将w的前驱顶点置为v。以for循环重复上述过程，循环开始时 currentDist = 0，循环次数为顶点个数减1，每次执行后 currentDist+1，表示距离不断递增，且距离最大不超过|V|-1 (当图为链状取到最大，为|V|-1)。



##### 算法过程

1. 设置一个用于输出出队顶点顺序的结果列表res(不是必要的)，给定一个源点s，置其距离(到源点s的距离)为0。
2. for循环按距离递增(广度优先搜索或者说层序遍历的方式)。令currentDist=0，以顶点个数减1为遍历次数，每次currentDist加1，表示距离以1为单位不断递增，最大不超过|V|-1。
3. for循环遍历所有顶点，找到距离未确定且为currentDist的顶点v(下一层顶点)，然后置v的距离为已确定，将v输出到结果列表中。
4. for循环遍历v的未确定距离的邻接顶点w，置w的距离为currentDist+1，置w的前驱为v。
5. 最外层for循环结束后所有顶点距离都会确定，算法结束。



##### 时空复杂度

时间复杂度：两层for均为O(|V|)，故为O(|V|^2)。

空间复杂度：不考虑用于返回的顶点列表时(对于寻找最短路径并不是必要的)时为O(1)。



##### 代码

```java
public List<Vertex<E>> shortestPathUnweightedBasic(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>();
    s.setDistance(0);

    for (int currentDist = 0; currentDist < vertices.size(); currentDist++) {
        for (Vertex<E> v : vertices) {
            if(!v.isKnown() && v.getDistance() == currentDist) {
                v.setKnown(true);
                res.add(v);
                for (Vertex<E> w : getAdjList(v)) {
                    // 已经取得距离的w一定是之前取得的，其距离已确定，所以要判断w是否为距离未更新的顶点。
                    if(w.getDistance() == Integer.MAX_VALUE) {
                        w.setDistance(currentDist + 1);
                        w.setPre(v);
                    }
                }
            }
        }

    }
    return res;
}  
```



#### 使用队列的改进算法

##### 算法描述

上述算法的一个明显的缺点是，尽管程序运行到后期时大部分顶点的距离均已确定，但距离每+1后仍要遍历所有顶点来寻找距离未确定的下一层顶点。可以使用队列改进这一算法。开始时令源点s距离为0，置其距离为已知并入队，然后以一个while循环使顶点出队，对于每次出队的顶点v，考察其邻接顶点w，若w距离未知，使其距离为v的距离+1，然后置w的距离为已知，置w前驱为v，w入队。while循环结束时算法完成，通过顶点前驱信息可以得到该顶点到源点间的最短路径。



##### 算法过程

1. 设置一个用于输出出队顶点顺序的结果列表res(不是必要的)，设置一个队列q，给定一个起始顶点(源点)s，置s的距离(到源点s的距离)为0，置s的距离为已知，将s加入到队列中。
2. while循环判断q是否为空，不空则队首顶点v出队，输出到结果列表res中。
3. for循环遍历v的邻接顶点w，判断w距离是否已知，若未知则w的距离等于v的距离+1，置w的距离为已知，置w的前驱为v，w入队。
4. 最外层while循环结束后所有顶点距离都会确定，算法结束。



##### 时空复杂度

时间复杂度：与拓扑排序时间复杂度分析类似，每个顶点均入队一次出队一次，O(|V|)。遍历邻接顶点的for，在程序整体运行过程中每个顶点都会遍历其邻接顶点，总遍历的次数为边的总数，O(|E|)，总的时间复杂度为O(|E|+|V|)。

空间复杂度：不考虑用于返回的列表。取决于队列长度，O(|V|)。



##### 代码

```java
public List<Vertex<E>> shortestPathUnweightedQueue(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>();
    Queue<Vertex<E>> q = new LinkedList<>();
    s.setDistance(0); // 将起始顶点的距离设为0
    s.setKnown(true);
    q.add(s); // 起始顶点入队

    while(!q.isEmpty()) {
        Vertex<E> v = q.remove();
        res.add(v);
        // 每次顶点v出队，考察其邻接顶点的距离
        for (Vertex<E> w : getAdjList(v)) {
            // 用known字段来表示w的距离是否已更新，此处也可以用w.getDistance() == Integer.MAXVALUE，
            // 但要限制最大路径不能超过Integer.MAXVALUE，若使用该判断条件，
            // 则该方法内的s.setKnown(true);w.setKnown(true);语句可以去掉
            if(!w.isKnown()) { 
                w.setDistance(v.getDistance() + 1); // 将其距离更新为v.getDistance() + 1
                w.setKnown(true);
                w.setPre(v); // 将v设置为w的其前驱顶点
                q.add(w); // w入队
            }
        }
    }

    return res;
}  
```



### 赋权最短路径 

#### 单源最短路径

##### Dijkstra算法朴素版

###### 算法描述

[Dijkstra算法](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)：一种基于广度优先搜索和贪婪思想(或者说层序遍历思想)的求解无负边单源最短路径的算法。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvj8uhzs9nj60es08st9102.jpg" alt="image-20211018111446692" style="float:left;zoom:50%;" />



###### 算法过程

朴素版本过程如下：

1. 初始化。设置一个用于输出出队顶点顺序的结果列表res(不是必要的)。选定一个源点s，初始化所有顶点到源点s的距离为无穷大，表示该点到s的距离尚未确定，置s到其自身距离为0。

2. 一次循环完成一个顶点最短路径的确定。以while循环寻找当前距离未确定顶点中距离最小者。在当前具有有效距离(即不为无穷大)的未确定距离的顶点中找到距离最小者v，置v的距离为已确定。

3. 松弛操作。更新上述顶点v的所有邻接顶点w到源点s的距离dw。有如下两种情况，因为在松弛前所有顶点的距离默认为无穷大，所以两种情形的形式一样，都是判断dv + d(v, w) < dw。

    3.1  如果是初次访问，w到s的距离dw有效化为dw = dv + d(v, w)。

    3.2. 当w不是初次访问，当满足dv + d(v, w) < dw时，更新dw为dv + d(v, w)。

4. 当所有顶点距离都确定时while循环结束，每个顶点v到源点的最短距离被求出。

**补充说明：**

1) 第2步是该算法贪婪的体现，即每次while都确定一个顶点的最短路径，while结束即求得所有顶点的最短路径。
2) 第3步是BFS思想的体现。每次while确定一个顶点v后，调整其邻接顶点的距离，即一次处理一层。
3) 针对第2步在当前距离未确定顶点中寻找距离最小值，可以采用优先队列(小顶堆)进行改进，具体实现见后续。
4) Dijkstra算法对有负值边的图无效，原因见后续。



###### 正确性证明

利用数学归纳法(结合反证法)证明，以下是证明全过程[^1]。

a) 首先回顾数学归纳法的证明过程。

1. 起始验证。对于命题P(n)，当n = 1时命题P成立。
2. 假设命题成立。假设命题P(n)在n = m (m > 1, m ∈ N)时成立。
3. 递推证明。根据2的假设，若能证明n = m + 1时命题P成立，则命题得证。

例如，有命题P：1+2+3...+n = n*(n+1)/2，按照数学归纳法证明如下：

1. 起始验证。当n等于1时，1 = 1*(1+1)/2，命题成立。

2. 假设命题成立。假设命题等于m时成立，1+2+3+...+m = m*(m+1)/2。

3. 递推证明。根据2的假设，如果能证明n = m+1时命题正确，则命题P正确。

   证明：在2所示式子左右两边加上m+1，得到 1+2+3+...+m+(m+1) = m*(m+1)/2 + (m+1)

   等号右边可以写成(m+1)*(m+2)/2，显然该形式就是将n = m+1代入原命题P的形式，证毕。

b) 利用数学归纳法证明如下命题。

命题P：Dijkstra算法第n次进入while时，会将第n个顶点加入距离已确定顶点集合A中，此时对于顶点∀v ∈ A(共n个)，总有d(v) = δ(v)。

※ d(v)表示由Dijkstra算法得到的最短距离估计，对于源点s，在程序开始时赋予d(s) = 0，对于其他顶点，由松弛操作得到。δ(v)表示实际的顶点v到源点的最短距离。

1. 起始验证。当n等于1时，A集合中只有源点s自身，d(s) = 0 (程序开始时赋值得到)，且知道δ(v) = 0，故n=1时命题正确。

2. 假设命题成立。假设命题P在n等于m时，P(m)成立，即算法经过m次while，得到具有m个顶点的集合A，对于顶点∀v ∈ A(共m个)，总有d(v) = δ(v)。

3. P(m+1)递推证明。根据2的假设，如果能证明第m+1个顶点u被放入集合A时有 d(u) = δ(u)，则命题P正确。

   证明：|A| = m时，在集合B (B = S - A) 中根据算法规则找到距离最短的顶点u，将该顶点将作为第m+1个顶点放入A中，放入后|A| = m + 1，如果能证明 d(u) = δ(u)，使得P(m+1)成立，则对于顶点∀v ∈ A(共m+1个)，有d(v) = δ(v)。

   以反证法证明之。

   3.1 假设m+1时d(u) = δ(u)不成立，即有如下式(1)， 之后的目标是根据已知条件导出某种矛盾情形，推翻该假设。

   δ(u) < d(u)       式 (1) 

   ※ δ(u)是实际的u到源点的最短距离，d(u) = δ(u)不成立时只能是δ(u) < d(u)。

   3.2 根据3.1的假设，存在一条从源点s到u的路径Pu，该路径是s到u的最短路径，即 len(Pu) = δ(u)  < d(u)。路径Pu一定有不在A集内的顶点(至少有u不在A集中)，同时也有在A集中的点(至少有s点在A集中)，可以假设Pu经过x和y，其中x在A中(可以是s)，y在B中(可以是u本身)，y到u的过程中也可以再进入A，如下图。Px为Pu在顶点x结束的子路径，因为路径Px加边(x, y)为路径Pu的一部分，所以有：

   len(Px) + len(x, y) ≤ len(Pu) = δ(u)       式(2)

   这是显然的，因为len(Px) + len(x, y)是len(Pu)的一部分，当y=u时取到等号。

   <img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvlx6lkq0wj60nw0f6mxj02.jpg" style="float:left;zoom:33%;" />

   3.3 在x被选中进入A集内时，对其邻接顶点y执行过松弛操作，该操作比较d(x) + len(x, y)是否小于d(y)，若小于则以d(x) + len(x, y)更新d(y)的值，所以如果更新了，更新之后有d(y) = d(x) + len(x, y) ，如果没更新，说明d(y) < d(x) + len(x, y)。假设之后y还会被y的其他前驱顶点更新d(y)值(当该前驱顶点进入A集时)，那d(y)只会变得更小，所以一定有：

   d(y) ≤ d(x) + len(x, y)        式(3)

   比较式(2)和式(3)中的len(Px)和d(x)，因为d(x) = δ(x) (由步骤2的P(m)假设给出，顶点x是P(m)假设的m个顶点之一)，而Px只是若干从s到x的路径之一，必有d(x) ≤ len(Px)，当Px就是s到x的最短路径时取到等号。所以根据式(2)和式(3)有：

   d(y) ≤ d(x) + len(x, y) ≤ len(Px) + len(x, y) ≤ len(Pu)，即 

   d(y) ≤ len(Pu) = δ(u)       式(4)

   3.4 顶点y与u均在B集中，根据算法规则，u之所以是第m+1个被放入A集中的顶点，是因为第m+1次进入while时，u在B集中相比于B集中的其他顶点(自然也包括y)，到源点s的距离最小，显然有：
   
   d(u) ≤ d(y)        式(5)
   
   结合式(1)，式(4)，式(5)得到：
   
   δ(u) < d(u) ≤ d(y) ≤ len(Pu) = δ(u) ，即 δ(u) < δ(u)，至此，由3.1的假设“d(u) = δ(u)不成立”导出了矛盾，所以d(u) = δ(u)是成立的，反证结束。

至此，对Dijkstra算法正确性得证。



###### 时空复杂度

时间复杂度：O(|E|+|V|^2)，由于|E| < |V|^2，也可写为O(|V|^2)。

1. 寻找拥有到源点最小距离的顶点的时间为O(|V|^2)。 先遍历一遍顶点确认存在距离未确定的顶点O(|V|)，再遍历一遍顶点寻找未确定距离的顶点中距离最短者O(|V|)。

2. 所有顶点的距离被更新(松弛)的次数上限为O(|E|)。由算法可知顶点距离的更新(或者说边的松弛)只发生在找到当前距离未确定且距离最小的顶点之后，一次更新的次数是该顶点的邻接顶点数(即出边数，出度)。每一次循环确定一个这样的顶点，也就是每一次循环松弛某一个顶点的所有出边。所有顶点的出边即总边数为|E|。故总松弛次数，也即所有顶点的距离被更新的次数上限为O(|E|)。

空间复杂度：不考虑用于返回的顶点列表时为O(1)。



###### 代码

```java
// 为了更清楚地分析时间复杂度，将检查未确定距离顶点的方法checkUnknown和
// 获取未确定距离顶点中最小者的方法getUnknownMin写在外部。

public List<Vertex<E>> shortestPathDijkstraBasic(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>(); 
    s.setDistance(0);

    // 遍历所有顶点确认是否有距离未确定的顶点，O(|V|)
    while(checkUnknown(vertices)) { 
        // 从所有顶点中取出距离unknown的顶点中的距离最小者v，O(|V|)
        Vertex<E> v = getUnknownMin(vertices);
        v.setKnown(true); // 置v的距离已确定
        res.add(v); // 按顺序输出已确定距离的顶点
        // 松弛v的邻接顶点w，本方法总共O(|E|)
        for (Vertex<E> w : getAdjList(v)) {
            // 松弛对象是未确定距离的邻接顶点w，本程序赋权图以邻接矩阵方式存储顶点的邻接顶点信息，
            // 故以边权是否为0判断是否为邻边
            if(!w.isKnown() && getEdgeValue(v, w) != 0) { 
                int dw = v.getDistance() + getEdgeValue(v, w);
                if(dw < w.getDistance()) { // 松弛条件
                    w.setDistance(dw); // 更新dw
                    w.setPre(v); // 置w前驱为v
                }
            }
        }
    }

    return res;
}

/**
 * 检查顶点列表中是否存在unknown顶点，O(|V|)
 */
private boolean checkUnknown(List<Vertex<E>> vertices) {
    for (Vertex<E> v : vertices) {
        if(!v.isKnown()) {
            return true;
        }
    }
    return false;
}

/**
 * 返回顶点列表中unknown且到源点距离最小的顶点，O(|V|)
 */
private Vertex<E> getUnknownMin(List<Vertex<E>> list){
    Vertex<E> min = new Vertex<>();
    // 先将初始min的距离设置为无穷大
    min.setDistance(Integer.MAX_VALUE); 
    for (int i = 0; i < vertices.size(); i++) {
        Vertex<E> cur = vertices.get(i);
        // 在unknown顶点中找到具有有效距离的最小者，顶点距离初识为无距离(Integer.MAX_VALUE)
        if(!cur.isKnown() && cur.getDistance() < min.getDistance()) {
            min = cur;
        }
    }
    return min;
}
```



##### Dijkstra算法优先队列(堆)版

###### 算法描述

针对Dijkstra算法朴素版第2步在当前距离未确定顶点中寻找距离最小者，可以采用优先队列(小顶堆)进行改进，其他过程与朴素版一致。需要注意的是一个顶点的距离在被确定前可能经过多次松弛，算法在每次顶点距离松弛时将其入堆，于是同一时间，堆中可能有多个相同的顶点(松弛过几次就有几个)。这其中最靠顶的将会先出堆，出堆即表明该顶点距离已确定，所以顶点出堆时要判断是否是第一次出堆，若不是则跳过。



###### 算法过程

1. 初始化。设置一个用于输出出堆顶点顺序的结果列表res(不是必要的)。选定一个源点s，初始化所有顶点到源点s的距离为无穷大，表示该点到s的距离尚未确定，置s到其自身距离为0。准备一个小顶堆pq，将s入堆。

2. 一次有效出堆完成一个顶点最短路径的确定。以while循环对pq判空，若不空，堆顶顶点v出堆。若v不是第一次出堆则跳过，若是则v即此时未确定距离的顶点中距离最小者，置v的距离为已确定。

3. 松弛操作。更新上述顶点v的所有邻接顶点w到源点s的距离dw。有如下两种情况，因为在松弛前所有顶点的距离默认为无穷大，所以两种情形的形式一样，都是判断dv + d(v, w) < dw。dw被松弛则将w入堆，以支持第2步(在当前具有有效距离的顶点中找到距离最小者)。

   3.1  如果是初次访问，w到s的距离dw有效化为dw = dv + d(v, w)。

   3.2. 当w不是初次访问，当满足dv + d(v, w) < dw时，更新dw为dv + d(v, w)。

4. 当堆中无元素即所有顶点距离都确定时while循环结束，每个顶点v到源点的最短距离被求出。



###### 时空复杂度

时间复杂度：O(|E|log|E|+|E|log|E|)，化简为O(|E|log|E|)，可进一步化简为O(|E|log|V|) ，化简依据后述。

1. 在当前距离未确定顶点中寻找距离最小者 O(|E|log|E|)。while中pq判空耗时与堆大小有关，为O(|E|)，获取距离最小者耗时也与堆大小有关，为O(log|E|)，故为O(|E|log|E|)。

   ※ 优先队列判空操作isEmpty()本身是常数时间操作，但总共要执行|E|次。

2. 所有顶点的距离被更新(松弛)的次数上限为O(|E|)。由算法可知顶点距离的更新(或者说边的松弛)只发生在找到当前距离未确定且距离最小的顶点之后，一次更新的次数是该顶点的邻接顶点数(即出边数，出度)。每一次循环确定一个这样的顶点，也就是每一次循环松弛某一个顶点的所有出边。所有顶点的出边即总边数为|E|。故总松弛次数，也即所有顶点的距离被更新的次数，也即顶点入堆总次数为O(|E|)。dw更新时w入堆，插入操作的时间复杂度为O(log|E|)，入堆次数与更新次数相同，dw更新与w入堆的时间复杂度为O(|E|log|E|)，由于|E| <= |V|*(|V| - 1) ，故log|E| < 2log|V|，于是dw更新与w入堆的时间复杂度为O(|E|log|V|)。

   ※ 根据上述顶点入堆次数取决于总边数的分析，堆的大小上限不是|V|而是|E|(或者说是O(|E|))，所以dw更新时w入堆的插入操作的时间复杂度为O(log|E|)，只是借助边数与顶点数的关系，可化简为O(log|V|)。

空间复杂度：不考虑用于返回的顶点列表时为O(1)。

※ 连通图顶点数与边数的关系：

无向连通图：|V| - 1 <= |E| <= |V|*(|V| - 1) / 2 

链状时|E|取到最小|V|-1，完全连通即两两相连时取到最大|V|*(|V| - 1) / 2 

有向连通图：|V| - 1 <= |E| <= |V|*(|V| - 1) 

链状时|E|取到最小|V|-1，完全连通即两两相连且反向成时取到最大|V|*(|V| - 1) 



###### 代码

```java
public List<Vertex<E>> shortestPathDijkstraPQ(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>(); 
    s.setDistance(0);
    // 泛型PriorityQueue的写法，重写compare方法，比较元素getDistance()方法的结果，小顶堆
    PriorityQueue<Vertex<E>> pq = new PriorityQueue<>(new Comparator<Vertex<E>>() {
        @Override
        public int compare(Vertex<E> v1, Vertex<E> v2) {
            return v1.getDistance() - v2.getDistance();
        }
    });
    pq.add(s);

    while(!pq.isEmpty()) { // 判空 O(|E|)
        // 从unknowns中取出距离最小的顶点， O(log|E|)
        Vertex<E> v = pq.remove();
        // 当顶点v被更新过多次(多次入堆)，则存在v多次出堆的情况，
        // 跳过不是第一次出堆的顶点(v.isKnown = true)
        if(v.isKnown()) { 
            continue;
        }
        v.setKnown(true); // 置v的距离为已确定
        res.add(v); // 按顺序输出已确定距离的顶点
        // 松弛v的邻接顶点w，O(|E|log|E|)
        for (Vertex<E> w : getAdjList(v)) {
            if(!w.isKnown() && getEdgeValue(v, w) != 0) { // 松弛对象是距离未确定的w
                // 将dw初次赋有效值或dw有更新时的w加入到pq中，以保证算法过程第2步总是
                // 能够在所有“具有有效距离值但距离未确定”的顶点中寻找距离最小者。
                // 注意dw有更新的情况下堆中可能有多个w(dw不同)，因此插入次数上限与更新次数上限相同，为O(|E|)。
                int dw = v.getDistance() + getEdgeValue(v, w);
                if(dw < w.getDistance()) { // 松弛条件
                    w.setDistance(dw); // 更新dw
                    w.setPre(v); // 置w的前驱为v
                    pq.add(w); // 插入堆中，注意一个顶点的dw可能更新多次，O(log|E|)
                }
            }
        }
    }

    return res;
}
```



##### Dijkstra算法斐波那契堆版

###### 算法描述

###### 算法过程

###### 时空复杂度

###### 代码



##### Dijkstra算法无法处理负边图

如下图，顶点A是源点，从A开始执行算法，B.dist和C.dist被更新为1，2，在距离未确定的顶点B和C中B.dist更小，B的距离设为已确定，B.dist = 1，但实际上从A到C再到B会得到一条更短的的路径(-1)。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvys7ulosej308w08mjrb.jpg" alt="image-20211031204826493" style="float:left;zoom:50%;" />



##### Dijkstra算法之无圈图情形 (可处理有负边情形)

###### 算法描述

连通的有向无圈图有且仅有一个入度为0的顶点(超过1个则不连通，0个则有圈)，以该顶点为源点s，从s开始以拓扑排序方式实现Dijkstra算法。与拓扑排序一样，每次入度为0的顶点v出队，由于已无入边，故该顶点距离dv不会再被更新，此时dv即已确定。标准的Dijkstra算法的关键操作为“在当前具有有效距离且距离未确定的顶点中寻找距离最小者，并置其距离为已确定”，目的是每一次循环确定一个顶点的最短路径(贪婪)，所以也可将本算法看作是免去了引号所描述的操作的Dijkstra算法，即无需寻找，顶点出队时其距离即被确定。

**该算法可应用于有负边的图。** 对任意顶点而言，若到源点有更短路径，会一直更新至其入度为0。以下图为例，从A开始执行算法，A出队，B.dist和C.dist被更新为1和2，然后B，C入度减为1，0，C无入边，其距离不会再被更新，即最终C.dist = 1，C入队。接着C出队，B.dist被更新为-1，B的入度减为0，此时B无入边，其距离不会再被更新，即其距离被最终确定为B.dist = -1。可以看到B的距离在其入度减至0的过程中总有机会更新至最短。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvys7ulosej308w08mjrb.jpg" alt="image-20211031204826493" style="float:left;zoom:50%;" />



###### 算法过程

1. 设置一个用于保存拓扑排序的列表res(不是必要的)。设置一个队列q，置s的距离为0，s入队。
2. while中对q判空，若不空则队首顶点v出队，置其距离为已知，将v放入输出列表res中。
3. 遍历v的邻接顶点w，更新dw，置w的前驱为v。
4. 将v的邻接顶点w的入度减1，并检查减1后是否为0，为0则入队。
5. 当while结束时，输出列表中res出队的顶点顺序为拓扑排序，此时所有顶点前驱确定，源点s到其他顶点的最短路径确定。



###### 时空复杂度

时间复杂度：队列中每个顶点均入队一次，出队一次O(|V|)，在更新并检查邻接顶点的for中，更新和检查的总次数等于边数O(|E|)，故总的时间复杂度为O(|E|+|V|)。

空间复杂度：取决于队列长度，不大于|V|，O(|V|)。



###### 代码

```java
public List<Vertex<E>> shortestPathDijkstraDAG(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>();
    Queue<Vertex<E>> q = new LinkedList<>();
    s.setDistance(0);
    q.add(s);

    while(!q.isEmpty()) {
        Vertex<E> v = q.remove(); 
        v.setKnown(true);
        res.add(v);
        for (Vertex<E> w : getAdjList(v)) {
            if(getEdgeValue(v, w) != 0) { // 由于采用邻接矩阵方式存储，根据边权是否为0判断是否为真的邻接顶点
                int dw = v.getDistance() + getEdgeValue(v, w); // 顶点v的距离值+边(v,w)的权值
                if(dw < w.getDistance()) { // 若“v的距离+vw边权”小于w的距离，更新w的距离dw
                    w.setDistance(dw);
                    w.setPre(v);
                }
                w.setIndegree(w.getIndegree() - 1); // w的入度减1
                if(w.getIndegree() == 0) { // 考察w此时入度是否为0，为0则入队
                    q.add(w);
                }
            }
        }
    }

    return res;
}
```



##### Bellman-Ford算法

###### 算法描述

[Bellman-Ford Algorithm(贝尔曼-福特算法)](https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm): 与Dijkstra算法的相同点是对边(或者说对顶点)不断执行松弛操作，以逐渐得到所有顶点到源点的最短距离。Dijkstra每次循环完成一个顶点最短路径的确定，而BF算法则对图的所有边(|E|条边)，简单地进行|V|-1次全量松弛操作，即能保证(无负圈图)所有顶点距离取得最短。这是一种思路简单但复杂度较高的做法，每次全量松弛要操作|E|条边，共|V|-1次，复杂度为O((|V|-1)|E|)，即O(|V||E|)。算法正确性证明如下。



###### 正确性证明

1. 已知若一个顶点v的所有入边完成了所有可能的松弛(一条入边可被多次松弛)，则在最后一次松弛后，必有dv=δv。 (dv表示由算法得到的v的距离，δv表示实际的v的最短距离)。
2. 易知，第i次全量松弛，第i层顶点的出边必被松弛。例如第1次全量松弛，s(第1层顶点)的出边必被松弛。第2次全量松弛，s的邻接顶点(第2层顶点)的出边必被松弛。
3. 考察顶点v的所有入边，p(s, v)路径长(边数)最长不会超过|V|-1，当s到v为链状时取到最长|V|-1 。当v的入边是第1层入边时，将在第1次全量松弛时被松弛，若是第2层入边，则会在第2次全量松弛时被松弛(这条入边的发出顶点在第1次全量松弛时已被松弛)，以此类推，第i层入边会在第i次全量松弛时被松弛。所有顶点的入边组成了该图的所有边，任意一边一定是某一层次的入边(可以同时属于多个层次)。某一层顶点距离的更新，一定来自其入边的松弛。
4. 由此，v的入边能否被全部松弛只取决于最深的入边能否被松弛(当一条入边有多个层次时，取最深层次)，也即取决于s到v的最长路径max{p(s, v), v ∈ V}的长度。如前述，max{p(s, v), v ∈ V}  <= |V| - 1，故至多经过|V| - 1次全量松弛，图的所有入边必定都松弛过且完成了所有可能的松弛 (某条入边属于多个层次时，可能经过多次松弛) 。如果把图看成以s为根的树，也可以说为求得所有顶点的最短路径，所需的全量松弛的次数取决于树的高度。对某一顶点，可以说该顶点至多经过其深度次全量松弛后取得最短路径。
5. 上述过程对任意顶点均成立，故BF算法正确性得证。

以下考察BF算法对下图的求解过程，重点关注顶点v。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxehuw9wg2j30f60cqdga.jpg" alt="image-20211215141921008" style="float:left;zoom:50%;" />

p(s, v)有如下四种可能：

p1: s > v ，|p1| = 15，(s, v)是v的第1层入边

p2: s > a > v，|p2| = 14，(a, v)是v的第2层入边

p3: s > b > a > v，|p3| = 12，(a, v)是v的第3层入边

p4: s > b > c > v，|p4| = 6，(c, v)是v的第3层入边

可以看到(a, v)边同时属于v的第2和第3层入边。这四条路径最长者长3 (指边数，p3和p4)，根据上述分析，只需要执行3次全量松弛即可完成对v最短路径的确定。又因为源点到所有顶点的所有路径中最长的长度也是3，所以执行3次全量松弛可以确定所有顶点的最短路径。假设全量松弛时顶点的处理顺序为s, a, c, b, v，以下表展示算法对该图的运行过程(第3次之后的全量松弛不会再松弛任何边，省略)。

| 松弛过程      | ds        | da            | dc            | db            | dv                              | 备注                                                         |
| ------------- | --------- | ------------- | ------------- | ------------- | ------------------------------- | ------------------------------------------------------------ |
| 初始          | **0 (*)** | ∞             | ∞             | ∞             | ∞                               | 初始时令ds为0，(*)表示已取得该顶点最短路径。                 |
| 第1次全量松弛 | 0         | **∞ > 9**     | ∞             | **∞ > 3 (*)** | **∞ > 15**                      | (s, a), (s,b), (s, v)属于第1层入边，被松弛。<br />且b只有一条入边，即经过这趟松弛操作，实际上已取得db = δb。 |
| 第2次全量松弛 | 0         | **9 > 7 (*)** | **∞ > 5 (*)** | 3             | **15 > 14**                     | 第1层入边不会再被松弛。第2层入边(a, v), (b, a), (b, c)被松弛。<br />经过这趟松弛操作，a, c的全部入边松弛完毕，取得da = δa，dc = δc。 |
| 第3次全量松弛 | 0         | 7             | 5             | 3             | **14 > 12**<br />**12 > 6 (*)** | 第1，2层入边不会再被松弛，第3层入边(a, v), (c, v)被松弛。<br />v的全部入边松弛完毕，取得dv = δv。 |



###### 算法过程

1. 设置一个用于保存按顺序被松弛的顶点列表res(不是必要的)。置源点s的距离为0。
2. |V|-1次for循环，在该循环内执行对所有边的松弛操作。
3. 进入for后按顶点顺序依次对所有顶点v考察其所有邻接顶点w，是否有v.dist + d(v, w) < w.dist，若有，则松弛之，即令w.dist更新为v.dist + d(v, w)。
4. 在对所有边进行松弛的循环操作中，若某一次没有任何边被松弛，则退出第2步的循环，表明所有可能的松弛已完成(负圈图除外)。
5. 检查图是否有负圈。做法是再对所有边执行松弛操作，若有边可被松弛，则有负圈，结束程序，否则循环一遍后程序正常结束，所有顶点最短路径被求出。

**该算法可应用于有负边的图。**  由于该算法在|V|-1次对所有边的松弛操作中会穷尽所有边被松弛的可能，类似以拓扑排序方式针对DAG图的Dijkstra算法(通过入度为0保证穷尽所有松弛的可能)，所以也适用于有负边的图。

**最坏情形举例。**  当图为链状且每次松弛均从底端开始时达到最坏情形，需要对所有边执行|V|-1次松弛后才能求得所有顶点的最短路径。如下图：

假定每次循环均以v, c, b, a, s的顺序松弛，程序开始时置源点s的距离为0。

- 第1次循环只有a的距离被松弛为1

- 第2次循环b的距离被松弛为3

- 第3次循环c的距离被松弛为6

- 第4次循环v的距离被松弛为10

每次循环都对所有边尝试松弛，但每次只有一个顶点的距离被更新，经过|V|-1次即4次循环后才完成。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxekg5u1idj30ts04i0sz.jpg" alt="image-20211215154902192" style="float:left;zoom:35%;" />

**提前结束优化：** 当某一次全量松弛过程中没有边被松弛，说明所有可能的松弛已被穷尽，可提前结束程序。



###### 时空复杂度

时间复杂度：由上述分析可知为O(|V||E|)。

空间复杂度：不考虑用于返回的顶点列表时(对于寻找最短路径并不是必要的)时为O(1)。



###### 代码

```java
public List<Vertex<E>> shortestPathBF(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>();
    s.setDistance(0);

    for (int i = 0; i < vertices.size(); i++) {
        // 若某一次全量松弛没有边被松弛，则提前结束
        boolean finished = true;
        // 由于本程序未实现Edge类，用如下两个for实现对顶点v，松弛其所有边
        for (Vertex<E> v : vertices) {
            for(Vertex<E> w : getAdjList(v)) {
                if(getEdgeValue(v, w) != 0) {
                    // 当v的距离尚未被有效化时，dw会大于Integer.MAX_VALUE，所以要此处以long类型处理
                    long dw = (long)v.getDistance() + (long)getEdgeValue(v, w); 
                    if(dw < w.getDistance()) {
                        w.setDistance((int)dw);
                        w.setPre(v);
                        res.add(w); // 这里res表示对于被松弛的顶点，按被松弛的顺序放入，一个顶点可以被多次松弛
                        finished = false; // 若本次全量松弛过程中有边被松弛，标记为false表示未完成
                    }
                }
            }
        }
        if(finished) { // 若未true，表示某一次全量松弛没有边被松弛，提前结束
            break;
        }
    }
    // 负圈检测，再次对所有边执行松弛操作，若有边被松弛，说明存在负圈
    for (Vertex<E> v : vertices) {
        for(Vertex<E> w : getAdjList(v)) {
            if(getEdgeValue(v, w) != 0) {
                int dw = v.getDistance() + getEdgeValue(v, w);
                if(dw < w.getDistance()) {
                    System.err.println("存在负圈！");
                    return res;
                }
            }
        }
    }

    return res;
}
```



##### SPFA

###### 算法描述

BF算法通过对所有边执行|V|-1次松弛操作，保证了所有顶点的距离都能更新到最短。这一做法的本质是确保所有顶点的所有入边的所有可能的松弛均已完成，如果能够以更高的效率实现这一点，即可改进BF算法。实际上除源点外(源点的距离直接给出，为0)，一个顶点w的距离能够被更新，隐含着这样一个前提：w的前驱v的距离被更新过。因为dv + d(v, w) < dw时才会更新dw，而d(v, w)是不变的，初始时dv和dw都是无穷大，所以只有dv更新(变小)，dw才会更新(变小)，从这种链式反应风格的做法中可以看出SPFA算法本质上是DP的应用。从源点出发指向其邻接顶点，对一个连通的有向图，总能遍历所有顶点，每次考察已松弛的顶点v是否能松弛起邻接顶点w，w成为已松弛的顶点后再考察是否能松弛w的邻接顶点u，循环到“当前已松弛顶点均无法再松弛任何顶点”为止。于是可以设置一个队列q，程序开始时置源点s的距离为0，s入队。然后对q判空，不空时队首顶点v出队，松弛其边(即更新v的邻接顶点w的距离)，根据上述分析，如果dw有更新，那它的邻接顶点将能够被更新，所以将w入队，等待出队时尝试松弛w的边。重复这一过程，最后当q为空时(假设图无负圈)代表所有被更新过距离的顶点，都无法再触发其邻接顶点距离的更新，也即所有顶点入边带来的所有可能的对该顶点距离的更新确实已被穷尽，程序结束，并得到所有顶点到源点的最短路径。但若图存在负圈，while将无法结束。可以设置一个哈希表记录顶点入队的次数，可以证明，一个顶点入队次数大于|V|-1时，该图存在负圈，此时即可结束程序。



###### 正确性证明

SPFA算法与BF算法的核心内容都在于穷尽所有顶点入边(或者说所有路径)带来的所有可能的松弛。BF算法通过|V|-1次全量松弛达到 (详见BF算法正确性证明)，第i次全量松弛中，有效松弛仅作用于第i层的入边，前i-1层的入边已不能够被松弛却还是会被尝试，产生了冗余操作。SPFA算法利用前述一个顶点的距离能够被松弛的隐含前提，通过队列来减少松弛顶点距离的次数。第i层顶点入队时发生的松弛相当于BF算法中第i层入边的松弛，在连通性的保证下，以层序的方式完成所有层入边的松弛，因此该算法是正确的。

仍以下图为例考察SPFA算法的求解过程，进一步看清其正确性及SPFA与BF的关系。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gxehuw9wg2j30f60cqdga.jpg" alt="image-20211215141921008" style="float:left;zoom:50%;" />

第1层顶点只有s，所以第2步s出队相当于BF算法中第1次全量松弛的效果。a，b，v是第2层顶点，所以第3，4，5步相当于BF算法中第2次全量松弛的效果。此时v，a，c时第3层顶点 (根据所在路径层深的不同，一个顶点可以属于不同层)，所以接下来的第6，7，8相当于BF算法中的第3次全量松弛的效果。

| 松弛过程 | ds        | da            | dc            | db            | dv             | 队列q          | 备注                                                         |
| -------- | --------- | ------------- | ------------- | ------------- | -------------- | -------------- | ------------------------------------------------------------ |
| 1. 初始  | **0 (*)** | ∞             | ∞             | ∞             | ∞              | s              | 初始时令ds为0，(*)表示已取得该顶点最短路径。                 |
| 2. s出   | 0         | **∞ > 9**     | ∞             | **∞ > 3 (*)** | **∞ > 15**     | **a, b, v**    | s出队时松弛(s, a), (s,b), (s, v)。<br />且b只有一条入边，即经过这趟松弛操作，实际上已取得db = δb。 |
| 3. a出   | 0         | 9             | ∞             | 3             | **15 > 14**    | b, v, **v**    | a出队时松弛(a, v)，这是v的距离第2次被松弛。                  |
| 4. b出   | 0         | **9 > 7 (*)** | **∞ > 5 (*)** | 3             | 14             | v, v, **a, c** | b出队时松弛(b, a), (b, c)，a有两条路径，c只有一条，于是da = δa，dc = δc。 |
| 5. v出   | 0         | 7             | 5             | 3             | 14             | v, a, c        | 无可松弛边                                                   |
| 6. v出   | 0         | 7             | 5             | 3             | 14             | a, c           | 无可松弛边                                                   |
| 7. a出   | 0         | 7             | 5             | 3             | **14 > 12**    | c, **v**       | a出队时松弛(a, v)，这是v的距离第3次被松弛。                  |
| 8. c出   | 0         | 7             | 5             | 3             | **12 > 6 (*)** | v, **v**       | c出队时松弛(c, v)，这是v的距离第4次被松弛。<br />此时p(s, v)所有可能的路径带来的v的入边的松弛均已完成，于是dv = δv。 |
| 9. v出   | 0         | 7             | 5             | 3             | 14             | v              | 无可松弛边                                                   |
| 10. v出  | 0         | 7             | 5             | 3             | 14             | 空             | 无可松弛边，队列空，程序结束。                               |



###### 算法过程

1. 设置一个保存按顺序出队的顶点的列表(不是必要的)，设置一个队列q，置源点s的距离为0，s入队。
2. 设置一个用于支持负圈检测的记录所有顶点入队次数的哈希表。
3. 以while循环对q判空，若q不空，队首顶点v出队，将v加入结果列表中。
4. 遍历v的邻接顶点w，若满足松弛条件，则更新w的距离，置w的前驱为v，将w入队，并检查w的入队次数是否大于|V|，若大于则表示存在负圈，结束程序。

SPFA也能应用于有负权的非负圈图，原因于BF算法类似。

**负圈判定：**由于出现负圈时while会无限循环下去，因此需要提前记录保存每个顶点入队的次数(例如用哈希表记录)，顶点v的距离更新后判断当前更新次数是否超过了|V|-1次，若超过则说明存在负圈，若不超过则将更新次数加1。以层为单位追踪顶点入队出队的过程，不难理解无负圈情况下，一个顶点的距离至多被松弛(顶点入队) |V|-1次，若超过则说明存在经过该顶点的负圈。



###### 时空复杂度

时间复杂度：顶点v入队次数上限取决于p(s, v)路径的条数，间接取决于v的入边数，上限为|E|，共|V|个顶点，时间复杂度为O(|V||E|)。

空间复杂度：用于支持负圈检测的哈希表的空间，O(|V|)。

对时间复杂度的分析可以看出，稀疏图中顶点的p(s, v)路径平均条数很少，SPFA实际运行速度会很快。稠密图下会达到O(|V||E|)。



###### 代码

```java
public List<Vertex<E>> shortestPathSPFA(Vertex<E> s){
    List<Vertex<E>> res = new ArrayList<>();
    s.setDistance(0);
    Queue<Vertex<E>> q = new LinkedList<>();
    q.add(s);
    // 设置一个HashMap记录每个顶点入队次数，以支持负圈检测
    Map<Vertex<E>, Integer> inCounter = new HashMap<>();
    for (Vertex<E> v : vertices) {
        inCounter.put(v, 0);
    }

    while(!q.isEmpty()) {
        Vertex<E> v = q.remove(); 
        res.add(v);
        for (Vertex<E> w : getAdjList(v)) {
            if(getEdgeValue(v, w) != 0) { // 只对v的邻边操作
                int dw = v.getDistance() + getEdgeValue(v, w);
                if(dw < w.getDistance()) { // 若源点经过顶点v到顶点w的距离小于源点到w的距离，更新源点w的距离
                    w.setDistance(dw);
                    w.setPre(v);
                    q.add(w); // 当w有松弛操作时将w加入队列
                    // 在w入队后判断当前入队次数，若大于|V|-1则检出负圈，输出提示信息并结束程序
                    int wInCount = inCounter.get(w);
                    if(wInCount > vertices.size() - 1) {
                        System.err.println("存在负圈！");
                        return res;
                    }
                    inCounter.put(w, wInCount + 1);
                }
            }
        }
    }

    return res;
}
```



#### 所有点对最短路径 (Floyd-Warshall算法)

##### 算法描述

[Floyd算法(Floyd-Warshall Algorithm)](https://en.wikipedia.org/wiki/Floyd%E2%80%93Warshall_algorithm): 求解图中任意两点的最短路径的算法。图可以是有向图或无向图，可以有负权边，但不能有负圈(负圈上任意两点间无最短路径)。



##### 算法过程



##### 正确性证明

利用数学归纳法证明如下命题。

命题P：任意顶点i到任意顶点j之间存在最短路径p(i, j)，若这条路径的点集是(i, v1, v2, ..., vn, j)，其中v1,v2...vn的1~n的数字标号表示在Floyd-Warshall算法外层循环中被处理的先后顺序，那么本命题宣称在外层循环处理顶点vn时，i到j的最短路径长度D(i, j)被确定。

1. 起始验证。

   当n = 0时，即p(i, j) = i > j (*1)，D(i, j) = |edge(i, j)|，这在程序一开始的初始化阶段即得到，故n = 0满足命题。

   当n = 1时，即p(i, j) = i > v1 > j，外层循环在处理v1时，通过内层的两个循环，将D(i, v1) + D(v1, j)的结果用于更新D(i, j)，故n = 1满足命题。为了帮助理解，以下继续说明n = 2的情形。

   当n = 2时，例如p(i, j) = i > v2 > v1 > j，外层循环首先处理v1(注意vk的k表示在外层循环中的处理顺序)，由n = 1情形的分析，v2到j的最短路径p(v2, j)的路径长度D(v2, j)被确定(*2)。接着外层循环处理v2(外层循环在v1和v2之间可以处理其他的顶点)，显然，通过内层的两个for，可以将D(i, j)更新为D(i, v2) + D(v2, j)。

   *1 p(i, j) = i > j，p(i, j) = i > v1 > j中的">"表现方向和顺序。

   *2 已知任意两点i, j之间的最短路径为p，那么p上的任意两点的最短路径确定在p上。反证法简单可证。假设p上有b, c两点，这两点之间的最短路径经过一不在p上的顶点，那i, j的最短路径也就不是p，而是p(i, b) + p(b, c) + p(c, j)。

2. 假设命题成立。假设命题P在n小于等于m时，P(m)成立，即外层循环在处理顶点vn时，i到j的最短路径(p(i, j) = i > ... > vn > ... > j)长度D(i, j)被确定。再次强调，vn可以是路径p(i, j)中的任意位置的顶点，但一定是外层循环中这条路径上i和j之间的n个顶点中最后被处理的那个。

3. P(m+1)递推证明。根据2的假设，当i到j的最短路径为p(i, j) = i > ... > v(m+1) > ... > j时，在外层循环处理v(m+1)时，通过内层的两个for循环，会计算D(i, v(m+1)) + D(v(m+1), j)。路径p(i, v(m+1)和p(v(m+1), j))的顶点个数都小于等于m。根据2的假设，D(i, v(m+1)) 和D(v(m+1), j)都已经被确定，故D(i, j)被确定。

经过上述归纳法证明过程，命题P得证。



下面通过一个例子观察Floyd算法的动态规划过程。

设图G中i, j间最短路径为 i > a > b > c > d > e > f > g > h > j。最外层循环对该路径上顶点的处理顺序可以是任意顺序，例如b, h, i, g, a, e, j, f, c, d(分别标上序号1, 2, 3, 4, 5, 6, 7, 8, 9, 10，表示外层循环处理的先后顺序)。为了更方便看清楚动态规划的过程，可以从处理最后一个顶点d得到D(i, j)这一步开始溯源，且只观察程序对上述十个顶点的处理(不观察其他顶点不影响结果，因为其他顶点不在该最短路径上)。

外层循环处理d之后由D(i, d) + D(d, j)的结果得到i到j的最短路径长D(i, j)，因此D(i, d)和D(d, j)此时必是已知的。继续溯源，i到d的路径上c是最后被处理的，处理c时计算D(i, d) = D(i, c) + D(c, d)，其中D(c, d)是边长，程序开始时已知，D(i, c)需要继续溯源，D(i, c) = D(i, a) + D(a, c)，其中D(i, a)是边长，D(a, c) = D(a, b) + D(b, c)，D(a, b)和D(b, c)是边长。其余过程如图，标红处表示相邻的顶点的边长，在程序开始时得到。

可以看出，外层循环处理i到j的最短路径的所有顶点的过程中，先处理的顶点总能够为后处理的顶点提供完整的最短路径信息，这正是动态规划过程的体现。

<img src="https://tva1.sinaimg.cn/large/008i3skNly1gxlre6dkzlj312k0pyace.jpg" alt="image-20211221210813747" style="zoom:50%;" />

![floyd-demo](https://tva1.sinaimg.cn/large/008i3skNgy1gxlu0xqdbng31fu0qonpj.gif)





##### 时空复杂度



##### 代码



### 最短路径例子：词梯问题



## 网络流问题

### 最大流最小割定理(Max-flow min-cut theorem)

对于一个网络流(图)，从源点到目标点的最大的流量等于最小割的每一条边的和。

流

割和割的大小

无权有向图两点间不相交路径数量问题

添加反向增广路不影响结果的证明

下界和上界

推广至有权图

最大流最小割定理

### Ford-Fulkerson方法

[福特-富尔克森方法](https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm)1956年由L. R. Ford Jr和D. R. Fulkerson发表的用于求有向图最大流的算法。因为该算法未完全明确指定求增广路径的方法，所以通常也将其称作福特-福尔克森方法。若增广路径以BFS方式求出，则为Edmonds-Karp算法。

#### 算法描述

给定一张边的容量为c的图G(V, E)，源点s和汇点t。求G中从s到t的最大流f。

1. 设置一张流量图Gf和一张残余图Gr，初始化Gf为边权均为0的图G，Gr为G。
2. 考察Gr中是否有从s到t的路径p，使得p上的每一条边(u,v) ∈ p，都有cr(u, v) > 0。p称作增广路径(Augmenting Path)。若存在p，则：
   2.1 将p中最小边的权加到Gf中相同位置的每条边上。
   2.2 在Gr中p的每条边减去该最小边的权。
   2.3 在Gr中p的反向路径上的每条边上加上该最小边权。
3. 在Gr中反复寻找增广路径p并执行2中的操作直到Gr中找不到p，算法停止。
4. 在Gr中定义S为s可以达到的点的集合，T是剩余点的集合，在G中，S到T的割的大小即为所求的最大流。

#### 坏情形

**增广路径选取的坏情形：**

如下图，寻找从A到B的增广路径时，若总是选取A>B>C>D，由于小权边限制了流的大小，需经历1000次选取才能结束算法，而选取A>B>D，A>C>D则只需要两次，有两种做法能够有效解决。

做法1: 总是选取流最大的增广路径。显然能够避免小权边引起的多次增广路选取。利用Dijkstra算法，将顶点距离的更新策略从选取较小值改为选取较大值，即可实现该做法。

做法2: 总是选取最短的增广路径。较短的增广路降低了路径上出现小权边的概率。该做法显然可以用无权最短路径实现。

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvev606qcyj60ey0a0mxg02.jpg" style="float:left;zoom:50%;" />

**边权值的坏情形：**



#### 时空复杂度

时间复杂度：设最大流为f，算法过程为穷尽增广路径的过程，以无权最短路径算法(即上述做法2，总是选取最短的增广路径)寻找一条s到t的增广路径需O(E) (O(E+V)可表成O(E)) 时间，而每找到一条增广路径，至少增加1个单位的流量，故总的时间复杂度为O(E*f)。

空间复杂度：取决于求最短路径时用到的队列的长度，O(|V|)。

### Edmonds-Karp算法

[埃德蒙兹-卡普算法]()



### Dinic算法

<img src="https://tva1.sinaimg.cn/large/008i3skNgy1gvfw5jat8ij608a0aiaa502.jpg" style="float:left;zoom:50%;" />

朴素Dinic算法中，在当前分层图下，每次主程序(对singleAugPathDFS来说的主程序是multipleAugPathDFS)主调用DFS(singleAugPathDFS)找到一条增广路后，会一直return到本次主调用结束。然后主程序基于`(singleAugFlow = singleAugPathDFS(des, current, singleAugFlow)) != 0`的判断再次调用DFS，又一次从src顶点开始搜索下一条到des的增广路。以上图为例，增广过程如下：

第一次主调：s>a>c>t, 找到增广路后return，得到minEdge，且minEdge > 0，修改正向和反向边权后return，t>c>a>s然后退出主调用，本次主调结束，得到本次增广路发送流为2。整体的顶点访问顺序为s>a>c>t>c>a>s。

第二次主调：s>a>c，发现(c, t)边权为0，不满足isAdjacent(current, w)条件，找a的下一个满足层号关系的邻接顶点d，然后d>t，同上，找到增广路后在return过程中修改正反向边权，t>d>a>s后退出主调用，本次主调结束，得到本次增广路发送流为1。整体的顶点访问顺序为s>a>c>d>t>d>a>s。

第三次主调：从s开始，发现(s, a)边权为0，不满足isAdjacent(current, w)条件，找s的下一个满足层号关系的邻接顶点b，然后b>d>t，同上，找到增广路后在return过程中修改正反向边权，t>d>b>s后退出主调用，本次调用结束，得到本次增广路发送流为2。整体的顶点访问顺序为s>b>d>t>d>b>s。

第四次主调：从s开始，for循环遍历所有邻接顶点均不满足isAdjacent(current, w)条件，返回0 (`return 0;`)，于是主调方法的while也结束，得到最终结果maxFlow = 5.

注意：对DFS的主调用这个描述是为了区别于DFS的递归调用。

#### 优化1: 一次DFS主调用实现多路增广

通过上述对程序运行过程的分析，可以看到每次对DFS的主调，得到增广路后不断回退到主调结束，然后再利用下一次主调寻找下一条增广路。如果在找到增广路后不是一路回退，而是在回退到上一个节点后继续探索其下一个满足条件的邻接顶点，那么可以期待一次主调就能完成当前分层图下所有增广路的寻找，得到当前分层图下源点可发送的最大流multipleAugFlow。做法如下：

1. 为每一个顶点维护一个可用流数据(flow)，源点可用流设置为Integer.MAX_VALUE。
2. 在分层图中利用DFS搜索增广路的过程中，更新当前顶点u的flow值。假设u的前驱顶点为v，则u.flow = min(v.flow, edgeValue(v, u))。
3. 找到增广路时会得到本条增广路的最小边权singleAugFlow。注意，基础版本在BFS增广过程维护一个增广路上的最小边权，增广完成后以其为本次增广的发送流，在优化1中，增广完成时，本次增广的发送流singleAugFlow是当前汇点的可用流，即`singleAugFlow = des.flow`。在2中已经知道，每一个顶点的可用流都是在以它为当前顶点时更新或赋予的。
4. 得到singleAugFlow后回退，与基础版本算法一样，每回退到当前顶点v(假设其后继顶点为u)，将正向边(v, u)边权减去singleAugFlow，将反向边(u, v)边权加上singleAugFlow。同时，在优化1版本中会令u的可用流减去singleAugFlow，即u.flow -= singleAugFlow (这一点是实现优化的关键！)。接着不是继续回退，而是考察u的下一个满足条件的邻接顶点，假设存在，为顶点w。同样，先求w的可用流w.flow = min(u.flow, edgeValue(u, w))。可以看到顶点u在寻找经过它的下一条增广路时，携带了其可发送的流大小的信息(u.flow)，继续向汇点更新新增广路上的顶点的可用流时，都会受到当前u.flow的限制，即如果存在新的从u到汇点的增广路，汇点des的可用流最多为u.flow(当u.flow相比于该路径上所有边权最小时)，由于最终`singleAugFlow = des.flow`，所以新的增广路可发送流最多也只能够是singleAugFlow = u.flow。本次增广后从汇点des回退到u，回退过程同前述，对每个回退到的顶点(k)执行k.flow -= singleAugFlow，调整路径上每条边的正反向边权，最终再次回到u，u再次减去本次singleAugFlow。当当前顶点的可用流为0，即u.flow = 0时，无需再考察从u到它的其他邻接顶点的新的增广路的可能性，直接break跳出。
5. 当源点src遍历完所有邻接顶点时，当前分层图的所有增广路被找到，返回src的多路增广可发送流大小。

#### 优化2: 当前弧优化

朴素Dinic算法中，假设源点src有多个邻接顶点A，B，C，D....。每次DFS都会从源点第一个邻接顶点A开始尝试增广，假设经过A有两条增广路。那么两次主调用DFS后，经过A的两条增广路都被找到，接着第3次主调用DFS，从A开始尝试增广，显然已无法经过A增广，于是尝试B，假设经过B有一条增广路，于是第3次主调用DFS的结果是找到经过B的一条增广路。接着第4次主调用DFS，此时仍然会从A开始尝试，到这里我们就可以发现，尽管经过A的增广路早已被穷尽，但每次对DFS的新的主调用，还是会从源点的第一个邻接顶点A开始尝试增广，这显然是无谓的开销。每次主调DFS时，不是从源点的第一个邻接顶点开始，而是从上一次主调所处理的那个源点的邻接顶点开始，就可以避免上述无谓的开销。如前述，经过3次对DFS的主调用，已经完成了经过A，B共3条增广路的寻找，在第4次主调用DFS时，不是从A开始，而是从B开始(注意不是C)尝试，已无经过B的增广路，于是寻找下一个邻接顶点C，执行经过C的增广路的寻找。下一次对DFS的主调用，从C开始(注意不是D)。这就是“当前弧优化”。

注意：当前弧优化是针对朴素Dinic算法来说的，如果已经实现了优化1，在当前分层图下，对DFS只需执行一次主调用，也就不存在当前弧优化所解决的问题。

### 最小费用流问题

## 最小生成树



### Prim算法



### Kruskal算法



## 深度优先搜索的应用



### 无向图



#### 判断无向图的连通性



#### 寻找无向图中的割点



#### 解决欧拉回路问题



### 有向图



#### 判断有向图是否无圈



#### 判断有向图是否强连通

[^1]: https://www.zhihu.com/question/57206374 为什么Dijkstra算法每轮递推能够保证找到一个顶点的最短路径？